module Glace2d;

with Math.*;

connectivities {
	nodes1: (∅) → {node};
	cells1: (∅) → {cell};
	outerFaces1: (∅) → {face};
	innerNodes1: (∅) → {node};
	nodesOfCell1: (cell) → {node};
	cellsOfNode1: (node) → {cell};
	nodesOfFace1: (face) → {node};
}

functions {
	trace1: (ℝ²ˣ²) → ℝ;
	perp1: (ℝ²) → ℝ²;
	tensProduct1: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct1: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse1: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes2: (∅) → {node};
	cells2: (∅) → {cell};
	outerFaces2: (∅) → {face};
	innerNodes2: (∅) → {node};
	nodesOfCell2: (cell) → {node};
	cellsOfNode2: (node) → {cell};
	nodesOfFace2: (face) → {node};
}

functions {
	trace2: (ℝ²ˣ²) → ℝ;
	perp2: (ℝ²) → ℝ²;
	tensProduct2: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct2: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse2: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes3: (∅) → {node};
	cells3: (∅) → {cell};
	outerFaces3: (∅) → {face};
	innerNodes3: (∅) → {node};
	nodesOfCell3: (cell) → {node};
	cellsOfNode3: (node) → {cell};
	nodesOfFace3: (face) → {node};
}

functions {
	trace3: (ℝ²ˣ²) → ℝ;
	perp3: (ℝ²) → ℝ²;
	tensProduct3: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct3: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse3: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes4: (∅) → {node};
	cells4: (∅) → {cell};
	outerFaces4: (∅) → {face};
	innerNodes4: (∅) → {node};
	nodesOfCell4: (cell) → {node};
	cellsOfNode4: (node) → {cell};
	nodesOfFace4: (face) → {node};
}

functions {
	trace4: (ℝ²ˣ²) → ℝ;
	perp4: (ℝ²) → ℝ²;
	tensProduct4: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct4: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse4: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes5: (∅) → {node};
	cells5: (∅) → {cell};
	outerFaces5: (∅) → {face};
	innerNodes5: (∅) → {node};
	nodesOfCell5: (cell) → {node};
	cellsOfNode5: (node) → {cell};
	nodesOfFace5: (face) → {node};
}

functions {
	trace5: (ℝ²ˣ²) → ℝ;
	perp5: (ℝ²) → ℝ²;
	tensProduct5: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct5: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse5: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes6: (∅) → {node};
	cells6: (∅) → {cell};
	outerFaces6: (∅) → {face};
	innerNodes6: (∅) → {node};
	nodesOfCell6: (cell) → {node};
	cellsOfNode6: (node) → {cell};
	nodesOfFace6: (face) → {node};
}

functions {
	trace6: (ℝ²ˣ²) → ℝ;
	perp6: (ℝ²) → ℝ²;
	tensProduct6: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct6: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse6: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes7: (∅) → {node};
	cells7: (∅) → {cell};
	outerFaces7: (∅) → {face};
	innerNodes7: (∅) → {node};
	nodesOfCell7: (cell) → {node};
	cellsOfNode7: (node) → {cell};
	nodesOfFace7: (face) → {node};
}

functions {
	trace7: (ℝ²ˣ²) → ℝ;
	perp7: (ℝ²) → ℝ²;
	tensProduct7: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct7: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse7: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes8: (∅) → {node};
	cells8: (∅) → {cell};
	outerFaces8: (∅) → {face};
	innerNodes8: (∅) → {node};
	nodesOfCell8: (cell) → {node};
	cellsOfNode8: (node) → {cell};
	nodesOfFace8: (face) → {node};
}

functions {
	trace8: (ℝ²ˣ²) → ℝ;
	perp8: (ℝ²) → ℝ²;
	tensProduct8: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct8: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse8: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes9: (∅) → {node};
	cells9: (∅) → {cell};
	outerFaces9: (∅) → {face};
	innerNodes9: (∅) → {node};
	nodesOfCell9: (cell) → {node};
	cellsOfNode9: (node) → {cell};
	nodesOfFace9: (face) → {node};
}

functions {
	trace9: (ℝ²ˣ²) → ℝ;
	perp9: (ℝ²) → ℝ²;
	tensProduct9: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct9: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse9: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes10: (∅) → {node};
	cells10: (∅) → {cell};
	outerFaces10: (∅) → {face};
	innerNodes10: (∅) → {node};
	nodesOfCell10: (cell) → {node};
	cellsOfNode10: (node) → {cell};
	nodesOfFace10: (face) → {node};
}

functions {
	trace10: (ℝ²ˣ²) → ℝ;
	perp10: (ℝ²) → ℝ²;
	tensProduct10: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct10: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse10: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes11: (∅) → {node};
	cells11: (∅) → {cell};
	outerFaces11: (∅) → {face};
	innerNodes11: (∅) → {node};
	nodesOfCell11: (cell) → {node};
	cellsOfNode11: (node) → {cell};
	nodesOfFace11: (face) → {node};
}

functions {
	trace11: (ℝ²ˣ²) → ℝ;
	perp11: (ℝ²) → ℝ²;
	tensProduct11: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct11: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse11: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes12: (∅) → {node};
	cells12: (∅) → {cell};
	outerFaces12: (∅) → {face};
	innerNodes12: (∅) → {node};
	nodesOfCell12: (cell) → {node};
	cellsOfNode12: (node) → {cell};
	nodesOfFace12: (face) → {node};
}

functions {
	trace12: (ℝ²ˣ²) → ℝ;
	perp12: (ℝ²) → ℝ²;
	tensProduct12: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct12: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse12: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes13: (∅) → {node};
	cells13: (∅) → {cell};
	outerFaces13: (∅) → {face};
	innerNodes13: (∅) → {node};
	nodesOfCell13: (cell) → {node};
	cellsOfNode13: (node) → {cell};
	nodesOfFace13: (face) → {node};
}

functions {
	trace13: (ℝ²ˣ²) → ℝ;
	perp13: (ℝ²) → ℝ²;
	tensProduct13: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct13: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse13: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes14: (∅) → {node};
	cells14: (∅) → {cell};
	outerFaces14: (∅) → {face};
	innerNodes14: (∅) → {node};
	nodesOfCell14: (cell) → {node};
	cellsOfNode14: (node) → {cell};
	nodesOfFace14: (face) → {node};
}

functions {
	trace14: (ℝ²ˣ²) → ℝ;
	perp14: (ℝ²) → ℝ²;
	tensProduct14: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct14: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse14: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes15: (∅) → {node};
	cells15: (∅) → {cell};
	outerFaces15: (∅) → {face};
	innerNodes15: (∅) → {node};
	nodesOfCell15: (cell) → {node};
	cellsOfNode15: (node) → {cell};
	nodesOfFace15: (face) → {node};
}

functions {
	trace15: (ℝ²ˣ²) → ℝ;
	perp15: (ℝ²) → ℝ²;
	tensProduct15: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct15: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse15: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes16: (∅) → {node};
	cells16: (∅) → {cell};
	outerFaces16: (∅) → {face};
	innerNodes16: (∅) → {node};
	nodesOfCell16: (cell) → {node};
	cellsOfNode16: (node) → {cell};
	nodesOfFace16: (face) → {node};
}

functions {
	trace16: (ℝ²ˣ²) → ℝ;
	perp16: (ℝ²) → ℝ²;
	tensProduct16: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct16: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse16: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes17: (∅) → {node};
	cells17: (∅) → {cell};
	outerFaces17: (∅) → {face};
	innerNodes17: (∅) → {node};
	nodesOfCell17: (cell) → {node};
	cellsOfNode17: (node) → {cell};
	nodesOfFace17: (face) → {node};
}

functions {
	trace17: (ℝ²ˣ²) → ℝ;
	perp17: (ℝ²) → ℝ²;
	tensProduct17: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct17: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse17: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes18: (∅) → {node};
	cells18: (∅) → {cell};
	outerFaces18: (∅) → {face};
	innerNodes18: (∅) → {node};
	nodesOfCell18: (cell) → {node};
	cellsOfNode18: (node) → {cell};
	nodesOfFace18: (face) → {node};
}

functions {
	trace18: (ℝ²ˣ²) → ℝ;
	perp18: (ℝ²) → ℝ²;
	tensProduct18: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct18: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse18: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes19: (∅) → {node};
	cells19: (∅) → {cell};
	outerFaces19: (∅) → {face};
	innerNodes19: (∅) → {node};
	nodesOfCell19: (cell) → {node};
	cellsOfNode19: (node) → {cell};
	nodesOfFace19: (face) → {node};
}

functions {
	trace19: (ℝ²ˣ²) → ℝ;
	perp19: (ℝ²) → ℝ²;
	tensProduct19: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct19: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse19: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes20: (∅) → {node};
	cells20: (∅) → {cell};
	outerFaces20: (∅) → {face};
	innerNodes20: (∅) → {node};
	nodesOfCell20: (cell) → {node};
	cellsOfNode20: (node) → {cell};
	nodesOfFace20: (face) → {node};
}

functions {
	trace20: (ℝ²ˣ²) → ℝ;
	perp20: (ℝ²) → ℝ²;
	tensProduct20: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct20: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse20: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes21: (∅) → {node};
	cells21: (∅) → {cell};
	outerFaces21: (∅) → {face};
	innerNodes21: (∅) → {node};
	nodesOfCell21: (cell) → {node};
	cellsOfNode21: (node) → {cell};
	nodesOfFace21: (face) → {node};
}

functions {
	trace21: (ℝ²ˣ²) → ℝ;
	perp21: (ℝ²) → ℝ²;
	tensProduct21: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct21: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse21: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes22: (∅) → {node};
	cells22: (∅) → {cell};
	outerFaces22: (∅) → {face};
	innerNodes22: (∅) → {node};
	nodesOfCell22: (cell) → {node};
	cellsOfNode22: (node) → {cell};
	nodesOfFace22: (face) → {node};
}

functions {
	trace22: (ℝ²ˣ²) → ℝ;
	perp22: (ℝ²) → ℝ²;
	tensProduct22: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct22: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse22: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes23: (∅) → {node};
	cells23: (∅) → {cell};
	outerFaces23: (∅) → {face};
	innerNodes23: (∅) → {node};
	nodesOfCell23: (cell) → {node};
	cellsOfNode23: (node) → {cell};
	nodesOfFace23: (face) → {node};
}

functions {
	trace23: (ℝ²ˣ²) → ℝ;
	perp23: (ℝ²) → ℝ²;
	tensProduct23: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct23: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse23: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes24: (∅) → {node};
	cells24: (∅) → {cell};
	outerFaces24: (∅) → {face};
	innerNodes24: (∅) → {node};
	nodesOfCell24: (cell) → {node};
	cellsOfNode24: (node) → {cell};
	nodesOfFace24: (face) → {node};
}

functions {
	trace24: (ℝ²ˣ²) → ℝ;
	perp24: (ℝ²) → ℝ²;
	tensProduct24: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct24: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse24: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes25: (∅) → {node};
	cells25: (∅) → {cell};
	outerFaces25: (∅) → {face};
	innerNodes25: (∅) → {node};
	nodesOfCell25: (cell) → {node};
	cellsOfNode25: (node) → {cell};
	nodesOfFace25: (face) → {node};
}

functions {
	trace25: (ℝ²ˣ²) → ℝ;
	perp25: (ℝ²) → ℝ²;
	tensProduct25: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct25: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse25: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes26: (∅) → {node};
	cells26: (∅) → {cell};
	outerFaces26: (∅) → {face};
	innerNodes26: (∅) → {node};
	nodesOfCell26: (cell) → {node};
	cellsOfNode26: (node) → {cell};
	nodesOfFace26: (face) → {node};
}

functions {
	trace26: (ℝ²ˣ²) → ℝ;
	perp26: (ℝ²) → ℝ²;
	tensProduct26: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct26: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse26: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes27: (∅) → {node};
	cells27: (∅) → {cell};
	outerFaces27: (∅) → {face};
	innerNodes27: (∅) → {node};
	nodesOfCell27: (cell) → {node};
	cellsOfNode27: (node) → {cell};
	nodesOfFace27: (face) → {node};
}

functions {
	trace27: (ℝ²ˣ²) → ℝ;
	perp27: (ℝ²) → ℝ²;
	tensProduct27: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct27: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse27: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes28: (∅) → {node};
	cells28: (∅) → {cell};
	outerFaces28: (∅) → {face};
	innerNodes28: (∅) → {node};
	nodesOfCell28: (cell) → {node};
	cellsOfNode28: (node) → {cell};
	nodesOfFace28: (face) → {node};
}

functions {
	trace28: (ℝ²ˣ²) → ℝ;
	perp28: (ℝ²) → ℝ²;
	tensProduct28: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct28: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse28: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes29: (∅) → {node};
	cells29: (∅) → {cell};
	outerFaces29: (∅) → {face};
	innerNodes29: (∅) → {node};
	nodesOfCell29: (cell) → {node};
	cellsOfNode29: (node) → {cell};
	nodesOfFace29: (face) → {node};
}

functions {
	trace29: (ℝ²ˣ²) → ℝ;
	perp29: (ℝ²) → ℝ²;
	tensProduct29: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct29: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse29: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes30: (∅) → {node};
	cells30: (∅) → {cell};
	outerFaces30: (∅) → {face};
	innerNodes30: (∅) → {node};
	nodesOfCell30: (cell) → {node};
	cellsOfNode30: (node) → {cell};
	nodesOfFace30: (face) → {node};
}

functions {
	trace30: (ℝ²ˣ²) → ℝ;
	perp30: (ℝ²) → ℝ²;
	tensProduct30: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct30: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse30: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes31: (∅) → {node};
	cells31: (∅) → {cell};
	outerFaces31: (∅) → {face};
	innerNodes31: (∅) → {node};
	nodesOfCell31: (cell) → {node};
	cellsOfNode31: (node) → {cell};
	nodesOfFace31: (face) → {node};
}

functions {
	trace31: (ℝ²ˣ²) → ℝ;
	perp31: (ℝ²) → ℝ²;
	tensProduct31: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct31: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse31: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes32: (∅) → {node};
	cells32: (∅) → {cell};
	outerFaces32: (∅) → {face};
	innerNodes32: (∅) → {node};
	nodesOfCell32: (cell) → {node};
	cellsOfNode32: (node) → {cell};
	nodesOfFace32: (face) → {node};
}

functions {
	trace32: (ℝ²ˣ²) → ℝ;
	perp32: (ℝ²) → ℝ²;
	tensProduct32: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct32: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse32: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes33: (∅) → {node};
	cells33: (∅) → {cell};
	outerFaces33: (∅) → {face};
	innerNodes33: (∅) → {node};
	nodesOfCell33: (cell) → {node};
	cellsOfNode33: (node) → {cell};
	nodesOfFace33: (face) → {node};
}

functions {
	trace33: (ℝ²ˣ²) → ℝ;
	perp33: (ℝ²) → ℝ²;
	tensProduct33: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct33: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse33: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes34: (∅) → {node};
	cells34: (∅) → {cell};
	outerFaces34: (∅) → {face};
	innerNodes34: (∅) → {node};
	nodesOfCell34: (cell) → {node};
	cellsOfNode34: (node) → {cell};
	nodesOfFace34: (face) → {node};
}

functions {
	trace34: (ℝ²ˣ²) → ℝ;
	perp34: (ℝ²) → ℝ²;
	tensProduct34: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct34: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse34: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes35: (∅) → {node};
	cells35: (∅) → {cell};
	outerFaces35: (∅) → {face};
	innerNodes35: (∅) → {node};
	nodesOfCell35: (cell) → {node};
	cellsOfNode35: (node) → {cell};
	nodesOfFace35: (face) → {node};
}

functions {
	trace35: (ℝ²ˣ²) → ℝ;
	perp35: (ℝ²) → ℝ²;
	tensProduct35: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct35: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse35: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes36: (∅) → {node};
	cells36: (∅) → {cell};
	outerFaces36: (∅) → {face};
	innerNodes36: (∅) → {node};
	nodesOfCell36: (cell) → {node};
	cellsOfNode36: (node) → {cell};
	nodesOfFace36: (face) → {node};
}

functions {
	trace36: (ℝ²ˣ²) → ℝ;
	perp36: (ℝ²) → ℝ²;
	tensProduct36: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct36: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse36: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes37: (∅) → {node};
	cells37: (∅) → {cell};
	outerFaces37: (∅) → {face};
	innerNodes37: (∅) → {node};
	nodesOfCell37: (cell) → {node};
	cellsOfNode37: (node) → {cell};
	nodesOfFace37: (face) → {node};
}

functions {
	trace37: (ℝ²ˣ²) → ℝ;
	perp37: (ℝ²) → ℝ²;
	tensProduct37: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct37: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse37: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes38: (∅) → {node};
	cells38: (∅) → {cell};
	outerFaces38: (∅) → {face};
	innerNodes38: (∅) → {node};
	nodesOfCell38: (cell) → {node};
	cellsOfNode38: (node) → {cell};
	nodesOfFace38: (face) → {node};
}

functions {
	trace38: (ℝ²ˣ²) → ℝ;
	perp38: (ℝ²) → ℝ²;
	tensProduct38: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct38: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse38: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes39: (∅) → {node};
	cells39: (∅) → {cell};
	outerFaces39: (∅) → {face};
	innerNodes39: (∅) → {node};
	nodesOfCell39: (cell) → {node};
	cellsOfNode39: (node) → {cell};
	nodesOfFace39: (face) → {node};
}

functions {
	trace39: (ℝ²ˣ²) → ℝ;
	perp39: (ℝ²) → ℝ²;
	tensProduct39: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct39: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse39: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes40: (∅) → {node};
	cells40: (∅) → {cell};
	outerFaces40: (∅) → {face};
	innerNodes40: (∅) → {node};
	nodesOfCell40: (cell) → {node};
	cellsOfNode40: (node) → {cell};
	nodesOfFace40: (face) → {node};
}

functions {
	trace40: (ℝ²ˣ²) → ℝ;
	perp40: (ℝ²) → ℝ²;
	tensProduct40: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct40: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse40: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes41: (∅) → {node};
	cells41: (∅) → {cell};
	outerFaces41: (∅) → {face};
	innerNodes41: (∅) → {node};
	nodesOfCell41: (cell) → {node};
	cellsOfNode41: (node) → {cell};
	nodesOfFace41: (face) → {node};
}

functions {
	trace41: (ℝ²ˣ²) → ℝ;
	perp41: (ℝ²) → ℝ²;
	tensProduct41: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct41: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse41: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes42: (∅) → {node};
	cells42: (∅) → {cell};
	outerFaces42: (∅) → {face};
	innerNodes42: (∅) → {node};
	nodesOfCell42: (cell) → {node};
	cellsOfNode42: (node) → {cell};
	nodesOfFace42: (face) → {node};
}

functions {
	trace42: (ℝ²ˣ²) → ℝ;
	perp42: (ℝ²) → ℝ²;
	tensProduct42: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct42: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse42: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes43: (∅) → {node};
	cells43: (∅) → {cell};
	outerFaces43: (∅) → {face};
	innerNodes43: (∅) → {node};
	nodesOfCell43: (cell) → {node};
	cellsOfNode43: (node) → {cell};
	nodesOfFace43: (face) → {node};
}

functions {
	trace43: (ℝ²ˣ²) → ℝ;
	perp43: (ℝ²) → ℝ²;
	tensProduct43: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct43: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse43: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes44: (∅) → {node};
	cells44: (∅) → {cell};
	outerFaces44: (∅) → {face};
	innerNodes44: (∅) → {node};
	nodesOfCell44: (cell) → {node};
	cellsOfNode44: (node) → {cell};
	nodesOfFace44: (face) → {node};
}

functions {
	trace44: (ℝ²ˣ²) → ℝ;
	perp44: (ℝ²) → ℝ²;
	tensProduct44: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct44: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse44: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes45: (∅) → {node};
	cells45: (∅) → {cell};
	outerFaces45: (∅) → {face};
	innerNodes45: (∅) → {node};
	nodesOfCell45: (cell) → {node};
	cellsOfNode45: (node) → {cell};
	nodesOfFace45: (face) → {node};
}

functions {
	trace45: (ℝ²ˣ²) → ℝ;
	perp45: (ℝ²) → ℝ²;
	tensProduct45: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct45: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse45: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes46: (∅) → {node};
	cells46: (∅) → {cell};
	outerFaces46: (∅) → {face};
	innerNodes46: (∅) → {node};
	nodesOfCell46: (cell) → {node};
	cellsOfNode46: (node) → {cell};
	nodesOfFace46: (face) → {node};
}

functions {
	trace46: (ℝ²ˣ²) → ℝ;
	perp46: (ℝ²) → ℝ²;
	tensProduct46: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct46: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse46: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes47: (∅) → {node};
	cells47: (∅) → {cell};
	outerFaces47: (∅) → {face};
	innerNodes47: (∅) → {node};
	nodesOfCell47: (cell) → {node};
	cellsOfNode47: (node) → {cell};
	nodesOfFace47: (face) → {node};
}

functions {
	trace47: (ℝ²ˣ²) → ℝ;
	perp47: (ℝ²) → ℝ²;
	tensProduct47: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct47: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse47: (ℝ²ˣ²) → ℝ²ˣ²;
}


// Options obligatoires pour générer
const ℝ LENGTH1 = 0.01;
const ℕ X_EDGE_ELEMS1 = 100;
const ℕ Y_EDGE_ELEMS1 = 10;
const ℕ Z_EDGE_ELEMS1 = 1;
const ℝ option_stoptime1 = 0.2;
const ℕ option_max_iterations1 = 20000;

// Autres options
const ℝ γ1 = 1.4;
const ℝ option_x_interface1 = 0.5;
const ℝ option_δt_ini1 = 1.0e-5;
const ℝ option_δt_cfl1 = 0.4;
const ℝ option_ρ_ini_zg1 = 1.0;
const ℝ option_ρ_ini_zd1 = 0.125;
const ℝ option_p_ini_zg1 = 1.0;
const ℝ option_p_ini_zd1 = 0.1;

ℝ t1=0.0;
ℝ δt1=0.0;

ℝ² coord1[nodes1], X1[nodes1], b1[nodes1], bt1[nodes1];
ℝ²ˣ² Ar1[nodes1], Mt1[nodes1];
ℝ² ur1[nodes1];
ℝ p_ic1[cells1], ρ_ic1[cells1], V_ic1[cells1];
ℝ c1[cells1], m1[cells1], p1[cells1], ρ1[cells1], e1[cells1], E1[cells1], V1[cells1];
ℝ δtj1[cells1];
ℝ² uj1[cells1], center1[cells1];
ℝ l1[cells1, nodesOfCell1];
ℝ² C_ic1[cells1, nodesOfCell1], C1[cells1, nodesOfCell1], F1[cells1, nodesOfCell1];
ℝ²ˣ² Ajr1[cells1, nodesOfCell1];


// Options obligatoires pour générer
const ℝ LENGTH2 = 0.01;
const ℕ X_EDGE_ELEMS2 = 100;
const ℕ Y_EDGE_ELEMS2 = 10;
const ℕ Z_EDGE_ELEMS2 = 1;
const ℝ option_stoptime2 = 0.2;
const ℕ option_max_iterations2 = 20000;

// Autres options
const ℝ γ2 = 1.4;
const ℝ option_x_interface2 = 0.5;
const ℝ option_δt_ini2 = 1.0e-5;
const ℝ option_δt_cfl2 = 0.4;
const ℝ option_ρ_ini_zg2 = 1.0;
const ℝ option_ρ_ini_zd2 = 0.125;
const ℝ option_p_ini_zg2 = 1.0;
const ℝ option_p_ini_zd2 = 0.1;

ℝ t2=0.0;
ℝ δt2=0.0;

ℝ² coord2[nodes2], X2[nodes2], b2[nodes2], bt2[nodes2];
ℝ²ˣ² Ar2[nodes2], Mt2[nodes2];
ℝ² ur2[nodes2];
ℝ p_ic2[cells2], ρ_ic2[cells2], V_ic2[cells2];
ℝ c2[cells2], m2[cells2], p2[cells2], ρ2[cells2], e2[cells2], E2[cells2], V2[cells2];
ℝ δtj2[cells2];
ℝ² uj2[cells2], center2[cells2];
ℝ l2[cells2, nodesOfCell2];
ℝ² C_ic2[cells2, nodesOfCell2], C2[cells2, nodesOfCell2], F2[cells2, nodesOfCell2];
ℝ²ˣ² Ajr2[cells2, nodesOfCell2];


// Options obligatoires pour générer
const ℝ LENGTH3 = 0.01;
const ℕ X_EDGE_ELEMS3 = 100;
const ℕ Y_EDGE_ELEMS3 = 10;
const ℕ Z_EDGE_ELEMS3 = 1;
const ℝ option_stoptime3 = 0.2;
const ℕ option_max_iterations3 = 20000;

// Autres options
const ℝ γ3 = 1.4;
const ℝ option_x_interface3 = 0.5;
const ℝ option_δt_ini3 = 1.0e-5;
const ℝ option_δt_cfl3 = 0.4;
const ℝ option_ρ_ini_zg3 = 1.0;
const ℝ option_ρ_ini_zd3 = 0.125;
const ℝ option_p_ini_zg3 = 1.0;
const ℝ option_p_ini_zd3 = 0.1;

ℝ t3=0.0;
ℝ δt3=0.0;

ℝ² coord3[nodes3], X3[nodes3], b3[nodes3], bt3[nodes3];
ℝ²ˣ² Ar3[nodes3], Mt3[nodes3];
ℝ² ur3[nodes3];
ℝ p_ic3[cells3], ρ_ic3[cells3], V_ic3[cells3];
ℝ c3[cells3], m3[cells3], p3[cells3], ρ3[cells3], e3[cells3], E3[cells3], V3[cells3];
ℝ δtj3[cells3];
ℝ² uj3[cells3], center3[cells3];
ℝ l3[cells3, nodesOfCell3];
ℝ² C_ic3[cells3, nodesOfCell3], C3[cells3, nodesOfCell3], F3[cells3, nodesOfCell3];
ℝ²ˣ² Ajr3[cells3, nodesOfCell3];


// Options obligatoires pour générer
const ℝ LENGTH4 = 0.01;
const ℕ X_EDGE_ELEMS4 = 100;
const ℕ Y_EDGE_ELEMS4 = 10;
const ℕ Z_EDGE_ELEMS4 = 1;
const ℝ option_stoptime4 = 0.2;
const ℕ option_max_iterations4 = 20000;

// Autres options
const ℝ γ4 = 1.4;
const ℝ option_x_interface4 = 0.5;
const ℝ option_δt_ini4 = 1.0e-5;
const ℝ option_δt_cfl4 = 0.4;
const ℝ option_ρ_ini_zg4 = 1.0;
const ℝ option_ρ_ini_zd4 = 0.125;
const ℝ option_p_ini_zg4 = 1.0;
const ℝ option_p_ini_zd4 = 0.1;

ℝ t4=0.0;
ℝ δt4=0.0;

ℝ² coord4[nodes4], X4[nodes4], b4[nodes4], bt4[nodes4];
ℝ²ˣ² Ar4[nodes4], Mt4[nodes4];
ℝ² ur4[nodes4];
ℝ p_ic4[cells4], ρ_ic4[cells4], V_ic4[cells4];
ℝ c4[cells4], m4[cells4], p4[cells4], ρ4[cells4], e4[cells4], E4[cells4], V4[cells4];
ℝ δtj4[cells4];
ℝ² uj4[cells4], center4[cells4];
ℝ l4[cells4, nodesOfCell4];
ℝ² C_ic4[cells4, nodesOfCell4], C4[cells4, nodesOfCell4], F4[cells4, nodesOfCell4];
ℝ²ˣ² Ajr4[cells4, nodesOfCell4];


// Options obligatoires pour générer
const ℝ LENGTH5 = 0.01;
const ℕ X_EDGE_ELEMS5 = 100;
const ℕ Y_EDGE_ELEMS5 = 10;
const ℕ Z_EDGE_ELEMS5 = 1;
const ℝ option_stoptime5 = 0.2;
const ℕ option_max_iterations5 = 20000;

// Autres options
const ℝ γ5 = 1.4;
const ℝ option_x_interface5 = 0.5;
const ℝ option_δt_ini5 = 1.0e-5;
const ℝ option_δt_cfl5 = 0.4;
const ℝ option_ρ_ini_zg5 = 1.0;
const ℝ option_ρ_ini_zd5 = 0.125;
const ℝ option_p_ini_zg5 = 1.0;
const ℝ option_p_ini_zd5 = 0.1;

ℝ t5=0.0;
ℝ δt5=0.0;

ℝ² coord5[nodes5], X5[nodes5], b5[nodes5], bt5[nodes5];
ℝ²ˣ² Ar5[nodes5], Mt5[nodes5];
ℝ² ur5[nodes5];
ℝ p_ic5[cells5], ρ_ic5[cells5], V_ic5[cells5];
ℝ c5[cells5], m5[cells5], p5[cells5], ρ5[cells5], e5[cells5], E5[cells5], V5[cells5];
ℝ δtj5[cells5];
ℝ² uj5[cells5], center5[cells5];
ℝ l5[cells5, nodesOfCell5];
ℝ² C_ic5[cells5, nodesOfCell5], C5[cells5, nodesOfCell5], F5[cells5, nodesOfCell5];
ℝ²ˣ² Ajr5[cells5, nodesOfCell5];


// Options obligatoires pour générer
const ℝ LENGTH6 = 0.01;
const ℕ X_EDGE_ELEMS6 = 100;
const ℕ Y_EDGE_ELEMS6 = 10;
const ℕ Z_EDGE_ELEMS6 = 1;
const ℝ option_stoptime6 = 0.2;
const ℕ option_max_iterations6 = 20000;

// Autres options
const ℝ γ6 = 1.4;
const ℝ option_x_interface6 = 0.5;
const ℝ option_δt_ini6 = 1.0e-5;
const ℝ option_δt_cfl6 = 0.4;
const ℝ option_ρ_ini_zg6 = 1.0;
const ℝ option_ρ_ini_zd6 = 0.125;
const ℝ option_p_ini_zg6 = 1.0;
const ℝ option_p_ini_zd6 = 0.1;

ℝ t6=0.0;
ℝ δt6=0.0;

ℝ² coord6[nodes6], X6[nodes6], b6[nodes6], bt6[nodes6];
ℝ²ˣ² Ar6[nodes6], Mt6[nodes6];
ℝ² ur6[nodes6];
ℝ p_ic6[cells6], ρ_ic6[cells6], V_ic6[cells6];
ℝ c6[cells6], m6[cells6], p6[cells6], ρ6[cells6], e6[cells6], E6[cells6], V6[cells6];
ℝ δtj6[cells6];
ℝ² uj6[cells6], center6[cells6];
ℝ l6[cells6, nodesOfCell6];
ℝ² C_ic6[cells6, nodesOfCell6], C6[cells6, nodesOfCell6], F6[cells6, nodesOfCell6];
ℝ²ˣ² Ajr6[cells6, nodesOfCell6];


// Options obligatoires pour générer
const ℝ LENGTH7 = 0.01;
const ℕ X_EDGE_ELEMS7 = 100;
const ℕ Y_EDGE_ELEMS7 = 10;
const ℕ Z_EDGE_ELEMS7 = 1;
const ℝ option_stoptime7 = 0.2;
const ℕ option_max_iterations7 = 20000;

// Autres options
const ℝ γ7 = 1.4;
const ℝ option_x_interface7 = 0.5;
const ℝ option_δt_ini7 = 1.0e-5;
const ℝ option_δt_cfl7 = 0.4;
const ℝ option_ρ_ini_zg7 = 1.0;
const ℝ option_ρ_ini_zd7 = 0.125;
const ℝ option_p_ini_zg7 = 1.0;
const ℝ option_p_ini_zd7 = 0.1;

ℝ t7=0.0;
ℝ δt7=0.0;

ℝ² coord7[nodes7], X7[nodes7], b7[nodes7], bt7[nodes7];
ℝ²ˣ² Ar7[nodes7], Mt7[nodes7];
ℝ² ur7[nodes7];
ℝ p_ic7[cells7], ρ_ic7[cells7], V_ic7[cells7];
ℝ c7[cells7], m7[cells7], p7[cells7], ρ7[cells7], e7[cells7], E7[cells7], V7[cells7];
ℝ δtj7[cells7];
ℝ² uj7[cells7], center7[cells7];
ℝ l7[cells7, nodesOfCell7];
ℝ² C_ic7[cells7, nodesOfCell7], C7[cells7, nodesOfCell7], F7[cells7, nodesOfCell7];
ℝ²ˣ² Ajr7[cells7, nodesOfCell7];


// Options obligatoires pour générer
const ℝ LENGTH8 = 0.01;
const ℕ X_EDGE_ELEMS8 = 100;
const ℕ Y_EDGE_ELEMS8 = 10;
const ℕ Z_EDGE_ELEMS8 = 1;
const ℝ option_stoptime8 = 0.2;
const ℕ option_max_iterations8 = 20000;

// Autres options
const ℝ γ8 = 1.4;
const ℝ option_x_interface8 = 0.5;
const ℝ option_δt_ini8 = 1.0e-5;
const ℝ option_δt_cfl8 = 0.4;
const ℝ option_ρ_ini_zg8 = 1.0;
const ℝ option_ρ_ini_zd8 = 0.125;
const ℝ option_p_ini_zg8 = 1.0;
const ℝ option_p_ini_zd8 = 0.1;

ℝ t8=0.0;
ℝ δt8=0.0;

ℝ² coord8[nodes8], X8[nodes8], b8[nodes8], bt8[nodes8];
ℝ²ˣ² Ar8[nodes8], Mt8[nodes8];
ℝ² ur8[nodes8];
ℝ p_ic8[cells8], ρ_ic8[cells8], V_ic8[cells8];
ℝ c8[cells8], m8[cells8], p8[cells8], ρ8[cells8], e8[cells8], E8[cells8], V8[cells8];
ℝ δtj8[cells8];
ℝ² uj8[cells8], center8[cells8];
ℝ l8[cells8, nodesOfCell8];
ℝ² C_ic8[cells8, nodesOfCell8], C8[cells8, nodesOfCell8], F8[cells8, nodesOfCell8];
ℝ²ˣ² Ajr8[cells8, nodesOfCell8];


// Options obligatoires pour générer
const ℝ LENGTH9 = 0.01;
const ℕ X_EDGE_ELEMS9 = 100;
const ℕ Y_EDGE_ELEMS9 = 10;
const ℕ Z_EDGE_ELEMS9 = 1;
const ℝ option_stoptime9 = 0.2;
const ℕ option_max_iterations9 = 20000;

// Autres options
const ℝ γ9 = 1.4;
const ℝ option_x_interface9 = 0.5;
const ℝ option_δt_ini9 = 1.0e-5;
const ℝ option_δt_cfl9 = 0.4;
const ℝ option_ρ_ini_zg9 = 1.0;
const ℝ option_ρ_ini_zd9 = 0.125;
const ℝ option_p_ini_zg9 = 1.0;
const ℝ option_p_ini_zd9 = 0.1;

ℝ t9=0.0;
ℝ δt9=0.0;

ℝ² coord9[nodes9], X9[nodes9], b9[nodes9], bt9[nodes9];
ℝ²ˣ² Ar9[nodes9], Mt9[nodes9];
ℝ² ur9[nodes9];
ℝ p_ic9[cells9], ρ_ic9[cells9], V_ic9[cells9];
ℝ c9[cells9], m9[cells9], p9[cells9], ρ9[cells9], e9[cells9], E9[cells9], V9[cells9];
ℝ δtj9[cells9];
ℝ² uj9[cells9], center9[cells9];
ℝ l9[cells9, nodesOfCell9];
ℝ² C_ic9[cells9, nodesOfCell9], C9[cells9, nodesOfCell9], F9[cells9, nodesOfCell9];
ℝ²ˣ² Ajr9[cells9, nodesOfCell9];


// Options obligatoires pour générer
const ℝ LENGTH10 = 0.01;
const ℕ X_EDGE_ELEMS10 = 100;
const ℕ Y_EDGE_ELEMS10 = 10;
const ℕ Z_EDGE_ELEMS10 = 1;
const ℝ option_stoptime10 = 0.2;
const ℕ option_max_iterations10 = 20000;

// Autres options
const ℝ γ10 = 1.4;
const ℝ option_x_interface10 = 0.5;
const ℝ option_δt_ini10 = 1.0e-5;
const ℝ option_δt_cfl10 = 0.4;
const ℝ option_ρ_ini_zg10 = 1.0;
const ℝ option_ρ_ini_zd10 = 0.125;
const ℝ option_p_ini_zg10 = 1.0;
const ℝ option_p_ini_zd10 = 0.1;

ℝ t10=0.0;
ℝ δt10=0.0;

ℝ² coord10[nodes10], X10[nodes10], b10[nodes10], bt10[nodes10];
ℝ²ˣ² Ar10[nodes10], Mt10[nodes10];
ℝ² ur10[nodes10];
ℝ p_ic10[cells10], ρ_ic10[cells10], V_ic10[cells10];
ℝ c10[cells10], m10[cells10], p10[cells10], ρ10[cells10], e10[cells10], E10[cells10], V10[cells10];
ℝ δtj10[cells10];
ℝ² uj10[cells10], center10[cells10];
ℝ l10[cells10, nodesOfCell10];
ℝ² C_ic10[cells10, nodesOfCell10], C10[cells10, nodesOfCell10], F10[cells10, nodesOfCell10];
ℝ²ˣ² Ajr10[cells10, nodesOfCell10];


// Options obligatoires pour générer
const ℝ LENGTH11 = 0.01;
const ℕ X_EDGE_ELEMS11 = 100;
const ℕ Y_EDGE_ELEMS11 = 10;
const ℕ Z_EDGE_ELEMS11 = 1;
const ℝ option_stoptime11 = 0.2;
const ℕ option_max_iterations11 = 20000;

// Autres options
const ℝ γ11 = 1.4;
const ℝ option_x_interface11 = 0.5;
const ℝ option_δt_ini11 = 1.0e-5;
const ℝ option_δt_cfl11 = 0.4;
const ℝ option_ρ_ini_zg11 = 1.0;
const ℝ option_ρ_ini_zd11 = 0.125;
const ℝ option_p_ini_zg11 = 1.0;
const ℝ option_p_ini_zd11 = 0.1;

ℝ t11=0.0;
ℝ δt11=0.0;

ℝ² coord11[nodes11], X11[nodes11], b11[nodes11], bt11[nodes11];
ℝ²ˣ² Ar11[nodes11], Mt11[nodes11];
ℝ² ur11[nodes11];
ℝ p_ic11[cells11], ρ_ic11[cells11], V_ic11[cells11];
ℝ c11[cells11], m11[cells11], p11[cells11], ρ11[cells11], e11[cells11], E11[cells11], V11[cells11];
ℝ δtj11[cells11];
ℝ² uj11[cells11], center11[cells11];
ℝ l11[cells11, nodesOfCell11];
ℝ² C_ic11[cells11, nodesOfCell11], C11[cells11, nodesOfCell11], F11[cells11, nodesOfCell11];
ℝ²ˣ² Ajr11[cells11, nodesOfCell11];


// Options obligatoires pour générer
const ℝ LENGTH12 = 0.01;
const ℕ X_EDGE_ELEMS12 = 100;
const ℕ Y_EDGE_ELEMS12 = 10;
const ℕ Z_EDGE_ELEMS12 = 1;
const ℝ option_stoptime12 = 0.2;
const ℕ option_max_iterations12 = 20000;

// Autres options
const ℝ γ12 = 1.4;
const ℝ option_x_interface12 = 0.5;
const ℝ option_δt_ini12 = 1.0e-5;
const ℝ option_δt_cfl12 = 0.4;
const ℝ option_ρ_ini_zg12 = 1.0;
const ℝ option_ρ_ini_zd12 = 0.125;
const ℝ option_p_ini_zg12 = 1.0;
const ℝ option_p_ini_zd12 = 0.1;

ℝ t12=0.0;
ℝ δt12=0.0;

ℝ² coord12[nodes12], X12[nodes12], b12[nodes12], bt12[nodes12];
ℝ²ˣ² Ar12[nodes12], Mt12[nodes12];
ℝ² ur12[nodes12];
ℝ p_ic12[cells12], ρ_ic12[cells12], V_ic12[cells12];
ℝ c12[cells12], m12[cells12], p12[cells12], ρ12[cells12], e12[cells12], E12[cells12], V12[cells12];
ℝ δtj12[cells12];
ℝ² uj12[cells12], center12[cells12];
ℝ l12[cells12, nodesOfCell12];
ℝ² C_ic12[cells12, nodesOfCell12], C12[cells12, nodesOfCell12], F12[cells12, nodesOfCell12];
ℝ²ˣ² Ajr12[cells12, nodesOfCell12];


// Options obligatoires pour générer
const ℝ LENGTH13 = 0.01;
const ℕ X_EDGE_ELEMS13 = 100;
const ℕ Y_EDGE_ELEMS13 = 10;
const ℕ Z_EDGE_ELEMS13 = 1;
const ℝ option_stoptime13 = 0.2;
const ℕ option_max_iterations13 = 20000;

// Autres options
const ℝ γ13 = 1.4;
const ℝ option_x_interface13 = 0.5;
const ℝ option_δt_ini13 = 1.0e-5;
const ℝ option_δt_cfl13 = 0.4;
const ℝ option_ρ_ini_zg13 = 1.0;
const ℝ option_ρ_ini_zd13 = 0.125;
const ℝ option_p_ini_zg13 = 1.0;
const ℝ option_p_ini_zd13 = 0.1;

ℝ t13=0.0;
ℝ δt13=0.0;

ℝ² coord13[nodes13], X13[nodes13], b13[nodes13], bt13[nodes13];
ℝ²ˣ² Ar13[nodes13], Mt13[nodes13];
ℝ² ur13[nodes13];
ℝ p_ic13[cells13], ρ_ic13[cells13], V_ic13[cells13];
ℝ c13[cells13], m13[cells13], p13[cells13], ρ13[cells13], e13[cells13], E13[cells13], V13[cells13];
ℝ δtj13[cells13];
ℝ² uj13[cells13], center13[cells13];
ℝ l13[cells13, nodesOfCell13];
ℝ² C_ic13[cells13, nodesOfCell13], C13[cells13, nodesOfCell13], F13[cells13, nodesOfCell13];
ℝ²ˣ² Ajr13[cells13, nodesOfCell13];


// Options obligatoires pour générer
const ℝ LENGTH14 = 0.01;
const ℕ X_EDGE_ELEMS14 = 100;
const ℕ Y_EDGE_ELEMS14 = 10;
const ℕ Z_EDGE_ELEMS14 = 1;
const ℝ option_stoptime14 = 0.2;
const ℕ option_max_iterations14 = 20000;

// Autres options
const ℝ γ14 = 1.4;
const ℝ option_x_interface14 = 0.5;
const ℝ option_δt_ini14 = 1.0e-5;
const ℝ option_δt_cfl14 = 0.4;
const ℝ option_ρ_ini_zg14 = 1.0;
const ℝ option_ρ_ini_zd14 = 0.125;
const ℝ option_p_ini_zg14 = 1.0;
const ℝ option_p_ini_zd14 = 0.1;

ℝ t14=0.0;
ℝ δt14=0.0;

ℝ² coord14[nodes14], X14[nodes14], b14[nodes14], bt14[nodes14];
ℝ²ˣ² Ar14[nodes14], Mt14[nodes14];
ℝ² ur14[nodes14];
ℝ p_ic14[cells14], ρ_ic14[cells14], V_ic14[cells14];
ℝ c14[cells14], m14[cells14], p14[cells14], ρ14[cells14], e14[cells14], E14[cells14], V14[cells14];
ℝ δtj14[cells14];
ℝ² uj14[cells14], center14[cells14];
ℝ l14[cells14, nodesOfCell14];
ℝ² C_ic14[cells14, nodesOfCell14], C14[cells14, nodesOfCell14], F14[cells14, nodesOfCell14];
ℝ²ˣ² Ajr14[cells14, nodesOfCell14];


// Options obligatoires pour générer
const ℝ LENGTH15 = 0.01;
const ℕ X_EDGE_ELEMS15 = 100;
const ℕ Y_EDGE_ELEMS15 = 10;
const ℕ Z_EDGE_ELEMS15 = 1;
const ℝ option_stoptime15 = 0.2;
const ℕ option_max_iterations15 = 20000;

// Autres options
const ℝ γ15 = 1.4;
const ℝ option_x_interface15 = 0.5;
const ℝ option_δt_ini15 = 1.0e-5;
const ℝ option_δt_cfl15 = 0.4;
const ℝ option_ρ_ini_zg15 = 1.0;
const ℝ option_ρ_ini_zd15 = 0.125;
const ℝ option_p_ini_zg15 = 1.0;
const ℝ option_p_ini_zd15 = 0.1;

ℝ t15=0.0;
ℝ δt15=0.0;

ℝ² coord15[nodes15], X15[nodes15], b15[nodes15], bt15[nodes15];
ℝ²ˣ² Ar15[nodes15], Mt15[nodes15];
ℝ² ur15[nodes15];
ℝ p_ic15[cells15], ρ_ic15[cells15], V_ic15[cells15];
ℝ c15[cells15], m15[cells15], p15[cells15], ρ15[cells15], e15[cells15], E15[cells15], V15[cells15];
ℝ δtj15[cells15];
ℝ² uj15[cells15], center15[cells15];
ℝ l15[cells15, nodesOfCell15];
ℝ² C_ic15[cells15, nodesOfCell15], C15[cells15, nodesOfCell15], F15[cells15, nodesOfCell15];
ℝ²ˣ² Ajr15[cells15, nodesOfCell15];


// Options obligatoires pour générer
const ℝ LENGTH16 = 0.01;
const ℕ X_EDGE_ELEMS16 = 100;
const ℕ Y_EDGE_ELEMS16 = 10;
const ℕ Z_EDGE_ELEMS16 = 1;
const ℝ option_stoptime16 = 0.2;
const ℕ option_max_iterations16 = 20000;

// Autres options
const ℝ γ16 = 1.4;
const ℝ option_x_interface16 = 0.5;
const ℝ option_δt_ini16 = 1.0e-5;
const ℝ option_δt_cfl16 = 0.4;
const ℝ option_ρ_ini_zg16 = 1.0;
const ℝ option_ρ_ini_zd16 = 0.125;
const ℝ option_p_ini_zg16 = 1.0;
const ℝ option_p_ini_zd16 = 0.1;

ℝ t16=0.0;
ℝ δt16=0.0;

ℝ² coord16[nodes16], X16[nodes16], b16[nodes16], bt16[nodes16];
ℝ²ˣ² Ar16[nodes16], Mt16[nodes16];
ℝ² ur16[nodes16];
ℝ p_ic16[cells16], ρ_ic16[cells16], V_ic16[cells16];
ℝ c16[cells16], m16[cells16], p16[cells16], ρ16[cells16], e16[cells16], E16[cells16], V16[cells16];
ℝ δtj16[cells16];
ℝ² uj16[cells16], center16[cells16];
ℝ l16[cells16, nodesOfCell16];
ℝ² C_ic16[cells16, nodesOfCell16], C16[cells16, nodesOfCell16], F16[cells16, nodesOfCell16];
ℝ²ˣ² Ajr16[cells16, nodesOfCell16];


// Options obligatoires pour générer
const ℝ LENGTH17 = 0.01;
const ℕ X_EDGE_ELEMS17 = 100;
const ℕ Y_EDGE_ELEMS17 = 10;
const ℕ Z_EDGE_ELEMS17 = 1;
const ℝ option_stoptime17 = 0.2;
const ℕ option_max_iterations17 = 20000;

// Autres options
const ℝ γ17 = 1.4;
const ℝ option_x_interface17 = 0.5;
const ℝ option_δt_ini17 = 1.0e-5;
const ℝ option_δt_cfl17 = 0.4;
const ℝ option_ρ_ini_zg17 = 1.0;
const ℝ option_ρ_ini_zd17 = 0.125;
const ℝ option_p_ini_zg17 = 1.0;
const ℝ option_p_ini_zd17 = 0.1;

ℝ t17=0.0;
ℝ δt17=0.0;

ℝ² coord17[nodes17], X17[nodes17], b17[nodes17], bt17[nodes17];
ℝ²ˣ² Ar17[nodes17], Mt17[nodes17];
ℝ² ur17[nodes17];
ℝ p_ic17[cells17], ρ_ic17[cells17], V_ic17[cells17];
ℝ c17[cells17], m17[cells17], p17[cells17], ρ17[cells17], e17[cells17], E17[cells17], V17[cells17];
ℝ δtj17[cells17];
ℝ² uj17[cells17], center17[cells17];
ℝ l17[cells17, nodesOfCell17];
ℝ² C_ic17[cells17, nodesOfCell17], C17[cells17, nodesOfCell17], F17[cells17, nodesOfCell17];
ℝ²ˣ² Ajr17[cells17, nodesOfCell17];


// Options obligatoires pour générer
const ℝ LENGTH18 = 0.01;
const ℕ X_EDGE_ELEMS18 = 100;
const ℕ Y_EDGE_ELEMS18 = 10;
const ℕ Z_EDGE_ELEMS18 = 1;
const ℝ option_stoptime18 = 0.2;
const ℕ option_max_iterations18 = 20000;

// Autres options
const ℝ γ18 = 1.4;
const ℝ option_x_interface18 = 0.5;
const ℝ option_δt_ini18 = 1.0e-5;
const ℝ option_δt_cfl18 = 0.4;
const ℝ option_ρ_ini_zg18 = 1.0;
const ℝ option_ρ_ini_zd18 = 0.125;
const ℝ option_p_ini_zg18 = 1.0;
const ℝ option_p_ini_zd18 = 0.1;

ℝ t18=0.0;
ℝ δt18=0.0;

ℝ² coord18[nodes18], X18[nodes18], b18[nodes18], bt18[nodes18];
ℝ²ˣ² Ar18[nodes18], Mt18[nodes18];
ℝ² ur18[nodes18];
ℝ p_ic18[cells18], ρ_ic18[cells18], V_ic18[cells18];
ℝ c18[cells18], m18[cells18], p18[cells18], ρ18[cells18], e18[cells18], E18[cells18], V18[cells18];
ℝ δtj18[cells18];
ℝ² uj18[cells18], center18[cells18];
ℝ l18[cells18, nodesOfCell18];
ℝ² C_ic18[cells18, nodesOfCell18], C18[cells18, nodesOfCell18], F18[cells18, nodesOfCell18];
ℝ²ˣ² Ajr18[cells18, nodesOfCell18];


// Options obligatoires pour générer
const ℝ LENGTH19 = 0.01;
const ℕ X_EDGE_ELEMS19 = 100;
const ℕ Y_EDGE_ELEMS19 = 10;
const ℕ Z_EDGE_ELEMS19 = 1;
const ℝ option_stoptime19 = 0.2;
const ℕ option_max_iterations19 = 20000;

// Autres options
const ℝ γ19 = 1.4;
const ℝ option_x_interface19 = 0.5;
const ℝ option_δt_ini19 = 1.0e-5;
const ℝ option_δt_cfl19 = 0.4;
const ℝ option_ρ_ini_zg19 = 1.0;
const ℝ option_ρ_ini_zd19 = 0.125;
const ℝ option_p_ini_zg19 = 1.0;
const ℝ option_p_ini_zd19 = 0.1;

ℝ t19=0.0;
ℝ δt19=0.0;

ℝ² coord19[nodes19], X19[nodes19], b19[nodes19], bt19[nodes19];
ℝ²ˣ² Ar19[nodes19], Mt19[nodes19];
ℝ² ur19[nodes19];
ℝ p_ic19[cells19], ρ_ic19[cells19], V_ic19[cells19];
ℝ c19[cells19], m19[cells19], p19[cells19], ρ19[cells19], e19[cells19], E19[cells19], V19[cells19];
ℝ δtj19[cells19];
ℝ² uj19[cells19], center19[cells19];
ℝ l19[cells19, nodesOfCell19];
ℝ² C_ic19[cells19, nodesOfCell19], C19[cells19, nodesOfCell19], F19[cells19, nodesOfCell19];
ℝ²ˣ² Ajr19[cells19, nodesOfCell19];


// Options obligatoires pour générer
const ℝ LENGTH20 = 0.01;
const ℕ X_EDGE_ELEMS20 = 100;
const ℕ Y_EDGE_ELEMS20 = 10;
const ℕ Z_EDGE_ELEMS20 = 1;
const ℝ option_stoptime20 = 0.2;
const ℕ option_max_iterations20 = 20000;

// Autres options
const ℝ γ20 = 1.4;
const ℝ option_x_interface20 = 0.5;
const ℝ option_δt_ini20 = 1.0e-5;
const ℝ option_δt_cfl20 = 0.4;
const ℝ option_ρ_ini_zg20 = 1.0;
const ℝ option_ρ_ini_zd20 = 0.125;
const ℝ option_p_ini_zg20 = 1.0;
const ℝ option_p_ini_zd20 = 0.1;

ℝ t20=0.0;
ℝ δt20=0.0;

ℝ² coord20[nodes20], X20[nodes20], b20[nodes20], bt20[nodes20];
ℝ²ˣ² Ar20[nodes20], Mt20[nodes20];
ℝ² ur20[nodes20];
ℝ p_ic20[cells20], ρ_ic20[cells20], V_ic20[cells20];
ℝ c20[cells20], m20[cells20], p20[cells20], ρ20[cells20], e20[cells20], E20[cells20], V20[cells20];
ℝ δtj20[cells20];
ℝ² uj20[cells20], center20[cells20];
ℝ l20[cells20, nodesOfCell20];
ℝ² C_ic20[cells20, nodesOfCell20], C20[cells20, nodesOfCell20], F20[cells20, nodesOfCell20];
ℝ²ˣ² Ajr20[cells20, nodesOfCell20];


// Options obligatoires pour générer
const ℝ LENGTH21 = 0.01;
const ℕ X_EDGE_ELEMS21 = 100;
const ℕ Y_EDGE_ELEMS21 = 10;
const ℕ Z_EDGE_ELEMS21 = 1;
const ℝ option_stoptime21 = 0.2;
const ℕ option_max_iterations21 = 20000;

// Autres options
const ℝ γ21 = 1.4;
const ℝ option_x_interface21 = 0.5;
const ℝ option_δt_ini21 = 1.0e-5;
const ℝ option_δt_cfl21 = 0.4;
const ℝ option_ρ_ini_zg21 = 1.0;
const ℝ option_ρ_ini_zd21 = 0.125;
const ℝ option_p_ini_zg21 = 1.0;
const ℝ option_p_ini_zd21 = 0.1;

ℝ t21=0.0;
ℝ δt21=0.0;

ℝ² coord21[nodes21], X21[nodes21], b21[nodes21], bt21[nodes21];
ℝ²ˣ² Ar21[nodes21], Mt21[nodes21];
ℝ² ur21[nodes21];
ℝ p_ic21[cells21], ρ_ic21[cells21], V_ic21[cells21];
ℝ c21[cells21], m21[cells21], p21[cells21], ρ21[cells21], e21[cells21], E21[cells21], V21[cells21];
ℝ δtj21[cells21];
ℝ² uj21[cells21], center21[cells21];
ℝ l21[cells21, nodesOfCell21];
ℝ² C_ic21[cells21, nodesOfCell21], C21[cells21, nodesOfCell21], F21[cells21, nodesOfCell21];
ℝ²ˣ² Ajr21[cells21, nodesOfCell21];


// Options obligatoires pour générer
const ℝ LENGTH22 = 0.01;
const ℕ X_EDGE_ELEMS22 = 100;
const ℕ Y_EDGE_ELEMS22 = 10;
const ℕ Z_EDGE_ELEMS22 = 1;
const ℝ option_stoptime22 = 0.2;
const ℕ option_max_iterations22 = 20000;

// Autres options
const ℝ γ22 = 1.4;
const ℝ option_x_interface22 = 0.5;
const ℝ option_δt_ini22 = 1.0e-5;
const ℝ option_δt_cfl22 = 0.4;
const ℝ option_ρ_ini_zg22 = 1.0;
const ℝ option_ρ_ini_zd22 = 0.125;
const ℝ option_p_ini_zg22 = 1.0;
const ℝ option_p_ini_zd22 = 0.1;

ℝ t22=0.0;
ℝ δt22=0.0;

ℝ² coord22[nodes22], X22[nodes22], b22[nodes22], bt22[nodes22];
ℝ²ˣ² Ar22[nodes22], Mt22[nodes22];
ℝ² ur22[nodes22];
ℝ p_ic22[cells22], ρ_ic22[cells22], V_ic22[cells22];
ℝ c22[cells22], m22[cells22], p22[cells22], ρ22[cells22], e22[cells22], E22[cells22], V22[cells22];
ℝ δtj22[cells22];
ℝ² uj22[cells22], center22[cells22];
ℝ l22[cells22, nodesOfCell22];
ℝ² C_ic22[cells22, nodesOfCell22], C22[cells22, nodesOfCell22], F22[cells22, nodesOfCell22];
ℝ²ˣ² Ajr22[cells22, nodesOfCell22];


// Options obligatoires pour générer
const ℝ LENGTH23 = 0.01;
const ℕ X_EDGE_ELEMS23 = 100;
const ℕ Y_EDGE_ELEMS23 = 10;
const ℕ Z_EDGE_ELEMS23 = 1;
const ℝ option_stoptime23 = 0.2;
const ℕ option_max_iterations23 = 20000;

// Autres options
const ℝ γ23 = 1.4;
const ℝ option_x_interface23 = 0.5;
const ℝ option_δt_ini23 = 1.0e-5;
const ℝ option_δt_cfl23 = 0.4;
const ℝ option_ρ_ini_zg23 = 1.0;
const ℝ option_ρ_ini_zd23 = 0.125;
const ℝ option_p_ini_zg23 = 1.0;
const ℝ option_p_ini_zd23 = 0.1;

ℝ t23=0.0;
ℝ δt23=0.0;

ℝ² coord23[nodes23], X23[nodes23], b23[nodes23], bt23[nodes23];
ℝ²ˣ² Ar23[nodes23], Mt23[nodes23];
ℝ² ur23[nodes23];
ℝ p_ic23[cells23], ρ_ic23[cells23], V_ic23[cells23];
ℝ c23[cells23], m23[cells23], p23[cells23], ρ23[cells23], e23[cells23], E23[cells23], V23[cells23];
ℝ δtj23[cells23];
ℝ² uj23[cells23], center23[cells23];
ℝ l23[cells23, nodesOfCell23];
ℝ² C_ic23[cells23, nodesOfCell23], C23[cells23, nodesOfCell23], F23[cells23, nodesOfCell23];
ℝ²ˣ² Ajr23[cells23, nodesOfCell23];


// Options obligatoires pour générer
const ℝ LENGTH24 = 0.01;
const ℕ X_EDGE_ELEMS24 = 100;
const ℕ Y_EDGE_ELEMS24 = 10;
const ℕ Z_EDGE_ELEMS24 = 1;
const ℝ option_stoptime24 = 0.2;
const ℕ option_max_iterations24 = 20000;

// Autres options
const ℝ γ24 = 1.4;
const ℝ option_x_interface24 = 0.5;
const ℝ option_δt_ini24 = 1.0e-5;
const ℝ option_δt_cfl24 = 0.4;
const ℝ option_ρ_ini_zg24 = 1.0;
const ℝ option_ρ_ini_zd24 = 0.125;
const ℝ option_p_ini_zg24 = 1.0;
const ℝ option_p_ini_zd24 = 0.1;

ℝ t24=0.0;
ℝ δt24=0.0;

ℝ² coord24[nodes24], X24[nodes24], b24[nodes24], bt24[nodes24];
ℝ²ˣ² Ar24[nodes24], Mt24[nodes24];
ℝ² ur24[nodes24];
ℝ p_ic24[cells24], ρ_ic24[cells24], V_ic24[cells24];
ℝ c24[cells24], m24[cells24], p24[cells24], ρ24[cells24], e24[cells24], E24[cells24], V24[cells24];
ℝ δtj24[cells24];
ℝ² uj24[cells24], center24[cells24];
ℝ l24[cells24, nodesOfCell24];
ℝ² C_ic24[cells24, nodesOfCell24], C24[cells24, nodesOfCell24], F24[cells24, nodesOfCell24];
ℝ²ˣ² Ajr24[cells24, nodesOfCell24];


// Options obligatoires pour générer
const ℝ LENGTH25 = 0.01;
const ℕ X_EDGE_ELEMS25 = 100;
const ℕ Y_EDGE_ELEMS25 = 10;
const ℕ Z_EDGE_ELEMS25 = 1;
const ℝ option_stoptime25 = 0.2;
const ℕ option_max_iterations25 = 20000;

// Autres options
const ℝ γ25 = 1.4;
const ℝ option_x_interface25 = 0.5;
const ℝ option_δt_ini25 = 1.0e-5;
const ℝ option_δt_cfl25 = 0.4;
const ℝ option_ρ_ini_zg25 = 1.0;
const ℝ option_ρ_ini_zd25 = 0.125;
const ℝ option_p_ini_zg25 = 1.0;
const ℝ option_p_ini_zd25 = 0.1;

ℝ t25=0.0;
ℝ δt25=0.0;

ℝ² coord25[nodes25], X25[nodes25], b25[nodes25], bt25[nodes25];
ℝ²ˣ² Ar25[nodes25], Mt25[nodes25];
ℝ² ur25[nodes25];
ℝ p_ic25[cells25], ρ_ic25[cells25], V_ic25[cells25];
ℝ c25[cells25], m25[cells25], p25[cells25], ρ25[cells25], e25[cells25], E25[cells25], V25[cells25];
ℝ δtj25[cells25];
ℝ² uj25[cells25], center25[cells25];
ℝ l25[cells25, nodesOfCell25];
ℝ² C_ic25[cells25, nodesOfCell25], C25[cells25, nodesOfCell25], F25[cells25, nodesOfCell25];
ℝ²ˣ² Ajr25[cells25, nodesOfCell25];


// Options obligatoires pour générer
const ℝ LENGTH26 = 0.01;
const ℕ X_EDGE_ELEMS26 = 100;
const ℕ Y_EDGE_ELEMS26 = 10;
const ℕ Z_EDGE_ELEMS26 = 1;
const ℝ option_stoptime26 = 0.2;
const ℕ option_max_iterations26 = 20000;

// Autres options
const ℝ γ26 = 1.4;
const ℝ option_x_interface26 = 0.5;
const ℝ option_δt_ini26 = 1.0e-5;
const ℝ option_δt_cfl26 = 0.4;
const ℝ option_ρ_ini_zg26 = 1.0;
const ℝ option_ρ_ini_zd26 = 0.125;
const ℝ option_p_ini_zg26 = 1.0;
const ℝ option_p_ini_zd26 = 0.1;

ℝ t26=0.0;
ℝ δt26=0.0;

ℝ² coord26[nodes26], X26[nodes26], b26[nodes26], bt26[nodes26];
ℝ²ˣ² Ar26[nodes26], Mt26[nodes26];
ℝ² ur26[nodes26];
ℝ p_ic26[cells26], ρ_ic26[cells26], V_ic26[cells26];
ℝ c26[cells26], m26[cells26], p26[cells26], ρ26[cells26], e26[cells26], E26[cells26], V26[cells26];
ℝ δtj26[cells26];
ℝ² uj26[cells26], center26[cells26];
ℝ l26[cells26, nodesOfCell26];
ℝ² C_ic26[cells26, nodesOfCell26], C26[cells26, nodesOfCell26], F26[cells26, nodesOfCell26];
ℝ²ˣ² Ajr26[cells26, nodesOfCell26];


// Options obligatoires pour générer
const ℝ LENGTH27 = 0.01;
const ℕ X_EDGE_ELEMS27 = 100;
const ℕ Y_EDGE_ELEMS27 = 10;
const ℕ Z_EDGE_ELEMS27 = 1;
const ℝ option_stoptime27 = 0.2;
const ℕ option_max_iterations27 = 20000;

// Autres options
const ℝ γ27 = 1.4;
const ℝ option_x_interface27 = 0.5;
const ℝ option_δt_ini27 = 1.0e-5;
const ℝ option_δt_cfl27 = 0.4;
const ℝ option_ρ_ini_zg27 = 1.0;
const ℝ option_ρ_ini_zd27 = 0.125;
const ℝ option_p_ini_zg27 = 1.0;
const ℝ option_p_ini_zd27 = 0.1;

ℝ t27=0.0;
ℝ δt27=0.0;

ℝ² coord27[nodes27], X27[nodes27], b27[nodes27], bt27[nodes27];
ℝ²ˣ² Ar27[nodes27], Mt27[nodes27];
ℝ² ur27[nodes27];
ℝ p_ic27[cells27], ρ_ic27[cells27], V_ic27[cells27];
ℝ c27[cells27], m27[cells27], p27[cells27], ρ27[cells27], e27[cells27], E27[cells27], V27[cells27];
ℝ δtj27[cells27];
ℝ² uj27[cells27], center27[cells27];
ℝ l27[cells27, nodesOfCell27];
ℝ² C_ic27[cells27, nodesOfCell27], C27[cells27, nodesOfCell27], F27[cells27, nodesOfCell27];
ℝ²ˣ² Ajr27[cells27, nodesOfCell27];


// Options obligatoires pour générer
const ℝ LENGTH28 = 0.01;
const ℕ X_EDGE_ELEMS28 = 100;
const ℕ Y_EDGE_ELEMS28 = 10;
const ℕ Z_EDGE_ELEMS28 = 1;
const ℝ option_stoptime28 = 0.2;
const ℕ option_max_iterations28 = 20000;

// Autres options
const ℝ γ28 = 1.4;
const ℝ option_x_interface28 = 0.5;
const ℝ option_δt_ini28 = 1.0e-5;
const ℝ option_δt_cfl28 = 0.4;
const ℝ option_ρ_ini_zg28 = 1.0;
const ℝ option_ρ_ini_zd28 = 0.125;
const ℝ option_p_ini_zg28 = 1.0;
const ℝ option_p_ini_zd28 = 0.1;

ℝ t28=0.0;
ℝ δt28=0.0;

ℝ² coord28[nodes28], X28[nodes28], b28[nodes28], bt28[nodes28];
ℝ²ˣ² Ar28[nodes28], Mt28[nodes28];
ℝ² ur28[nodes28];
ℝ p_ic28[cells28], ρ_ic28[cells28], V_ic28[cells28];
ℝ c28[cells28], m28[cells28], p28[cells28], ρ28[cells28], e28[cells28], E28[cells28], V28[cells28];
ℝ δtj28[cells28];
ℝ² uj28[cells28], center28[cells28];
ℝ l28[cells28, nodesOfCell28];
ℝ² C_ic28[cells28, nodesOfCell28], C28[cells28, nodesOfCell28], F28[cells28, nodesOfCell28];
ℝ²ˣ² Ajr28[cells28, nodesOfCell28];


// Options obligatoires pour générer
const ℝ LENGTH29 = 0.01;
const ℕ X_EDGE_ELEMS29 = 100;
const ℕ Y_EDGE_ELEMS29 = 10;
const ℕ Z_EDGE_ELEMS29 = 1;
const ℝ option_stoptime29 = 0.2;
const ℕ option_max_iterations29 = 20000;

// Autres options
const ℝ γ29 = 1.4;
const ℝ option_x_interface29 = 0.5;
const ℝ option_δt_ini29 = 1.0e-5;
const ℝ option_δt_cfl29 = 0.4;
const ℝ option_ρ_ini_zg29 = 1.0;
const ℝ option_ρ_ini_zd29 = 0.125;
const ℝ option_p_ini_zg29 = 1.0;
const ℝ option_p_ini_zd29 = 0.1;

ℝ t29=0.0;
ℝ δt29=0.0;

ℝ² coord29[nodes29], X29[nodes29], b29[nodes29], bt29[nodes29];
ℝ²ˣ² Ar29[nodes29], Mt29[nodes29];
ℝ² ur29[nodes29];
ℝ p_ic29[cells29], ρ_ic29[cells29], V_ic29[cells29];
ℝ c29[cells29], m29[cells29], p29[cells29], ρ29[cells29], e29[cells29], E29[cells29], V29[cells29];
ℝ δtj29[cells29];
ℝ² uj29[cells29], center29[cells29];
ℝ l29[cells29, nodesOfCell29];
ℝ² C_ic29[cells29, nodesOfCell29], C29[cells29, nodesOfCell29], F29[cells29, nodesOfCell29];
ℝ²ˣ² Ajr29[cells29, nodesOfCell29];


// Options obligatoires pour générer
const ℝ LENGTH30 = 0.01;
const ℕ X_EDGE_ELEMS30 = 100;
const ℕ Y_EDGE_ELEMS30 = 10;
const ℕ Z_EDGE_ELEMS30 = 1;
const ℝ option_stoptime30 = 0.2;
const ℕ option_max_iterations30 = 20000;

// Autres options
const ℝ γ30 = 1.4;
const ℝ option_x_interface30 = 0.5;
const ℝ option_δt_ini30 = 1.0e-5;
const ℝ option_δt_cfl30 = 0.4;
const ℝ option_ρ_ini_zg30 = 1.0;
const ℝ option_ρ_ini_zd30 = 0.125;
const ℝ option_p_ini_zg30 = 1.0;
const ℝ option_p_ini_zd30 = 0.1;

ℝ t30=0.0;
ℝ δt30=0.0;

ℝ² coord30[nodes30], X30[nodes30], b30[nodes30], bt30[nodes30];
ℝ²ˣ² Ar30[nodes30], Mt30[nodes30];
ℝ² ur30[nodes30];
ℝ p_ic30[cells30], ρ_ic30[cells30], V_ic30[cells30];
ℝ c30[cells30], m30[cells30], p30[cells30], ρ30[cells30], e30[cells30], E30[cells30], V30[cells30];
ℝ δtj30[cells30];
ℝ² uj30[cells30], center30[cells30];
ℝ l30[cells30, nodesOfCell30];
ℝ² C_ic30[cells30, nodesOfCell30], C30[cells30, nodesOfCell30], F30[cells30, nodesOfCell30];
ℝ²ˣ² Ajr30[cells30, nodesOfCell30];


// Options obligatoires pour générer
const ℝ LENGTH31 = 0.01;
const ℕ X_EDGE_ELEMS31 = 100;
const ℕ Y_EDGE_ELEMS31 = 10;
const ℕ Z_EDGE_ELEMS31 = 1;
const ℝ option_stoptime31 = 0.2;
const ℕ option_max_iterations31 = 20000;

// Autres options
const ℝ γ31 = 1.4;
const ℝ option_x_interface31 = 0.5;
const ℝ option_δt_ini31 = 1.0e-5;
const ℝ option_δt_cfl31 = 0.4;
const ℝ option_ρ_ini_zg31 = 1.0;
const ℝ option_ρ_ini_zd31 = 0.125;
const ℝ option_p_ini_zg31 = 1.0;
const ℝ option_p_ini_zd31 = 0.1;

ℝ t31=0.0;
ℝ δt31=0.0;

ℝ² coord31[nodes31], X31[nodes31], b31[nodes31], bt31[nodes31];
ℝ²ˣ² Ar31[nodes31], Mt31[nodes31];
ℝ² ur31[nodes31];
ℝ p_ic31[cells31], ρ_ic31[cells31], V_ic31[cells31];
ℝ c31[cells31], m31[cells31], p31[cells31], ρ31[cells31], e31[cells31], E31[cells31], V31[cells31];
ℝ δtj31[cells31];
ℝ² uj31[cells31], center31[cells31];
ℝ l31[cells31, nodesOfCell31];
ℝ² C_ic31[cells31, nodesOfCell31], C31[cells31, nodesOfCell31], F31[cells31, nodesOfCell31];
ℝ²ˣ² Ajr31[cells31, nodesOfCell31];


// Options obligatoires pour générer
const ℝ LENGTH32 = 0.01;
const ℕ X_EDGE_ELEMS32 = 100;
const ℕ Y_EDGE_ELEMS32 = 10;
const ℕ Z_EDGE_ELEMS32 = 1;
const ℝ option_stoptime32 = 0.2;
const ℕ option_max_iterations32 = 20000;

// Autres options
const ℝ γ32 = 1.4;
const ℝ option_x_interface32 = 0.5;
const ℝ option_δt_ini32 = 1.0e-5;
const ℝ option_δt_cfl32 = 0.4;
const ℝ option_ρ_ini_zg32 = 1.0;
const ℝ option_ρ_ini_zd32 = 0.125;
const ℝ option_p_ini_zg32 = 1.0;
const ℝ option_p_ini_zd32 = 0.1;

ℝ t32=0.0;
ℝ δt32=0.0;

ℝ² coord32[nodes32], X32[nodes32], b32[nodes32], bt32[nodes32];
ℝ²ˣ² Ar32[nodes32], Mt32[nodes32];
ℝ² ur32[nodes32];
ℝ p_ic32[cells32], ρ_ic32[cells32], V_ic32[cells32];
ℝ c32[cells32], m32[cells32], p32[cells32], ρ32[cells32], e32[cells32], E32[cells32], V32[cells32];
ℝ δtj32[cells32];
ℝ² uj32[cells32], center32[cells32];
ℝ l32[cells32, nodesOfCell32];
ℝ² C_ic32[cells32, nodesOfCell32], C32[cells32, nodesOfCell32], F32[cells32, nodesOfCell32];
ℝ²ˣ² Ajr32[cells32, nodesOfCell32];


// Options obligatoires pour générer
const ℝ LENGTH33 = 0.01;
const ℕ X_EDGE_ELEMS33 = 100;
const ℕ Y_EDGE_ELEMS33 = 10;
const ℕ Z_EDGE_ELEMS33 = 1;
const ℝ option_stoptime33 = 0.2;
const ℕ option_max_iterations33 = 20000;

// Autres options
const ℝ γ33 = 1.4;
const ℝ option_x_interface33 = 0.5;
const ℝ option_δt_ini33 = 1.0e-5;
const ℝ option_δt_cfl33 = 0.4;
const ℝ option_ρ_ini_zg33 = 1.0;
const ℝ option_ρ_ini_zd33 = 0.125;
const ℝ option_p_ini_zg33 = 1.0;
const ℝ option_p_ini_zd33 = 0.1;

ℝ t33=0.0;
ℝ δt33=0.0;

ℝ² coord33[nodes33], X33[nodes33], b33[nodes33], bt33[nodes33];
ℝ²ˣ² Ar33[nodes33], Mt33[nodes33];
ℝ² ur33[nodes33];
ℝ p_ic33[cells33], ρ_ic33[cells33], V_ic33[cells33];
ℝ c33[cells33], m33[cells33], p33[cells33], ρ33[cells33], e33[cells33], E33[cells33], V33[cells33];
ℝ δtj33[cells33];
ℝ² uj33[cells33], center33[cells33];
ℝ l33[cells33, nodesOfCell33];
ℝ² C_ic33[cells33, nodesOfCell33], C33[cells33, nodesOfCell33], F33[cells33, nodesOfCell33];
ℝ²ˣ² Ajr33[cells33, nodesOfCell33];


// Options obligatoires pour générer
const ℝ LENGTH34 = 0.01;
const ℕ X_EDGE_ELEMS34 = 100;
const ℕ Y_EDGE_ELEMS34 = 10;
const ℕ Z_EDGE_ELEMS34 = 1;
const ℝ option_stoptime34 = 0.2;
const ℕ option_max_iterations34 = 20000;

// Autres options
const ℝ γ34 = 1.4;
const ℝ option_x_interface34 = 0.5;
const ℝ option_δt_ini34 = 1.0e-5;
const ℝ option_δt_cfl34 = 0.4;
const ℝ option_ρ_ini_zg34 = 1.0;
const ℝ option_ρ_ini_zd34 = 0.125;
const ℝ option_p_ini_zg34 = 1.0;
const ℝ option_p_ini_zd34 = 0.1;

ℝ t34=0.0;
ℝ δt34=0.0;

ℝ² coord34[nodes34], X34[nodes34], b34[nodes34], bt34[nodes34];
ℝ²ˣ² Ar34[nodes34], Mt34[nodes34];
ℝ² ur34[nodes34];
ℝ p_ic34[cells34], ρ_ic34[cells34], V_ic34[cells34];
ℝ c34[cells34], m34[cells34], p34[cells34], ρ34[cells34], e34[cells34], E34[cells34], V34[cells34];
ℝ δtj34[cells34];
ℝ² uj34[cells34], center34[cells34];
ℝ l34[cells34, nodesOfCell34];
ℝ² C_ic34[cells34, nodesOfCell34], C34[cells34, nodesOfCell34], F34[cells34, nodesOfCell34];
ℝ²ˣ² Ajr34[cells34, nodesOfCell34];


// Options obligatoires pour générer
const ℝ LENGTH35 = 0.01;
const ℕ X_EDGE_ELEMS35 = 100;
const ℕ Y_EDGE_ELEMS35 = 10;
const ℕ Z_EDGE_ELEMS35 = 1;
const ℝ option_stoptime35 = 0.2;
const ℕ option_max_iterations35 = 20000;

// Autres options
const ℝ γ35 = 1.4;
const ℝ option_x_interface35 = 0.5;
const ℝ option_δt_ini35 = 1.0e-5;
const ℝ option_δt_cfl35 = 0.4;
const ℝ option_ρ_ini_zg35 = 1.0;
const ℝ option_ρ_ini_zd35 = 0.125;
const ℝ option_p_ini_zg35 = 1.0;
const ℝ option_p_ini_zd35 = 0.1;

ℝ t35=0.0;
ℝ δt35=0.0;

ℝ² coord35[nodes35], X35[nodes35], b35[nodes35], bt35[nodes35];
ℝ²ˣ² Ar35[nodes35], Mt35[nodes35];
ℝ² ur35[nodes35];
ℝ p_ic35[cells35], ρ_ic35[cells35], V_ic35[cells35];
ℝ c35[cells35], m35[cells35], p35[cells35], ρ35[cells35], e35[cells35], E35[cells35], V35[cells35];
ℝ δtj35[cells35];
ℝ² uj35[cells35], center35[cells35];
ℝ l35[cells35, nodesOfCell35];
ℝ² C_ic35[cells35, nodesOfCell35], C35[cells35, nodesOfCell35], F35[cells35, nodesOfCell35];
ℝ²ˣ² Ajr35[cells35, nodesOfCell35];


// Options obligatoires pour générer
const ℝ LENGTH36 = 0.01;
const ℕ X_EDGE_ELEMS36 = 100;
const ℕ Y_EDGE_ELEMS36 = 10;
const ℕ Z_EDGE_ELEMS36 = 1;
const ℝ option_stoptime36 = 0.2;
const ℕ option_max_iterations36 = 20000;

// Autres options
const ℝ γ36 = 1.4;
const ℝ option_x_interface36 = 0.5;
const ℝ option_δt_ini36 = 1.0e-5;
const ℝ option_δt_cfl36 = 0.4;
const ℝ option_ρ_ini_zg36 = 1.0;
const ℝ option_ρ_ini_zd36 = 0.125;
const ℝ option_p_ini_zg36 = 1.0;
const ℝ option_p_ini_zd36 = 0.1;

ℝ t36=0.0;
ℝ δt36=0.0;

ℝ² coord36[nodes36], X36[nodes36], b36[nodes36], bt36[nodes36];
ℝ²ˣ² Ar36[nodes36], Mt36[nodes36];
ℝ² ur36[nodes36];
ℝ p_ic36[cells36], ρ_ic36[cells36], V_ic36[cells36];
ℝ c36[cells36], m36[cells36], p36[cells36], ρ36[cells36], e36[cells36], E36[cells36], V36[cells36];
ℝ δtj36[cells36];
ℝ² uj36[cells36], center36[cells36];
ℝ l36[cells36, nodesOfCell36];
ℝ² C_ic36[cells36, nodesOfCell36], C36[cells36, nodesOfCell36], F36[cells36, nodesOfCell36];
ℝ²ˣ² Ajr36[cells36, nodesOfCell36];


// Options obligatoires pour générer
const ℝ LENGTH37 = 0.01;
const ℕ X_EDGE_ELEMS37 = 100;
const ℕ Y_EDGE_ELEMS37 = 10;
const ℕ Z_EDGE_ELEMS37 = 1;
const ℝ option_stoptime37 = 0.2;
const ℕ option_max_iterations37 = 20000;

// Autres options
const ℝ γ37 = 1.4;
const ℝ option_x_interface37 = 0.5;
const ℝ option_δt_ini37 = 1.0e-5;
const ℝ option_δt_cfl37 = 0.4;
const ℝ option_ρ_ini_zg37 = 1.0;
const ℝ option_ρ_ini_zd37 = 0.125;
const ℝ option_p_ini_zg37 = 1.0;
const ℝ option_p_ini_zd37 = 0.1;

ℝ t37=0.0;
ℝ δt37=0.0;

ℝ² coord37[nodes37], X37[nodes37], b37[nodes37], bt37[nodes37];
ℝ²ˣ² Ar37[nodes37], Mt37[nodes37];
ℝ² ur37[nodes37];
ℝ p_ic37[cells37], ρ_ic37[cells37], V_ic37[cells37];
ℝ c37[cells37], m37[cells37], p37[cells37], ρ37[cells37], e37[cells37], E37[cells37], V37[cells37];
ℝ δtj37[cells37];
ℝ² uj37[cells37], center37[cells37];
ℝ l37[cells37, nodesOfCell37];
ℝ² C_ic37[cells37, nodesOfCell37], C37[cells37, nodesOfCell37], F37[cells37, nodesOfCell37];
ℝ²ˣ² Ajr37[cells37, nodesOfCell37];


// Options obligatoires pour générer
const ℝ LENGTH38 = 0.01;
const ℕ X_EDGE_ELEMS38 = 100;
const ℕ Y_EDGE_ELEMS38 = 10;
const ℕ Z_EDGE_ELEMS38 = 1;
const ℝ option_stoptime38 = 0.2;
const ℕ option_max_iterations38 = 20000;

// Autres options
const ℝ γ38 = 1.4;
const ℝ option_x_interface38 = 0.5;
const ℝ option_δt_ini38 = 1.0e-5;
const ℝ option_δt_cfl38 = 0.4;
const ℝ option_ρ_ini_zg38 = 1.0;
const ℝ option_ρ_ini_zd38 = 0.125;
const ℝ option_p_ini_zg38 = 1.0;
const ℝ option_p_ini_zd38 = 0.1;

ℝ t38=0.0;
ℝ δt38=0.0;

ℝ² coord38[nodes38], X38[nodes38], b38[nodes38], bt38[nodes38];
ℝ²ˣ² Ar38[nodes38], Mt38[nodes38];
ℝ² ur38[nodes38];
ℝ p_ic38[cells38], ρ_ic38[cells38], V_ic38[cells38];
ℝ c38[cells38], m38[cells38], p38[cells38], ρ38[cells38], e38[cells38], E38[cells38], V38[cells38];
ℝ δtj38[cells38];
ℝ² uj38[cells38], center38[cells38];
ℝ l38[cells38, nodesOfCell38];
ℝ² C_ic38[cells38, nodesOfCell38], C38[cells38, nodesOfCell38], F38[cells38, nodesOfCell38];
ℝ²ˣ² Ajr38[cells38, nodesOfCell38];


// Options obligatoires pour générer
const ℝ LENGTH39 = 0.01;
const ℕ X_EDGE_ELEMS39 = 100;
const ℕ Y_EDGE_ELEMS39 = 10;
const ℕ Z_EDGE_ELEMS39 = 1;
const ℝ option_stoptime39 = 0.2;
const ℕ option_max_iterations39 = 20000;

// Autres options
const ℝ γ39 = 1.4;
const ℝ option_x_interface39 = 0.5;
const ℝ option_δt_ini39 = 1.0e-5;
const ℝ option_δt_cfl39 = 0.4;
const ℝ option_ρ_ini_zg39 = 1.0;
const ℝ option_ρ_ini_zd39 = 0.125;
const ℝ option_p_ini_zg39 = 1.0;
const ℝ option_p_ini_zd39 = 0.1;

ℝ t39=0.0;
ℝ δt39=0.0;

ℝ² coord39[nodes39], X39[nodes39], b39[nodes39], bt39[nodes39];
ℝ²ˣ² Ar39[nodes39], Mt39[nodes39];
ℝ² ur39[nodes39];
ℝ p_ic39[cells39], ρ_ic39[cells39], V_ic39[cells39];
ℝ c39[cells39], m39[cells39], p39[cells39], ρ39[cells39], e39[cells39], E39[cells39], V39[cells39];
ℝ δtj39[cells39];
ℝ² uj39[cells39], center39[cells39];
ℝ l39[cells39, nodesOfCell39];
ℝ² C_ic39[cells39, nodesOfCell39], C39[cells39, nodesOfCell39], F39[cells39, nodesOfCell39];
ℝ²ˣ² Ajr39[cells39, nodesOfCell39];


// Options obligatoires pour générer
const ℝ LENGTH40 = 0.01;
const ℕ X_EDGE_ELEMS40 = 100;
const ℕ Y_EDGE_ELEMS40 = 10;
const ℕ Z_EDGE_ELEMS40 = 1;
const ℝ option_stoptime40 = 0.2;
const ℕ option_max_iterations40 = 20000;

// Autres options
const ℝ γ40 = 1.4;
const ℝ option_x_interface40 = 0.5;
const ℝ option_δt_ini40 = 1.0e-5;
const ℝ option_δt_cfl40 = 0.4;
const ℝ option_ρ_ini_zg40 = 1.0;
const ℝ option_ρ_ini_zd40 = 0.125;
const ℝ option_p_ini_zg40 = 1.0;
const ℝ option_p_ini_zd40 = 0.1;

ℝ t40=0.0;
ℝ δt40=0.0;

ℝ² coord40[nodes40], X40[nodes40], b40[nodes40], bt40[nodes40];
ℝ²ˣ² Ar40[nodes40], Mt40[nodes40];
ℝ² ur40[nodes40];
ℝ p_ic40[cells40], ρ_ic40[cells40], V_ic40[cells40];
ℝ c40[cells40], m40[cells40], p40[cells40], ρ40[cells40], e40[cells40], E40[cells40], V40[cells40];
ℝ δtj40[cells40];
ℝ² uj40[cells40], center40[cells40];
ℝ l40[cells40, nodesOfCell40];
ℝ² C_ic40[cells40, nodesOfCell40], C40[cells40, nodesOfCell40], F40[cells40, nodesOfCell40];
ℝ²ˣ² Ajr40[cells40, nodesOfCell40];


// Options obligatoires pour générer
const ℝ LENGTH41 = 0.01;
const ℕ X_EDGE_ELEMS41 = 100;
const ℕ Y_EDGE_ELEMS41 = 10;
const ℕ Z_EDGE_ELEMS41 = 1;
const ℝ option_stoptime41 = 0.2;
const ℕ option_max_iterations41 = 20000;

// Autres options
const ℝ γ41 = 1.4;
const ℝ option_x_interface41 = 0.5;
const ℝ option_δt_ini41 = 1.0e-5;
const ℝ option_δt_cfl41 = 0.4;
const ℝ option_ρ_ini_zg41 = 1.0;
const ℝ option_ρ_ini_zd41 = 0.125;
const ℝ option_p_ini_zg41 = 1.0;
const ℝ option_p_ini_zd41 = 0.1;

ℝ t41=0.0;
ℝ δt41=0.0;

ℝ² coord41[nodes41], X41[nodes41], b41[nodes41], bt41[nodes41];
ℝ²ˣ² Ar41[nodes41], Mt41[nodes41];
ℝ² ur41[nodes41];
ℝ p_ic41[cells41], ρ_ic41[cells41], V_ic41[cells41];
ℝ c41[cells41], m41[cells41], p41[cells41], ρ41[cells41], e41[cells41], E41[cells41], V41[cells41];
ℝ δtj41[cells41];
ℝ² uj41[cells41], center41[cells41];
ℝ l41[cells41, nodesOfCell41];
ℝ² C_ic41[cells41, nodesOfCell41], C41[cells41, nodesOfCell41], F41[cells41, nodesOfCell41];
ℝ²ˣ² Ajr41[cells41, nodesOfCell41];


// Options obligatoires pour générer
const ℝ LENGTH42 = 0.01;
const ℕ X_EDGE_ELEMS42 = 100;
const ℕ Y_EDGE_ELEMS42 = 10;
const ℕ Z_EDGE_ELEMS42 = 1;
const ℝ option_stoptime42 = 0.2;
const ℕ option_max_iterations42 = 20000;

// Autres options
const ℝ γ42 = 1.4;
const ℝ option_x_interface42 = 0.5;
const ℝ option_δt_ini42 = 1.0e-5;
const ℝ option_δt_cfl42 = 0.4;
const ℝ option_ρ_ini_zg42 = 1.0;
const ℝ option_ρ_ini_zd42 = 0.125;
const ℝ option_p_ini_zg42 = 1.0;
const ℝ option_p_ini_zd42 = 0.1;

ℝ t42=0.0;
ℝ δt42=0.0;

ℝ² coord42[nodes42], X42[nodes42], b42[nodes42], bt42[nodes42];
ℝ²ˣ² Ar42[nodes42], Mt42[nodes42];
ℝ² ur42[nodes42];
ℝ p_ic42[cells42], ρ_ic42[cells42], V_ic42[cells42];
ℝ c42[cells42], m42[cells42], p42[cells42], ρ42[cells42], e42[cells42], E42[cells42], V42[cells42];
ℝ δtj42[cells42];
ℝ² uj42[cells42], center42[cells42];
ℝ l42[cells42, nodesOfCell42];
ℝ² C_ic42[cells42, nodesOfCell42], C42[cells42, nodesOfCell42], F42[cells42, nodesOfCell42];
ℝ²ˣ² Ajr42[cells42, nodesOfCell42];


// Options obligatoires pour générer
const ℝ LENGTH43 = 0.01;
const ℕ X_EDGE_ELEMS43 = 100;
const ℕ Y_EDGE_ELEMS43 = 10;
const ℕ Z_EDGE_ELEMS43 = 1;
const ℝ option_stoptime43 = 0.2;
const ℕ option_max_iterations43 = 20000;

// Autres options
const ℝ γ43 = 1.4;
const ℝ option_x_interface43 = 0.5;
const ℝ option_δt_ini43 = 1.0e-5;
const ℝ option_δt_cfl43 = 0.4;
const ℝ option_ρ_ini_zg43 = 1.0;
const ℝ option_ρ_ini_zd43 = 0.125;
const ℝ option_p_ini_zg43 = 1.0;
const ℝ option_p_ini_zd43 = 0.1;

ℝ t43=0.0;
ℝ δt43=0.0;

ℝ² coord43[nodes43], X43[nodes43], b43[nodes43], bt43[nodes43];
ℝ²ˣ² Ar43[nodes43], Mt43[nodes43];
ℝ² ur43[nodes43];
ℝ p_ic43[cells43], ρ_ic43[cells43], V_ic43[cells43];
ℝ c43[cells43], m43[cells43], p43[cells43], ρ43[cells43], e43[cells43], E43[cells43], V43[cells43];
ℝ δtj43[cells43];
ℝ² uj43[cells43], center43[cells43];
ℝ l43[cells43, nodesOfCell43];
ℝ² C_ic43[cells43, nodesOfCell43], C43[cells43, nodesOfCell43], F43[cells43, nodesOfCell43];
ℝ²ˣ² Ajr43[cells43, nodesOfCell43];


// Options obligatoires pour générer
const ℝ LENGTH44 = 0.01;
const ℕ X_EDGE_ELEMS44 = 100;
const ℕ Y_EDGE_ELEMS44 = 10;
const ℕ Z_EDGE_ELEMS44 = 1;
const ℝ option_stoptime44 = 0.2;
const ℕ option_max_iterations44 = 20000;

// Autres options
const ℝ γ44 = 1.4;
const ℝ option_x_interface44 = 0.5;
const ℝ option_δt_ini44 = 1.0e-5;
const ℝ option_δt_cfl44 = 0.4;
const ℝ option_ρ_ini_zg44 = 1.0;
const ℝ option_ρ_ini_zd44 = 0.125;
const ℝ option_p_ini_zg44 = 1.0;
const ℝ option_p_ini_zd44 = 0.1;

ℝ t44=0.0;
ℝ δt44=0.0;

ℝ² coord44[nodes44], X44[nodes44], b44[nodes44], bt44[nodes44];
ℝ²ˣ² Ar44[nodes44], Mt44[nodes44];
ℝ² ur44[nodes44];
ℝ p_ic44[cells44], ρ_ic44[cells44], V_ic44[cells44];
ℝ c44[cells44], m44[cells44], p44[cells44], ρ44[cells44], e44[cells44], E44[cells44], V44[cells44];
ℝ δtj44[cells44];
ℝ² uj44[cells44], center44[cells44];
ℝ l44[cells44, nodesOfCell44];
ℝ² C_ic44[cells44, nodesOfCell44], C44[cells44, nodesOfCell44], F44[cells44, nodesOfCell44];
ℝ²ˣ² Ajr44[cells44, nodesOfCell44];


// Options obligatoires pour générer
const ℝ LENGTH45 = 0.01;
const ℕ X_EDGE_ELEMS45 = 100;
const ℕ Y_EDGE_ELEMS45 = 10;
const ℕ Z_EDGE_ELEMS45 = 1;
const ℝ option_stoptime45 = 0.2;
const ℕ option_max_iterations45 = 20000;

// Autres options
const ℝ γ45 = 1.4;
const ℝ option_x_interface45 = 0.5;
const ℝ option_δt_ini45 = 1.0e-5;
const ℝ option_δt_cfl45 = 0.4;
const ℝ option_ρ_ini_zg45 = 1.0;
const ℝ option_ρ_ini_zd45 = 0.125;
const ℝ option_p_ini_zg45 = 1.0;
const ℝ option_p_ini_zd45 = 0.1;

ℝ t45=0.0;
ℝ δt45=0.0;

ℝ² coord45[nodes45], X45[nodes45], b45[nodes45], bt45[nodes45];
ℝ²ˣ² Ar45[nodes45], Mt45[nodes45];
ℝ² ur45[nodes45];
ℝ p_ic45[cells45], ρ_ic45[cells45], V_ic45[cells45];
ℝ c45[cells45], m45[cells45], p45[cells45], ρ45[cells45], e45[cells45], E45[cells45], V45[cells45];
ℝ δtj45[cells45];
ℝ² uj45[cells45], center45[cells45];
ℝ l45[cells45, nodesOfCell45];
ℝ² C_ic45[cells45, nodesOfCell45], C45[cells45, nodesOfCell45], F45[cells45, nodesOfCell45];
ℝ²ˣ² Ajr45[cells45, nodesOfCell45];


// Options obligatoires pour générer
const ℝ LENGTH46 = 0.01;
const ℕ X_EDGE_ELEMS46 = 100;
const ℕ Y_EDGE_ELEMS46 = 10;
const ℕ Z_EDGE_ELEMS46 = 1;
const ℝ option_stoptime46 = 0.2;
const ℕ option_max_iterations46 = 20000;

// Autres options
const ℝ γ46 = 1.4;
const ℝ option_x_interface46 = 0.5;
const ℝ option_δt_ini46 = 1.0e-5;
const ℝ option_δt_cfl46 = 0.4;
const ℝ option_ρ_ini_zg46 = 1.0;
const ℝ option_ρ_ini_zd46 = 0.125;
const ℝ option_p_ini_zg46 = 1.0;
const ℝ option_p_ini_zd46 = 0.1;

ℝ t46=0.0;
ℝ δt46=0.0;

ℝ² coord46[nodes46], X46[nodes46], b46[nodes46], bt46[nodes46];
ℝ²ˣ² Ar46[nodes46], Mt46[nodes46];
ℝ² ur46[nodes46];
ℝ p_ic46[cells46], ρ_ic46[cells46], V_ic46[cells46];
ℝ c46[cells46], m46[cells46], p46[cells46], ρ46[cells46], e46[cells46], E46[cells46], V46[cells46];
ℝ δtj46[cells46];
ℝ² uj46[cells46], center46[cells46];
ℝ l46[cells46, nodesOfCell46];
ℝ² C_ic46[cells46, nodesOfCell46], C46[cells46, nodesOfCell46], F46[cells46, nodesOfCell46];
ℝ²ˣ² Ajr46[cells46, nodesOfCell46];


// Options obligatoires pour générer
const ℝ LENGTH47 = 0.01;
const ℕ X_EDGE_ELEMS47 = 100;
const ℕ Y_EDGE_ELEMS47 = 10;
const ℕ Z_EDGE_ELEMS47 = 1;
const ℝ option_stoptime47 = 0.2;
const ℕ option_max_iterations47 = 20000;

// Autres options
const ℝ γ47 = 1.4;
const ℝ option_x_interface47 = 0.5;
const ℝ option_δt_ini47 = 1.0e-5;
const ℝ option_δt_cfl47 = 0.4;
const ℝ option_ρ_ini_zg47 = 1.0;
const ℝ option_ρ_ini_zd47 = 0.125;
const ℝ option_p_ini_zg47 = 1.0;
const ℝ option_p_ini_zd47 = 0.1;

ℝ t47=0.0;
ℝ δt47=0.0;

ℝ² coord47[nodes47], X47[nodes47], b47[nodes47], bt47[nodes47];
ℝ²ˣ² Ar47[nodes47], Mt47[nodes47];
ℝ² ur47[nodes47];
ℝ p_ic47[cells47], ρ_ic47[cells47], V_ic47[cells47];
ℝ c47[cells47], m47[cells47], p47[cells47], ρ47[cells47], e47[cells47], E47[cells47], V47[cells47];
ℝ δtj47[cells47];
ℝ² uj47[cells47], center47[cells47];
ℝ l47[cells47, nodesOfCell47];
ℝ² C_ic47[cells47, nodesOfCell47], C47[cells47, nodesOfCell47], F47[cells47, nodesOfCell47];
ℝ²ˣ² Ajr47[cells47, nodesOfCell47];


// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter1: ∀j1∈cells1(), center1{j1} = (1.0/4.0) * ∑{r1∈nodesOfCell1(j1)}(coord1{r1});
IniIc1: ∀j1∈cells1(), if (center1{j1}.x < option_x_interface1) {
  ρ_ic1{j1}=option_ρ_ini_zg1;
  p_ic1{j1}=option_p_ini_zg1;
} else {
  ρ_ic1{j1}=option_ρ_ini_zd1;
  p_ic1{j1}=option_p_ini_zd1;
}

ComputeCjrIc1: ∀j1∈cells1(), ∀r1∈nodesOfCell1(j1), 
	C_ic1{j1,r1} = 0.5 * perp1(coord1{►(r1)} - coord1{◄(r1)});
IniVIc1: ∀j1∈cells1(), V_ic1{j1} = 0.5 * ∑{r1∈nodesOfCell1(j1)}(dot(C_ic1{j1,r1}, coord1{r1}));
IniM1: ∀j1∈cells1(), m1{j1} = ρ_ic1{j1} * V_ic1{j1}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr1: ∀j1∈cells1(), ∀r1∈nodesOfCell1(j1), C1{j1,r1} = 0.5 * perp1(X1{►(r1)} - X1{◄(r1)});
ComputeLjr1: ∀j1∈cells1(), ∀r1∈nodesOfCell1(j1), l1{j1,r1} = norm(C1{j1,r1});
Computeδtj1: ∀j1∈cells1(), δtj1{j1} = 2.0 * V1{j1} / (c1{j1} * ∑{r1∈nodesOfCell1(j1)}(l1{j1,r1}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity1: ∀j1∈cells1(), ρ1{j1} = m1{j1} / V1{j1};
ComputeEOSp1: ∀j1∈cells1(), p1{j1} = (γ1-1.0) * ρ1{j1} * e1{j1};
ComputeInternalEngergy1: ∀j1∈cells1(), e1{j1} = E1{j1} - 0.5 * dot(uj1{j1}, uj1{j1});
ComputeEOSc1: ∀j1∈cells1(), c1{j1} = √(γ1*p1{j1}/ρ1{j1}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr1: ∀j1∈cells1(), ∀r1∈nodesOfCell1(j1), Ajr1{j1,r1} = ((ρ1{j1}*c1{j1})/l1{j1,r1}) * tensProduct1(C1{j1,r1}, C1{j1,r1});
ComputeFjr1: ∀j1∈cells1(), ∀r1∈nodesOfCell1(j1), F1{j1,r1} = p1{j1}*C1{j1,r1} + matVectProduct1(Ajr1{j1,r1}, (uj1{j1}-ur1{r1}));
ComputeAr1: ∀r1∈nodes1(), Ar1{r1} = ∑{j1∈cellsOfNode1(r1)}(Ajr1{j1,r1});
ComputeBr1: ∀r1∈nodes1(), b1{r1} = ∑{j1∈cellsOfNode1(r1)}(p1{j1}*C1{j1,r1} + matVectProduct1(Ajr1{j1,r1}, uj1{j1}));
ComputeMt1: ∀r1∈innerNodes1(), Mt1{r1} = Ar1{r1};
ComputeBt1: ∀r1∈innerNodes1(), bt1{r1} = b1{r1};

OuterFacesComputations1: ∀k1∈outerFaces1(), {
	const ℝ epsilon1 = 1.0e-10;
	ℝ²ˣ² I1 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN1 = 0.0;
	ℝ X_MAX1 = X_EDGE_ELEMS1 * LENGTH1;
	ℝ Y_MIN1 = 0.0; 
	ℝ Y_MAX1 = Y_EDGE_ELEMS1 * LENGTH1;
	ℝ² nY1 = {0.0,1.0};
	
	∀r1∈nodesOfFace1(k1), {
		// Y boundary conditions (must be done before X)
		if ((X1{r1}.y-Y_MIN1 < epsilon1) || (X1{r1}.y-Y_MAX1 < epsilon1)) {
			ℝ sign1 = 0.0;
			if (X1{r1}.y-Y_MIN1 < epsilon1) sign1 = -1.0;
			else sign1 = 1.0;
			ℝ² n1 = sign1 * nY1;
      		ℝ²ˣ² nxn1 = tensProduct1(n1,n1);
      		ℝ²ˣ² IcP1 = I1 - nxn1;
			bt1{r1} = matVectProduct1(IcP1, b1{r1});
			Mt1{r1} = IcP1 * (Ar1{r1} * IcP1) + nxn1*trace1(Ar1{r1});
		}

		// X boundary conditions
		if ((Math.fabs(X1{r1}.x-X_MIN1) < epsilon1) || ( (Math.fabs(X1{r1}.x-X_MAX1) < epsilon1) )) {
			Mt1{r1} = I1;
			bt1{r1} = {0.0, 0.0};
		}
	}
}


ComputeU1: ∀r1∈nodes1(), ur1{r1} = matVectProduct1(inverse1(Mt1{r1}), bt1{r1});
ComputeV1: ∀j1∈cells1(), V1{j1} = 0.5 * ∑{r1∈nodesOfCell1(j1)}(dot(C1{j1,r1},X1{r1}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn1: ∀n1∈ℕ, ∀r01∈nodes1(), X1{r01}^{n1=0}=coord1{r01}; , ∀r1∈nodes1(), X1{r1}^{n1+1}=X1{r1}^{n1}+δt1^{n1}*ur1{r1};
ComputeUn1: ∀n1∈ℕ, ∀j01∈cells1(), uj1{j01}^{n1=0}={0.0,0.0}; , ∀j1∈cells1(), uj1{j1}^{n1+1}=uj1{j1}^{n1}-(δt1^{n1}/m1{j1})*∑{r1∈nodesOfCell1(j1)}(F1{j1,r1});
ComputeEn1: ∀n1∈ℕ, ∀j01∈cells1(), E1{j01}^{n1=0}=p_ic1{j01}/((γ1-1.0)*ρ_ic1{j01}); , ∀j1∈cells1(), E1{j1}^{n1+1}=E1{j1}^{n1} - (δt1^{n1} / m1{j1}) * ∑{r1∈nodesOfCell1(j1)}(dot(F1{j1,r1},ur1{r1}));
ComputeDt1: ∀n1∈ℕ, δt1^{n1=0}=option_δt_ini1;, δt1^{n1+1}=option_δt_cfl1*reduceMin{j1∈cells1()}(δtj1{j1});
ComputeTn1: ∀n1∈ℕ, t1^{n1=0}=0.0; , t1^{n1+1}=t1^{n1}+δt1^{n1+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter2: ∀j2∈cells2(), center2{j2} = (1.0/4.0) * ∑{r2∈nodesOfCell2(j2)}(coord2{r2});
IniIc2: ∀j2∈cells2(), if (center2{j2}.x < option_x_interface2) {
  ρ_ic2{j2}=option_ρ_ini_zg2;
  p_ic2{j2}=option_p_ini_zg2;
} else {
  ρ_ic2{j2}=option_ρ_ini_zd2;
  p_ic2{j2}=option_p_ini_zd2;
}

ComputeCjrIc2: ∀j2∈cells2(), ∀r2∈nodesOfCell2(j2), 
	C_ic2{j2,r2} = 0.5 * perp2(coord2{►(r2)} - coord2{◄(r2)});
IniVIc2: ∀j2∈cells2(), V_ic2{j2} = 0.5 * ∑{r2∈nodesOfCell2(j2)}(dot(C_ic2{j2,r2}, coord2{r2}));
IniM2: ∀j2∈cells2(), m2{j2} = ρ_ic2{j2} * V_ic2{j2}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr2: ∀j2∈cells2(), ∀r2∈nodesOfCell2(j2), C2{j2,r2} = 0.5 * perp2(X2{►(r2)} - X2{◄(r2)});
ComputeLjr2: ∀j2∈cells2(), ∀r2∈nodesOfCell2(j2), l2{j2,r2} = norm(C2{j2,r2});
Computeδtj2: ∀j2∈cells2(), δtj2{j2} = 2.0 * V2{j2} / (c2{j2} * ∑{r2∈nodesOfCell2(j2)}(l2{j2,r2}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity2: ∀j2∈cells2(), ρ2{j2} = m2{j2} / V2{j2};
ComputeEOSp2: ∀j2∈cells2(), p2{j2} = (γ2-1.0) * ρ2{j2} * e2{j2};
ComputeInternalEngergy2: ∀j2∈cells2(), e2{j2} = E2{j2} - 0.5 * dot(uj2{j2}, uj2{j2});
ComputeEOSc2: ∀j2∈cells2(), c2{j2} = √(γ2*p2{j2}/ρ2{j2}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr2: ∀j2∈cells2(), ∀r2∈nodesOfCell2(j2), Ajr2{j2,r2} = ((ρ2{j2}*c2{j2})/l2{j2,r2}) * tensProduct2(C2{j2,r2}, C2{j2,r2});
ComputeFjr2: ∀j2∈cells2(), ∀r2∈nodesOfCell2(j2), F2{j2,r2} = p2{j2}*C2{j2,r2} + matVectProduct2(Ajr2{j2,r2}, (uj2{j2}-ur2{r2}));
ComputeAr2: ∀r2∈nodes2(), Ar2{r2} = ∑{j2∈cellsOfNode2(r2)}(Ajr2{j2,r2});
ComputeBr2: ∀r2∈nodes2(), b2{r2} = ∑{j2∈cellsOfNode2(r2)}(p2{j2}*C2{j2,r2} + matVectProduct2(Ajr2{j2,r2}, uj2{j2}));
ComputeMt2: ∀r2∈innerNodes2(), Mt2{r2} = Ar2{r2};
ComputeBt2: ∀r2∈innerNodes2(), bt2{r2} = b2{r2};

OuterFacesComputations2: ∀k2∈outerFaces2(), {
	const ℝ epsilon2 = 1.0e-10;
	ℝ²ˣ² I2 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN2 = 0.0;
	ℝ X_MAX2 = X_EDGE_ELEMS2 * LENGTH2;
	ℝ Y_MIN2 = 0.0; 
	ℝ Y_MAX2 = Y_EDGE_ELEMS2 * LENGTH2;
	ℝ² nY2 = {0.0,1.0};
	
	∀r2∈nodesOfFace2(k2), {
		// Y boundary conditions (must be done before X)
		if ((X2{r2}.y-Y_MIN2 < epsilon2) || (X2{r2}.y-Y_MAX2 < epsilon2)) {
			ℝ sign2 = 0.0;
			if (X2{r2}.y-Y_MIN2 < epsilon2) sign2 = -1.0;
			else sign2 = 1.0;
			ℝ² n2 = sign2 * nY2;
      		ℝ²ˣ² nxn2 = tensProduct2(n2,n2);
      		ℝ²ˣ² IcP2 = I2 - nxn2;
			bt1{r2} = matVectProduct2(IcP2, b2{r2});
			Mt1{r2} = IcP2 * (Ar2{r2} * IcP2) + nxn2*trace2(Ar2{r2});
		}

		// X boundary conditions
		if ((Math.fabs(X2{r2}.x-X_MIN2) < epsilon2) || ( (Math.fabs(X2{r2}.x-X_MAX2) < epsilon2) )) {
			Mt2{r2} = I2;
			bt2{r2} = {0.0, 0.0};
		}
	}
}


ComputeU2: ∀r2∈nodes2(), ur2{r2} = matVectProduct2(inverse2(Mt2{r2}), bt2{r2});
ComputeV2: ∀j2∈cells2(), V2{j2} = 0.5 * ∑{r2∈nodesOfCell2(j2)}(dot(C2{j2,r2},X2{r2}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn2: ∀n2∈ℕ, ∀r02∈nodes2(), X2{r02}^{n2=0}=coord2{r02}; , ∀r2∈nodes2(), X2{r2}^{n2+1}=X2{r2}^{n2}+δt2^{n2}*ur2{r2};
ComputeUn2: ∀n2∈ℕ, ∀j02∈cells2(), uj2{j02}^{n2=0}={0.0,0.0}; , ∀j2∈cells2(), uj2{j2}^{n2+1}=uj2{j2}^{n2}-(δt2^{n2}/m2{j2})*∑{r2∈nodesOfCell2(j2)}(F2{j2,r2});
ComputeEn2: ∀n2∈ℕ, ∀j02∈cells2(), E2{j02}^{n2=0}=p_ic2{j02}/((γ2-1.0)*ρ_ic2{j02}); , ∀j2∈cells2(), E2{j2}^{n2+1}=E2{j2}^{n2} - (δt2^{n2} / m2{j2}) * ∑{r2∈nodesOfCell2(j2)}(dot(F2{j2,r2},ur2{r2}));
ComputeDt2: ∀n2∈ℕ, δt2^{n2=0}=option_δt_ini2;, δt2^{n2+1}=option_δt_cfl2*reduceMin{j2∈cells2()}(δtj2{j2});
ComputeTn2: ∀n2∈ℕ, t2^{n2=0}=0.0; , t2^{n2+1}=t2^{n2}+δt2^{n2+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter3: ∀j3∈cells3(), center3{j3} = (1.0/4.0) * ∑{r3∈nodesOfCell3(j3)}(coord3{r3});
IniIc3: ∀j3∈cells3(), if (center3{j3}.x < option_x_interface3) {
  ρ_ic3{j3}=option_ρ_ini_zg3;
  p_ic3{j3}=option_p_ini_zg3;
} else {
  ρ_ic3{j3}=option_ρ_ini_zd3;
  p_ic3{j3}=option_p_ini_zd3;
}

ComputeCjrIc3: ∀j3∈cells3(), ∀r3∈nodesOfCell3(j3), 
	C_ic3{j3,r3} = 0.5 * perp3(coord3{►(r3)} - coord3{◄(r3)});
IniVIc3: ∀j3∈cells3(), V_ic3{j3} = 0.5 * ∑{r3∈nodesOfCell3(j3)}(dot(C_ic3{j3,r3}, coord3{r3}));
IniM3: ∀j3∈cells3(), m3{j3} = ρ_ic3{j3} * V_ic3{j3}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr3: ∀j3∈cells3(), ∀r3∈nodesOfCell3(j3), C3{j3,r3} = 0.5 * perp3(X3{►(r3)} - X3{◄(r3)});
ComputeLjr3: ∀j3∈cells3(), ∀r3∈nodesOfCell3(j3), l3{j3,r3} = norm(C3{j3,r3});
Computeδtj3: ∀j3∈cells3(), δtj3{j3} = 2.0 * V3{j3} / (c3{j3} * ∑{r3∈nodesOfCell3(j3)}(l3{j3,r3}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity3: ∀j3∈cells3(), ρ3{j3} = m3{j3} / V3{j3};
ComputeEOSp3: ∀j3∈cells3(), p3{j3} = (γ3-1.0) * ρ3{j3} * e3{j3};
ComputeInternalEngergy3: ∀j3∈cells3(), e3{j3} = E3{j3} - 0.5 * dot(uj3{j3}, uj3{j3});
ComputeEOSc3: ∀j3∈cells3(), c3{j3} = √(γ3*p3{j3}/ρ3{j3}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr3: ∀j3∈cells3(), ∀r3∈nodesOfCell3(j3), Ajr3{j3,r3} = ((ρ3{j3}*c3{j3})/l3{j3,r3}) * tensProduct3(C3{j3,r3}, C3{j3,r3});
ComputeFjr3: ∀j3∈cells3(), ∀r3∈nodesOfCell3(j3), F3{j3,r3} = p3{j3}*C3{j3,r3} + matVectProduct3(Ajr3{j3,r3}, (uj3{j3}-ur3{r3}));
ComputeAr3: ∀r3∈nodes3(), Ar3{r3} = ∑{j3∈cellsOfNode3(r3)}(Ajr3{j3,r3});
ComputeBr3: ∀r3∈nodes3(), b3{r3} = ∑{j3∈cellsOfNode3(r3)}(p3{j3}*C3{j3,r3} + matVectProduct3(Ajr3{j3,r3}, uj3{j3}));
ComputeMt3: ∀r3∈innerNodes3(), Mt3{r3} = Ar3{r3};
ComputeBt3: ∀r3∈innerNodes3(), bt3{r3} = b3{r3};

OuterFacesComputations3: ∀k3∈outerFaces3(), {
	const ℝ epsilon3 = 1.0e-10;
	ℝ²ˣ² I3 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN3 = 0.0;
	ℝ X_MAX3 = X_EDGE_ELEMS3 * LENGTH3;
	ℝ Y_MIN3 = 0.0; 
	ℝ Y_MAX3 = Y_EDGE_ELEMS3 * LENGTH3;
	ℝ² nY3 = {0.0,1.0};
	
	∀r3∈nodesOfFace3(k3), {
		// Y boundary conditions (must be done before X)
		if ((X3{r3}.y-Y_MIN3 < epsilon3) || (X3{r3}.y-Y_MAX3 < epsilon3)) {
			ℝ sign3 = 0.0;
			if (X3{r3}.y-Y_MIN3 < epsilon3) sign3 = -1.0;
			else sign3 = 1.0;
			ℝ² n3 = sign3 * nY3;
      		ℝ²ˣ² nxn3 = tensProduct3(n3,n3);
      		ℝ²ˣ² IcP3 = I3 - nxn3;
			bt1{r3} = matVectProduct3(IcP3, b3{r3});
			Mt1{r3} = IcP3 * (Ar3{r3} * IcP3) + nxn3*trace3(Ar3{r3});
		}

		// X boundary conditions
		if ((Math.fabs(X3{r3}.x-X_MIN3) < epsilon3) || ( (Math.fabs(X3{r3}.x-X_MAX3) < epsilon3) )) {
			Mt3{r3} = I3;
			bt3{r3} = {0.0, 0.0};
		}
	}
}


ComputeU3: ∀r3∈nodes3(), ur3{r3} = matVectProduct3(inverse3(Mt3{r3}), bt3{r3});
ComputeV3: ∀j3∈cells3(), V3{j3} = 0.5 * ∑{r3∈nodesOfCell3(j3)}(dot(C3{j3,r3},X3{r3}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn3: ∀n3∈ℕ, ∀r03∈nodes3(), X3{r03}^{n3=0}=coord3{r03}; , ∀r3∈nodes3(), X3{r3}^{n3+1}=X3{r3}^{n3}+δt3^{n3}*ur3{r3};
ComputeUn3: ∀n3∈ℕ, ∀j03∈cells3(), uj3{j03}^{n3=0}={0.0,0.0}; , ∀j3∈cells3(), uj3{j3}^{n3+1}=uj3{j3}^{n3}-(δt3^{n3}/m3{j3})*∑{r3∈nodesOfCell3(j3)}(F3{j3,r3});
ComputeEn3: ∀n3∈ℕ, ∀j03∈cells3(), E3{j03}^{n3=0}=p_ic3{j03}/((γ3-1.0)*ρ_ic3{j03}); , ∀j3∈cells3(), E3{j3}^{n3+1}=E3{j3}^{n3} - (δt3^{n3} / m3{j3}) * ∑{r3∈nodesOfCell3(j3)}(dot(F3{j3,r3},ur3{r3}));
ComputeDt3: ∀n3∈ℕ, δt3^{n3=0}=option_δt_ini3;, δt3^{n3+1}=option_δt_cfl3*reduceMin{j3∈cells3()}(δtj3{j3});
ComputeTn3: ∀n3∈ℕ, t3^{n3=0}=0.0; , t3^{n3+1}=t3^{n3}+δt3^{n3+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter4: ∀j4∈cells4(), center4{j4} = (1.0/4.0) * ∑{r4∈nodesOfCell4(j4)}(coord4{r4});
IniIc4: ∀j4∈cells4(), if (center4{j4}.x < option_x_interface4) {
  ρ_ic4{j4}=option_ρ_ini_zg4;
  p_ic4{j4}=option_p_ini_zg4;
} else {
  ρ_ic4{j4}=option_ρ_ini_zd4;
  p_ic4{j4}=option_p_ini_zd4;
}

ComputeCjrIc4: ∀j4∈cells4(), ∀r4∈nodesOfCell4(j4), 
	C_ic4{j4,r4} = 0.5 * perp4(coord4{►(r4)} - coord4{◄(r4)});
IniVIc4: ∀j4∈cells4(), V_ic4{j4} = 0.5 * ∑{r4∈nodesOfCell4(j4)}(dot(C_ic4{j4,r4}, coord4{r4}));
IniM4: ∀j4∈cells4(), m4{j4} = ρ_ic4{j4} * V_ic4{j4}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr4: ∀j4∈cells4(), ∀r4∈nodesOfCell4(j4), C4{j4,r4} = 0.5 * perp4(X4{►(r4)} - X4{◄(r4)});
ComputeLjr4: ∀j4∈cells4(), ∀r4∈nodesOfCell4(j4), l4{j4,r4} = norm(C4{j4,r4});
Computeδtj4: ∀j4∈cells4(), δtj4{j4} = 2.0 * V4{j4} / (c4{j4} * ∑{r4∈nodesOfCell4(j4)}(l4{j4,r4}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity4: ∀j4∈cells4(), ρ4{j4} = m4{j4} / V4{j4};
ComputeEOSp4: ∀j4∈cells4(), p4{j4} = (γ4-1.0) * ρ4{j4} * e4{j4};
ComputeInternalEngergy4: ∀j4∈cells4(), e4{j4} = E4{j4} - 0.5 * dot(uj4{j4}, uj4{j4});
ComputeEOSc4: ∀j4∈cells4(), c4{j4} = √(γ4*p4{j4}/ρ4{j4}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr4: ∀j4∈cells4(), ∀r4∈nodesOfCell4(j4), Ajr4{j4,r4} = ((ρ4{j4}*c4{j4})/l4{j4,r4}) * tensProduct4(C4{j4,r4}, C4{j4,r4});
ComputeFjr4: ∀j4∈cells4(), ∀r4∈nodesOfCell4(j4), F4{j4,r4} = p4{j4}*C4{j4,r4} + matVectProduct4(Ajr4{j4,r4}, (uj4{j4}-ur4{r4}));
ComputeAr4: ∀r4∈nodes4(), Ar4{r4} = ∑{j4∈cellsOfNode4(r4)}(Ajr4{j4,r4});
ComputeBr4: ∀r4∈nodes4(), b4{r4} = ∑{j4∈cellsOfNode4(r4)}(p4{j4}*C4{j4,r4} + matVectProduct4(Ajr4{j4,r4}, uj4{j4}));
ComputeMt4: ∀r4∈innerNodes4(), Mt4{r4} = Ar4{r4};
ComputeBt4: ∀r4∈innerNodes4(), bt4{r4} = b4{r4};

OuterFacesComputations4: ∀k4∈outerFaces4(), {
	const ℝ epsilon4 = 1.0e-10;
	ℝ²ˣ² I4 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN4 = 0.0;
	ℝ X_MAX4 = X_EDGE_ELEMS4 * LENGTH4;
	ℝ Y_MIN4 = 0.0; 
	ℝ Y_MAX4 = Y_EDGE_ELEMS4 * LENGTH4;
	ℝ² nY4 = {0.0,1.0};
	
	∀r4∈nodesOfFace4(k4), {
		// Y boundary conditions (must be done before X)
		if ((X4{r4}.y-Y_MIN4 < epsilon4) || (X4{r4}.y-Y_MAX4 < epsilon4)) {
			ℝ sign4 = 0.0;
			if (X4{r4}.y-Y_MIN4 < epsilon4) sign4 = -1.0;
			else sign4 = 1.0;
			ℝ² n4 = sign4 * nY4;
      		ℝ²ˣ² nxn4 = tensProduct4(n4,n4);
      		ℝ²ˣ² IcP4 = I4 - nxn4;
			bt1{r4} = matVectProduct4(IcP4, b4{r4});
			Mt1{r4} = IcP4 * (Ar4{r4} * IcP4) + nxn4*trace4(Ar4{r4});
		}

		// X boundary conditions
		if ((Math.fabs(X4{r4}.x-X_MIN4) < epsilon4) || ( (Math.fabs(X4{r4}.x-X_MAX4) < epsilon4) )) {
			Mt4{r4} = I4;
			bt4{r4} = {0.0, 0.0};
		}
	}
}


ComputeU4: ∀r4∈nodes4(), ur4{r4} = matVectProduct4(inverse4(Mt4{r4}), bt4{r4});
ComputeV4: ∀j4∈cells4(), V4{j4} = 0.5 * ∑{r4∈nodesOfCell4(j4)}(dot(C4{j4,r4},X4{r4}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn4: ∀n4∈ℕ, ∀r04∈nodes4(), X4{r04}^{n4=0}=coord4{r04}; , ∀r4∈nodes4(), X4{r4}^{n4+1}=X4{r4}^{n4}+δt4^{n4}*ur4{r4};
ComputeUn4: ∀n4∈ℕ, ∀j04∈cells4(), uj4{j04}^{n4=0}={0.0,0.0}; , ∀j4∈cells4(), uj4{j4}^{n4+1}=uj4{j4}^{n4}-(δt4^{n4}/m4{j4})*∑{r4∈nodesOfCell4(j4)}(F4{j4,r4});
ComputeEn4: ∀n4∈ℕ, ∀j04∈cells4(), E4{j04}^{n4=0}=p_ic4{j04}/((γ4-1.0)*ρ_ic4{j04}); , ∀j4∈cells4(), E4{j4}^{n4+1}=E4{j4}^{n4} - (δt4^{n4} / m4{j4}) * ∑{r4∈nodesOfCell4(j4)}(dot(F4{j4,r4},ur4{r4}));
ComputeDt4: ∀n4∈ℕ, δt4^{n4=0}=option_δt_ini4;, δt4^{n4+1}=option_δt_cfl4*reduceMin{j4∈cells4()}(δtj4{j4});
ComputeTn4: ∀n4∈ℕ, t4^{n4=0}=0.0; , t4^{n4+1}=t4^{n4}+δt4^{n4+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter5: ∀j5∈cells5(), center5{j5} = (1.0/4.0) * ∑{r5∈nodesOfCell5(j5)}(coord5{r5});
IniIc5: ∀j5∈cells5(), if (center5{j5}.x < option_x_interface5) {
  ρ_ic5{j5}=option_ρ_ini_zg5;
  p_ic5{j5}=option_p_ini_zg5;
} else {
  ρ_ic5{j5}=option_ρ_ini_zd5;
  p_ic5{j5}=option_p_ini_zd5;
}

ComputeCjrIc5: ∀j5∈cells5(), ∀r5∈nodesOfCell5(j5), 
	C_ic5{j5,r5} = 0.5 * perp5(coord5{►(r5)} - coord5{◄(r5)});
IniVIc5: ∀j5∈cells5(), V_ic5{j5} = 0.5 * ∑{r5∈nodesOfCell5(j5)}(dot(C_ic5{j5,r5}, coord5{r5}));
IniM5: ∀j5∈cells5(), m5{j5} = ρ_ic5{j5} * V_ic5{j5}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr5: ∀j5∈cells5(), ∀r5∈nodesOfCell5(j5), C5{j5,r5} = 0.5 * perp5(X5{►(r5)} - X5{◄(r5)});
ComputeLjr5: ∀j5∈cells5(), ∀r5∈nodesOfCell5(j5), l5{j5,r5} = norm(C5{j5,r5});
Computeδtj5: ∀j5∈cells5(), δtj5{j5} = 2.0 * V5{j5} / (c5{j5} * ∑{r5∈nodesOfCell5(j5)}(l5{j5,r5}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity5: ∀j5∈cells5(), ρ5{j5} = m5{j5} / V5{j5};
ComputeEOSp5: ∀j5∈cells5(), p5{j5} = (γ5-1.0) * ρ5{j5} * e5{j5};
ComputeInternalEngergy5: ∀j5∈cells5(), e5{j5} = E5{j5} - 0.5 * dot(uj5{j5}, uj5{j5});
ComputeEOSc5: ∀j5∈cells5(), c5{j5} = √(γ5*p5{j5}/ρ5{j5}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr5: ∀j5∈cells5(), ∀r5∈nodesOfCell5(j5), Ajr5{j5,r5} = ((ρ5{j5}*c5{j5})/l5{j5,r5}) * tensProduct5(C5{j5,r5}, C5{j5,r5});
ComputeFjr5: ∀j5∈cells5(), ∀r5∈nodesOfCell5(j5), F5{j5,r5} = p5{j5}*C5{j5,r5} + matVectProduct5(Ajr5{j5,r5}, (uj5{j5}-ur5{r5}));
ComputeAr5: ∀r5∈nodes5(), Ar5{r5} = ∑{j5∈cellsOfNode5(r5)}(Ajr5{j5,r5});
ComputeBr5: ∀r5∈nodes5(), b5{r5} = ∑{j5∈cellsOfNode5(r5)}(p5{j5}*C5{j5,r5} + matVectProduct5(Ajr5{j5,r5}, uj5{j5}));
ComputeMt5: ∀r5∈innerNodes5(), Mt5{r5} = Ar5{r5};
ComputeBt5: ∀r5∈innerNodes5(), bt5{r5} = b5{r5};

OuterFacesComputations5: ∀k5∈outerFaces5(), {
	const ℝ epsilon5 = 1.0e-10;
	ℝ²ˣ² I5 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN5 = 0.0;
	ℝ X_MAX5 = X_EDGE_ELEMS5 * LENGTH5;
	ℝ Y_MIN5 = 0.0; 
	ℝ Y_MAX5 = Y_EDGE_ELEMS5 * LENGTH5;
	ℝ² nY5 = {0.0,1.0};
	
	∀r5∈nodesOfFace5(k5), {
		// Y boundary conditions (must be done before X)
		if ((X5{r5}.y-Y_MIN5 < epsilon5) || (X5{r5}.y-Y_MAX5 < epsilon5)) {
			ℝ sign5 = 0.0;
			if (X5{r5}.y-Y_MIN5 < epsilon5) sign5 = -1.0;
			else sign5 = 1.0;
			ℝ² n5 = sign5 * nY5;
      		ℝ²ˣ² nxn5 = tensProduct5(n5,n5);
      		ℝ²ˣ² IcP5 = I5 - nxn5;
			bt1{r5} = matVectProduct5(IcP5, b5{r5});
			Mt1{r5} = IcP5 * (Ar5{r5} * IcP5) + nxn5*trace5(Ar5{r5});
		}

		// X boundary conditions
		if ((Math.fabs(X5{r5}.x-X_MIN5) < epsilon5) || ( (Math.fabs(X5{r5}.x-X_MAX5) < epsilon5) )) {
			Mt5{r5} = I5;
			bt5{r5} = {0.0, 0.0};
		}
	}
}


ComputeU5: ∀r5∈nodes5(), ur5{r5} = matVectProduct5(inverse5(Mt5{r5}), bt5{r5});
ComputeV5: ∀j5∈cells5(), V5{j5} = 0.5 * ∑{r5∈nodesOfCell5(j5)}(dot(C5{j5,r5},X5{r5}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn5: ∀n5∈ℕ, ∀r05∈nodes5(), X5{r05}^{n5=0}=coord5{r05}; , ∀r5∈nodes5(), X5{r5}^{n5+1}=X5{r5}^{n5}+δt5^{n5}*ur5{r5};
ComputeUn5: ∀n5∈ℕ, ∀j05∈cells5(), uj5{j05}^{n5=0}={0.0,0.0}; , ∀j5∈cells5(), uj5{j5}^{n5+1}=uj5{j5}^{n5}-(δt5^{n5}/m5{j5})*∑{r5∈nodesOfCell5(j5)}(F5{j5,r5});
ComputeEn5: ∀n5∈ℕ, ∀j05∈cells5(), E5{j05}^{n5=0}=p_ic5{j05}/((γ5-1.0)*ρ_ic5{j05}); , ∀j5∈cells5(), E5{j5}^{n5+1}=E5{j5}^{n5} - (δt5^{n5} / m5{j5}) * ∑{r5∈nodesOfCell5(j5)}(dot(F5{j5,r5},ur5{r5}));
ComputeDt5: ∀n5∈ℕ, δt5^{n5=0}=option_δt_ini5;, δt5^{n5+1}=option_δt_cfl5*reduceMin{j5∈cells5()}(δtj5{j5});
ComputeTn5: ∀n5∈ℕ, t5^{n5=0}=0.0; , t5^{n5+1}=t5^{n5}+δt5^{n5+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter6: ∀j6∈cells6(), center6{j6} = (1.0/4.0) * ∑{r6∈nodesOfCell6(j6)}(coord6{r6});
IniIc6: ∀j6∈cells6(), if (center6{j6}.x < option_x_interface6) {
  ρ_ic6{j6}=option_ρ_ini_zg6;
  p_ic6{j6}=option_p_ini_zg6;
} else {
  ρ_ic6{j6}=option_ρ_ini_zd6;
  p_ic6{j6}=option_p_ini_zd6;
}

ComputeCjrIc6: ∀j6∈cells6(), ∀r6∈nodesOfCell6(j6), 
	C_ic6{j6,r6} = 0.5 * perp6(coord6{►(r6)} - coord6{◄(r6)});
IniVIc6: ∀j6∈cells6(), V_ic6{j6} = 0.5 * ∑{r6∈nodesOfCell6(j6)}(dot(C_ic6{j6,r6}, coord6{r6}));
IniM6: ∀j6∈cells6(), m6{j6} = ρ_ic6{j6} * V_ic6{j6}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr6: ∀j6∈cells6(), ∀r6∈nodesOfCell6(j6), C6{j6,r6} = 0.5 * perp6(X6{►(r6)} - X6{◄(r6)});
ComputeLjr6: ∀j6∈cells6(), ∀r6∈nodesOfCell6(j6), l6{j6,r6} = norm(C6{j6,r6});
Computeδtj6: ∀j6∈cells6(), δtj6{j6} = 2.0 * V6{j6} / (c6{j6} * ∑{r6∈nodesOfCell6(j6)}(l6{j6,r6}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity6: ∀j6∈cells6(), ρ6{j6} = m6{j6} / V6{j6};
ComputeEOSp6: ∀j6∈cells6(), p6{j6} = (γ6-1.0) * ρ6{j6} * e6{j6};
ComputeInternalEngergy6: ∀j6∈cells6(), e6{j6} = E6{j6} - 0.5 * dot(uj6{j6}, uj6{j6});
ComputeEOSc6: ∀j6∈cells6(), c6{j6} = √(γ6*p6{j6}/ρ6{j6}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr6: ∀j6∈cells6(), ∀r6∈nodesOfCell6(j6), Ajr6{j6,r6} = ((ρ6{j6}*c6{j6})/l6{j6,r6}) * tensProduct6(C6{j6,r6}, C6{j6,r6});
ComputeFjr6: ∀j6∈cells6(), ∀r6∈nodesOfCell6(j6), F6{j6,r6} = p6{j6}*C6{j6,r6} + matVectProduct6(Ajr6{j6,r6}, (uj6{j6}-ur6{r6}));
ComputeAr6: ∀r6∈nodes6(), Ar6{r6} = ∑{j6∈cellsOfNode6(r6)}(Ajr6{j6,r6});
ComputeBr6: ∀r6∈nodes6(), b6{r6} = ∑{j6∈cellsOfNode6(r6)}(p6{j6}*C6{j6,r6} + matVectProduct6(Ajr6{j6,r6}, uj6{j6}));
ComputeMt6: ∀r6∈innerNodes6(), Mt6{r6} = Ar6{r6};
ComputeBt6: ∀r6∈innerNodes6(), bt6{r6} = b6{r6};

OuterFacesComputations6: ∀k6∈outerFaces6(), {
	const ℝ epsilon6 = 1.0e-10;
	ℝ²ˣ² I6 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN6 = 0.0;
	ℝ X_MAX6 = X_EDGE_ELEMS6 * LENGTH6;
	ℝ Y_MIN6 = 0.0; 
	ℝ Y_MAX6 = Y_EDGE_ELEMS6 * LENGTH6;
	ℝ² nY6 = {0.0,1.0};
	
	∀r6∈nodesOfFace6(k6), {
		// Y boundary conditions (must be done before X)
		if ((X6{r6}.y-Y_MIN6 < epsilon6) || (X6{r6}.y-Y_MAX6 < epsilon6)) {
			ℝ sign6 = 0.0;
			if (X6{r6}.y-Y_MIN6 < epsilon6) sign6 = -1.0;
			else sign6 = 1.0;
			ℝ² n6 = sign6 * nY6;
      		ℝ²ˣ² nxn6 = tensProduct6(n6,n6);
      		ℝ²ˣ² IcP6 = I6 - nxn6;
			bt1{r6} = matVectProduct6(IcP6, b6{r6});
			Mt1{r6} = IcP6 * (Ar6{r6} * IcP6) + nxn6*trace6(Ar6{r6});
		}

		// X boundary conditions
		if ((Math.fabs(X6{r6}.x-X_MIN6) < epsilon6) || ( (Math.fabs(X6{r6}.x-X_MAX6) < epsilon6) )) {
			Mt6{r6} = I6;
			bt6{r6} = {0.0, 0.0};
		}
	}
}


ComputeU6: ∀r6∈nodes6(), ur6{r6} = matVectProduct6(inverse6(Mt6{r6}), bt6{r6});
ComputeV6: ∀j6∈cells6(), V6{j6} = 0.5 * ∑{r6∈nodesOfCell6(j6)}(dot(C6{j6,r6},X6{r6}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn6: ∀n6∈ℕ, ∀r06∈nodes6(), X6{r06}^{n6=0}=coord6{r06}; , ∀r6∈nodes6(), X6{r6}^{n6+1}=X6{r6}^{n6}+δt6^{n6}*ur6{r6};
ComputeUn6: ∀n6∈ℕ, ∀j06∈cells6(), uj6{j06}^{n6=0}={0.0,0.0}; , ∀j6∈cells6(), uj6{j6}^{n6+1}=uj6{j6}^{n6}-(δt6^{n6}/m6{j6})*∑{r6∈nodesOfCell6(j6)}(F6{j6,r6});
ComputeEn6: ∀n6∈ℕ, ∀j06∈cells6(), E6{j06}^{n6=0}=p_ic6{j06}/((γ6-1.0)*ρ_ic6{j06}); , ∀j6∈cells6(), E6{j6}^{n6+1}=E6{j6}^{n6} - (δt6^{n6} / m6{j6}) * ∑{r6∈nodesOfCell6(j6)}(dot(F6{j6,r6},ur6{r6}));
ComputeDt6: ∀n6∈ℕ, δt6^{n6=0}=option_δt_ini6;, δt6^{n6+1}=option_δt_cfl6*reduceMin{j6∈cells6()}(δtj6{j6});
ComputeTn6: ∀n6∈ℕ, t6^{n6=0}=0.0; , t6^{n6+1}=t6^{n6}+δt6^{n6+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter7: ∀j7∈cells7(), center7{j7} = (1.0/4.0) * ∑{r7∈nodesOfCell7(j7)}(coord7{r7});
IniIc7: ∀j7∈cells7(), if (center7{j7}.x < option_x_interface7) {
  ρ_ic7{j7}=option_ρ_ini_zg7;
  p_ic7{j7}=option_p_ini_zg7;
} else {
  ρ_ic7{j7}=option_ρ_ini_zd7;
  p_ic7{j7}=option_p_ini_zd7;
}

ComputeCjrIc7: ∀j7∈cells7(), ∀r7∈nodesOfCell7(j7), 
	C_ic7{j7,r7} = 0.5 * perp7(coord7{►(r7)} - coord7{◄(r7)});
IniVIc7: ∀j7∈cells7(), V_ic7{j7} = 0.5 * ∑{r7∈nodesOfCell7(j7)}(dot(C_ic7{j7,r7}, coord7{r7}));
IniM7: ∀j7∈cells7(), m7{j7} = ρ_ic7{j7} * V_ic7{j7}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr7: ∀j7∈cells7(), ∀r7∈nodesOfCell7(j7), C7{j7,r7} = 0.5 * perp7(X7{►(r7)} - X7{◄(r7)});
ComputeLjr7: ∀j7∈cells7(), ∀r7∈nodesOfCell7(j7), l7{j7,r7} = norm(C7{j7,r7});
Computeδtj7: ∀j7∈cells7(), δtj7{j7} = 2.0 * V7{j7} / (c7{j7} * ∑{r7∈nodesOfCell7(j7)}(l7{j7,r7}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity7: ∀j7∈cells7(), ρ7{j7} = m7{j7} / V7{j7};
ComputeEOSp7: ∀j7∈cells7(), p7{j7} = (γ7-1.0) * ρ7{j7} * e7{j7};
ComputeInternalEngergy7: ∀j7∈cells7(), e7{j7} = E7{j7} - 0.5 * dot(uj7{j7}, uj7{j7});
ComputeEOSc7: ∀j7∈cells7(), c7{j7} = √(γ7*p7{j7}/ρ7{j7}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr7: ∀j7∈cells7(), ∀r7∈nodesOfCell7(j7), Ajr7{j7,r7} = ((ρ7{j7}*c7{j7})/l7{j7,r7}) * tensProduct7(C7{j7,r7}, C7{j7,r7});
ComputeFjr7: ∀j7∈cells7(), ∀r7∈nodesOfCell7(j7), F7{j7,r7} = p7{j7}*C7{j7,r7} + matVectProduct7(Ajr7{j7,r7}, (uj7{j7}-ur7{r7}));
ComputeAr7: ∀r7∈nodes7(), Ar7{r7} = ∑{j7∈cellsOfNode7(r7)}(Ajr7{j7,r7});
ComputeBr7: ∀r7∈nodes7(), b7{r7} = ∑{j7∈cellsOfNode7(r7)}(p7{j7}*C7{j7,r7} + matVectProduct7(Ajr7{j7,r7}, uj7{j7}));
ComputeMt7: ∀r7∈innerNodes7(), Mt7{r7} = Ar7{r7};
ComputeBt7: ∀r7∈innerNodes7(), bt7{r7} = b7{r7};

OuterFacesComputations7: ∀k7∈outerFaces7(), {
	const ℝ epsilon7 = 1.0e-10;
	ℝ²ˣ² I7 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN7 = 0.0;
	ℝ X_MAX7 = X_EDGE_ELEMS7 * LENGTH7;
	ℝ Y_MIN7 = 0.0; 
	ℝ Y_MAX7 = Y_EDGE_ELEMS7 * LENGTH7;
	ℝ² nY7 = {0.0,1.0};
	
	∀r7∈nodesOfFace7(k7), {
		// Y boundary conditions (must be done before X)
		if ((X7{r7}.y-Y_MIN7 < epsilon7) || (X7{r7}.y-Y_MAX7 < epsilon7)) {
			ℝ sign7 = 0.0;
			if (X7{r7}.y-Y_MIN7 < epsilon7) sign7 = -1.0;
			else sign7 = 1.0;
			ℝ² n7 = sign7 * nY7;
      		ℝ²ˣ² nxn7 = tensProduct7(n7,n7);
      		ℝ²ˣ² IcP7 = I7 - nxn7;
			bt1{r7} = matVectProduct7(IcP7, b7{r7});
			Mt1{r7} = IcP7 * (Ar7{r7} * IcP7) + nxn7*trace7(Ar7{r7});
		}

		// X boundary conditions
		if ((Math.fabs(X7{r7}.x-X_MIN7) < epsilon7) || ( (Math.fabs(X7{r7}.x-X_MAX7) < epsilon7) )) {
			Mt7{r7} = I7;
			bt7{r7} = {0.0, 0.0};
		}
	}
}


ComputeU7: ∀r7∈nodes7(), ur7{r7} = matVectProduct7(inverse7(Mt7{r7}), bt7{r7});
ComputeV7: ∀j7∈cells7(), V7{j7} = 0.5 * ∑{r7∈nodesOfCell7(j7)}(dot(C7{j7,r7},X7{r7}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn7: ∀n7∈ℕ, ∀r07∈nodes7(), X7{r07}^{n7=0}=coord7{r07}; , ∀r7∈nodes7(), X7{r7}^{n7+1}=X7{r7}^{n7}+δt7^{n7}*ur7{r7};
ComputeUn7: ∀n7∈ℕ, ∀j07∈cells7(), uj7{j07}^{n7=0}={0.0,0.0}; , ∀j7∈cells7(), uj7{j7}^{n7+1}=uj7{j7}^{n7}-(δt7^{n7}/m7{j7})*∑{r7∈nodesOfCell7(j7)}(F7{j7,r7});
ComputeEn7: ∀n7∈ℕ, ∀j07∈cells7(), E7{j07}^{n7=0}=p_ic7{j07}/((γ7-1.0)*ρ_ic7{j07}); , ∀j7∈cells7(), E7{j7}^{n7+1}=E7{j7}^{n7} - (δt7^{n7} / m7{j7}) * ∑{r7∈nodesOfCell7(j7)}(dot(F7{j7,r7},ur7{r7}));
ComputeDt7: ∀n7∈ℕ, δt7^{n7=0}=option_δt_ini7;, δt7^{n7+1}=option_δt_cfl7*reduceMin{j7∈cells7()}(δtj7{j7});
ComputeTn7: ∀n7∈ℕ, t7^{n7=0}=0.0; , t7^{n7+1}=t7^{n7}+δt7^{n7+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter8: ∀j8∈cells8(), center8{j8} = (1.0/4.0) * ∑{r8∈nodesOfCell8(j8)}(coord8{r8});
IniIc8: ∀j8∈cells8(), if (center8{j8}.x < option_x_interface8) {
  ρ_ic8{j8}=option_ρ_ini_zg8;
  p_ic8{j8}=option_p_ini_zg8;
} else {
  ρ_ic8{j8}=option_ρ_ini_zd8;
  p_ic8{j8}=option_p_ini_zd8;
}

ComputeCjrIc8: ∀j8∈cells8(), ∀r8∈nodesOfCell8(j8), 
	C_ic8{j8,r8} = 0.5 * perp8(coord8{►(r8)} - coord8{◄(r8)});
IniVIc8: ∀j8∈cells8(), V_ic8{j8} = 0.5 * ∑{r8∈nodesOfCell8(j8)}(dot(C_ic8{j8,r8}, coord8{r8}));
IniM8: ∀j8∈cells8(), m8{j8} = ρ_ic8{j8} * V_ic8{j8}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr8: ∀j8∈cells8(), ∀r8∈nodesOfCell8(j8), C8{j8,r8} = 0.5 * perp8(X8{►(r8)} - X8{◄(r8)});
ComputeLjr8: ∀j8∈cells8(), ∀r8∈nodesOfCell8(j8), l8{j8,r8} = norm(C8{j8,r8});
Computeδtj8: ∀j8∈cells8(), δtj8{j8} = 2.0 * V8{j8} / (c8{j8} * ∑{r8∈nodesOfCell8(j8)}(l8{j8,r8}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity8: ∀j8∈cells8(), ρ8{j8} = m8{j8} / V8{j8};
ComputeEOSp8: ∀j8∈cells8(), p8{j8} = (γ8-1.0) * ρ8{j8} * e8{j8};
ComputeInternalEngergy8: ∀j8∈cells8(), e8{j8} = E8{j8} - 0.5 * dot(uj8{j8}, uj8{j8});
ComputeEOSc8: ∀j8∈cells8(), c8{j8} = √(γ8*p8{j8}/ρ8{j8}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr8: ∀j8∈cells8(), ∀r8∈nodesOfCell8(j8), Ajr8{j8,r8} = ((ρ8{j8}*c8{j8})/l8{j8,r8}) * tensProduct8(C8{j8,r8}, C8{j8,r8});
ComputeFjr8: ∀j8∈cells8(), ∀r8∈nodesOfCell8(j8), F8{j8,r8} = p8{j8}*C8{j8,r8} + matVectProduct8(Ajr8{j8,r8}, (uj8{j8}-ur8{r8}));
ComputeAr8: ∀r8∈nodes8(), Ar8{r8} = ∑{j8∈cellsOfNode8(r8)}(Ajr8{j8,r8});
ComputeBr8: ∀r8∈nodes8(), b8{r8} = ∑{j8∈cellsOfNode8(r8)}(p8{j8}*C8{j8,r8} + matVectProduct8(Ajr8{j8,r8}, uj8{j8}));
ComputeMt8: ∀r8∈innerNodes8(), Mt8{r8} = Ar8{r8};
ComputeBt8: ∀r8∈innerNodes8(), bt8{r8} = b8{r8};

OuterFacesComputations8: ∀k8∈outerFaces8(), {
	const ℝ epsilon8 = 1.0e-10;
	ℝ²ˣ² I8 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN8 = 0.0;
	ℝ X_MAX8 = X_EDGE_ELEMS8 * LENGTH8;
	ℝ Y_MIN8 = 0.0; 
	ℝ Y_MAX8 = Y_EDGE_ELEMS8 * LENGTH8;
	ℝ² nY8 = {0.0,1.0};
	
	∀r8∈nodesOfFace8(k8), {
		// Y boundary conditions (must be done before X)
		if ((X8{r8}.y-Y_MIN8 < epsilon8) || (X8{r8}.y-Y_MAX8 < epsilon8)) {
			ℝ sign8 = 0.0;
			if (X8{r8}.y-Y_MIN8 < epsilon8) sign8 = -1.0;
			else sign8 = 1.0;
			ℝ² n8 = sign8 * nY8;
      		ℝ²ˣ² nxn8 = tensProduct8(n8,n8);
      		ℝ²ˣ² IcP8 = I8 - nxn8;
			bt1{r8} = matVectProduct8(IcP8, b8{r8});
			Mt1{r8} = IcP8 * (Ar8{r8} * IcP8) + nxn8*trace8(Ar8{r8});
		}

		// X boundary conditions
		if ((Math.fabs(X8{r8}.x-X_MIN8) < epsilon8) || ( (Math.fabs(X8{r8}.x-X_MAX8) < epsilon8) )) {
			Mt8{r8} = I8;
			bt8{r8} = {0.0, 0.0};
		}
	}
}


ComputeU8: ∀r8∈nodes8(), ur8{r8} = matVectProduct8(inverse8(Mt8{r8}), bt8{r8});
ComputeV8: ∀j8∈cells8(), V8{j8} = 0.5 * ∑{r8∈nodesOfCell8(j8)}(dot(C8{j8,r8},X8{r8}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn8: ∀n8∈ℕ, ∀r08∈nodes8(), X8{r08}^{n8=0}=coord8{r08}; , ∀r8∈nodes8(), X8{r8}^{n8+1}=X8{r8}^{n8}+δt8^{n8}*ur8{r8};
ComputeUn8: ∀n8∈ℕ, ∀j08∈cells8(), uj8{j08}^{n8=0}={0.0,0.0}; , ∀j8∈cells8(), uj8{j8}^{n8+1}=uj8{j8}^{n8}-(δt8^{n8}/m8{j8})*∑{r8∈nodesOfCell8(j8)}(F8{j8,r8});
ComputeEn8: ∀n8∈ℕ, ∀j08∈cells8(), E8{j08}^{n8=0}=p_ic8{j08}/((γ8-1.0)*ρ_ic8{j08}); , ∀j8∈cells8(), E8{j8}^{n8+1}=E8{j8}^{n8} - (δt8^{n8} / m8{j8}) * ∑{r8∈nodesOfCell8(j8)}(dot(F8{j8,r8},ur8{r8}));
ComputeDt8: ∀n8∈ℕ, δt8^{n8=0}=option_δt_ini8;, δt8^{n8+1}=option_δt_cfl8*reduceMin{j8∈cells8()}(δtj8{j8});
ComputeTn8: ∀n8∈ℕ, t8^{n8=0}=0.0; , t8^{n8+1}=t8^{n8}+δt8^{n8+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter9: ∀j9∈cells9(), center9{j9} = (1.0/4.0) * ∑{r9∈nodesOfCell9(j9)}(coord9{r9});
IniIc9: ∀j9∈cells9(), if (center9{j9}.x < option_x_interface9) {
  ρ_ic9{j9}=option_ρ_ini_zg9;
  p_ic9{j9}=option_p_ini_zg9;
} else {
  ρ_ic9{j9}=option_ρ_ini_zd9;
  p_ic9{j9}=option_p_ini_zd9;
}

ComputeCjrIc9: ∀j9∈cells9(), ∀r9∈nodesOfCell9(j9), 
	C_ic9{j9,r9} = 0.5 * perp9(coord9{►(r9)} - coord9{◄(r9)});
IniVIc9: ∀j9∈cells9(), V_ic9{j9} = 0.5 * ∑{r9∈nodesOfCell9(j9)}(dot(C_ic9{j9,r9}, coord9{r9}));
IniM9: ∀j9∈cells9(), m9{j9} = ρ_ic9{j9} * V_ic9{j9}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr9: ∀j9∈cells9(), ∀r9∈nodesOfCell9(j9), C9{j9,r9} = 0.5 * perp9(X9{►(r9)} - X9{◄(r9)});
ComputeLjr9: ∀j9∈cells9(), ∀r9∈nodesOfCell9(j9), l9{j9,r9} = norm(C9{j9,r9});
Computeδtj9: ∀j9∈cells9(), δtj9{j9} = 2.0 * V9{j9} / (c9{j9} * ∑{r9∈nodesOfCell9(j9)}(l9{j9,r9}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity9: ∀j9∈cells9(), ρ9{j9} = m9{j9} / V9{j9};
ComputeEOSp9: ∀j9∈cells9(), p9{j9} = (γ9-1.0) * ρ9{j9} * e9{j9};
ComputeInternalEngergy9: ∀j9∈cells9(), e9{j9} = E9{j9} - 0.5 * dot(uj9{j9}, uj9{j9});
ComputeEOSc9: ∀j9∈cells9(), c9{j9} = √(γ9*p9{j9}/ρ9{j9}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr9: ∀j9∈cells9(), ∀r9∈nodesOfCell9(j9), Ajr9{j9,r9} = ((ρ9{j9}*c9{j9})/l9{j9,r9}) * tensProduct9(C9{j9,r9}, C9{j9,r9});
ComputeFjr9: ∀j9∈cells9(), ∀r9∈nodesOfCell9(j9), F9{j9,r9} = p9{j9}*C9{j9,r9} + matVectProduct9(Ajr9{j9,r9}, (uj9{j9}-ur9{r9}));
ComputeAr9: ∀r9∈nodes9(), Ar9{r9} = ∑{j9∈cellsOfNode9(r9)}(Ajr9{j9,r9});
ComputeBr9: ∀r9∈nodes9(), b9{r9} = ∑{j9∈cellsOfNode9(r9)}(p9{j9}*C9{j9,r9} + matVectProduct9(Ajr9{j9,r9}, uj9{j9}));
ComputeMt9: ∀r9∈innerNodes9(), Mt9{r9} = Ar9{r9};
ComputeBt9: ∀r9∈innerNodes9(), bt9{r9} = b9{r9};

OuterFacesComputations9: ∀k9∈outerFaces9(), {
	const ℝ epsilon9 = 1.0e-10;
	ℝ²ˣ² I9 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN9 = 0.0;
	ℝ X_MAX9 = X_EDGE_ELEMS9 * LENGTH9;
	ℝ Y_MIN9 = 0.0; 
	ℝ Y_MAX9 = Y_EDGE_ELEMS9 * LENGTH9;
	ℝ² nY9 = {0.0,1.0};
	
	∀r9∈nodesOfFace9(k9), {
		// Y boundary conditions (must be done before X)
		if ((X9{r9}.y-Y_MIN9 < epsilon9) || (X9{r9}.y-Y_MAX9 < epsilon9)) {
			ℝ sign9 = 0.0;
			if (X9{r9}.y-Y_MIN9 < epsilon9) sign9 = -1.0;
			else sign9 = 1.0;
			ℝ² n9 = sign9 * nY9;
      		ℝ²ˣ² nxn9 = tensProduct9(n9,n9);
      		ℝ²ˣ² IcP9 = I9 - nxn9;
			bt1{r9} = matVectProduct9(IcP9, b9{r9});
			Mt1{r9} = IcP9 * (Ar9{r9} * IcP9) + nxn9*trace9(Ar9{r9});
		}

		// X boundary conditions
		if ((Math.fabs(X9{r9}.x-X_MIN9) < epsilon9) || ( (Math.fabs(X9{r9}.x-X_MAX9) < epsilon9) )) {
			Mt9{r9} = I9;
			bt9{r9} = {0.0, 0.0};
		}
	}
}


ComputeU9: ∀r9∈nodes9(), ur9{r9} = matVectProduct9(inverse9(Mt9{r9}), bt9{r9});
ComputeV9: ∀j9∈cells9(), V9{j9} = 0.5 * ∑{r9∈nodesOfCell9(j9)}(dot(C9{j9,r9},X9{r9}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn9: ∀n9∈ℕ, ∀r09∈nodes9(), X9{r09}^{n9=0}=coord9{r09}; , ∀r9∈nodes9(), X9{r9}^{n9+1}=X9{r9}^{n9}+δt9^{n9}*ur9{r9};
ComputeUn9: ∀n9∈ℕ, ∀j09∈cells9(), uj9{j09}^{n9=0}={0.0,0.0}; , ∀j9∈cells9(), uj9{j9}^{n9+1}=uj9{j9}^{n9}-(δt9^{n9}/m9{j9})*∑{r9∈nodesOfCell9(j9)}(F9{j9,r9});
ComputeEn9: ∀n9∈ℕ, ∀j09∈cells9(), E9{j09}^{n9=0}=p_ic9{j09}/((γ9-1.0)*ρ_ic9{j09}); , ∀j9∈cells9(), E9{j9}^{n9+1}=E9{j9}^{n9} - (δt9^{n9} / m9{j9}) * ∑{r9∈nodesOfCell9(j9)}(dot(F9{j9,r9},ur9{r9}));
ComputeDt9: ∀n9∈ℕ, δt9^{n9=0}=option_δt_ini9;, δt9^{n9+1}=option_δt_cfl9*reduceMin{j9∈cells9()}(δtj9{j9});
ComputeTn9: ∀n9∈ℕ, t9^{n9=0}=0.0; , t9^{n9+1}=t9^{n9}+δt9^{n9+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter10: ∀j10∈cells10(), center10{j10} = (1.0/4.0) * ∑{r10∈nodesOfCell10(j10)}(coord10{r10});
IniIc10: ∀j10∈cells10(), if (center10{j10}.x < option_x_interface10) {
  ρ_ic10{j10}=option_ρ_ini_zg10;
  p_ic10{j10}=option_p_ini_zg10;
} else {
  ρ_ic10{j10}=option_ρ_ini_zd10;
  p_ic10{j10}=option_p_ini_zd10;
}

ComputeCjrIc10: ∀j10∈cells10(), ∀r10∈nodesOfCell10(j10), 
	C_ic10{j10,r10} = 0.5 * perp10(coord10{►(r10)} - coord10{◄(r10)});
IniVIc10: ∀j10∈cells10(), V_ic10{j10} = 0.5 * ∑{r10∈nodesOfCell10(j10)}(dot(C_ic10{j10,r10}, coord10{r10}));
IniM10: ∀j10∈cells10(), m10{j10} = ρ_ic10{j10} * V_ic10{j10}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr10: ∀j10∈cells10(), ∀r10∈nodesOfCell10(j10), C10{j10,r10} = 0.5 * perp10(X10{►(r10)} - X10{◄(r10)});
ComputeLjr10: ∀j10∈cells10(), ∀r10∈nodesOfCell10(j10), l10{j10,r10} = norm(C10{j10,r10});
Computeδtj10: ∀j10∈cells10(), δtj10{j10} = 2.0 * V10{j10} / (c10{j10} * ∑{r10∈nodesOfCell10(j10)}(l10{j10,r10}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity10: ∀j10∈cells10(), ρ10{j10} = m10{j10} / V10{j10};
ComputeEOSp10: ∀j10∈cells10(), p10{j10} = (γ10-1.0) * ρ10{j10} * e10{j10};
ComputeInternalEngergy10: ∀j10∈cells10(), e10{j10} = E10{j10} - 0.5 * dot(uj10{j10}, uj10{j10});
ComputeEOSc10: ∀j10∈cells10(), c10{j10} = √(γ10*p10{j10}/ρ10{j10}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr10: ∀j10∈cells10(), ∀r10∈nodesOfCell10(j10), Ajr10{j10,r10} = ((ρ10{j10}*c10{j10})/l10{j10,r10}) * tensProduct10(C10{j10,r10}, C10{j10,r10});
ComputeFjr10: ∀j10∈cells10(), ∀r10∈nodesOfCell10(j10), F10{j10,r10} = p10{j10}*C10{j10,r10} + matVectProduct10(Ajr10{j10,r10}, (uj10{j10}-ur10{r10}));
ComputeAr10: ∀r10∈nodes10(), Ar10{r10} = ∑{j10∈cellsOfNode10(r10)}(Ajr10{j10,r10});
ComputeBr10: ∀r10∈nodes10(), b10{r10} = ∑{j10∈cellsOfNode10(r10)}(p10{j10}*C10{j10,r10} + matVectProduct10(Ajr10{j10,r10}, uj10{j10}));
ComputeMt10: ∀r10∈innerNodes10(), Mt10{r10} = Ar10{r10};
ComputeBt10: ∀r10∈innerNodes10(), bt10{r10} = b10{r10};

OuterFacesComputations10: ∀k10∈outerFaces10(), {
	const ℝ epsilon10 = 1.0e-10;
	ℝ²ˣ² I10 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN10 = 0.0;
	ℝ X_MAX10 = X_EDGE_ELEMS10 * LENGTH10;
	ℝ Y_MIN10 = 0.0; 
	ℝ Y_MAX10 = Y_EDGE_ELEMS10 * LENGTH10;
	ℝ² nY10 = {0.0,1.0};
	
	∀r10∈nodesOfFace10(k10), {
		// Y boundary conditions (must be done before X)
		if ((X10{r10}.y-Y_MIN10 < epsilon10) || (X10{r10}.y-Y_MAX10 < epsilon10)) {
			ℝ sign10 = 0.0;
			if (X10{r10}.y-Y_MIN10 < epsilon10) sign10 = -1.0;
			else sign10 = 1.0;
			ℝ² n10 = sign10 * nY10;
      		ℝ²ˣ² nxn10 = tensProduct10(n10,n10);
      		ℝ²ˣ² IcP10 = I10 - nxn10;
			bt1{r10} = matVectProduct10(IcP10, b10{r10});
			Mt1{r10} = IcP10 * (Ar10{r10} * IcP10) + nxn10*trace10(Ar10{r10});
		}

		// X boundary conditions
		if ((Math.fabs(X10{r10}.x-X_MIN10) < epsilon10) || ( (Math.fabs(X10{r10}.x-X_MAX10) < epsilon10) )) {
			Mt10{r10} = I10;
			bt10{r10} = {0.0, 0.0};
		}
	}
}


ComputeU10: ∀r10∈nodes10(), ur10{r10} = matVectProduct10(inverse10(Mt10{r10}), bt10{r10});
ComputeV10: ∀j10∈cells10(), V10{j10} = 0.5 * ∑{r10∈nodesOfCell10(j10)}(dot(C10{j10,r10},X10{r10}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn10: ∀n10∈ℕ, ∀r010∈nodes10(), X10{r010}^{n10=0}=coord10{r010}; , ∀r10∈nodes10(), X10{r10}^{n10+1}=X10{r10}^{n10}+δt10^{n10}*ur10{r10};
ComputeUn10: ∀n10∈ℕ, ∀j010∈cells10(), uj10{j010}^{n10=0}={0.0,0.0}; , ∀j10∈cells10(), uj10{j10}^{n10+1}=uj10{j10}^{n10}-(δt10^{n10}/m10{j10})*∑{r10∈nodesOfCell10(j10)}(F10{j10,r10});
ComputeEn10: ∀n10∈ℕ, ∀j010∈cells10(), E10{j010}^{n10=0}=p_ic10{j010}/((γ10-1.0)*ρ_ic10{j010}); , ∀j10∈cells10(), E10{j10}^{n10+1}=E10{j10}^{n10} - (δt10^{n10} / m10{j10}) * ∑{r10∈nodesOfCell10(j10)}(dot(F10{j10,r10},ur10{r10}));
ComputeDt10: ∀n10∈ℕ, δt10^{n10=0}=option_δt_ini10;, δt10^{n10+1}=option_δt_cfl10*reduceMin{j10∈cells10()}(δtj10{j10});
ComputeTn10: ∀n10∈ℕ, t10^{n10=0}=0.0; , t10^{n10+1}=t10^{n10}+δt10^{n10+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter11: ∀j11∈cells11(), center11{j11} = (1.0/4.0) * ∑{r11∈nodesOfCell11(j11)}(coord11{r11});
IniIc11: ∀j11∈cells11(), if (center11{j11}.x < option_x_interface11) {
  ρ_ic11{j11}=option_ρ_ini_zg11;
  p_ic11{j11}=option_p_ini_zg11;
} else {
  ρ_ic11{j11}=option_ρ_ini_zd11;
  p_ic11{j11}=option_p_ini_zd11;
}

ComputeCjrIc11: ∀j11∈cells11(), ∀r11∈nodesOfCell11(j11), 
	C_ic11{j11,r11} = 0.5 * perp11(coord11{►(r11)} - coord11{◄(r11)});
IniVIc11: ∀j11∈cells11(), V_ic11{j11} = 0.5 * ∑{r11∈nodesOfCell11(j11)}(dot(C_ic11{j11,r11}, coord11{r11}));
IniM11: ∀j11∈cells11(), m11{j11} = ρ_ic11{j11} * V_ic11{j11}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr11: ∀j11∈cells11(), ∀r11∈nodesOfCell11(j11), C11{j11,r11} = 0.5 * perp11(X11{►(r11)} - X11{◄(r11)});
ComputeLjr11: ∀j11∈cells11(), ∀r11∈nodesOfCell11(j11), l11{j11,r11} = norm(C11{j11,r11});
Computeδtj11: ∀j11∈cells11(), δtj11{j11} = 2.0 * V11{j11} / (c11{j11} * ∑{r11∈nodesOfCell11(j11)}(l11{j11,r11}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity11: ∀j11∈cells11(), ρ11{j11} = m11{j11} / V11{j11};
ComputeEOSp11: ∀j11∈cells11(), p11{j11} = (γ11-1.0) * ρ11{j11} * e11{j11};
ComputeInternalEngergy11: ∀j11∈cells11(), e11{j11} = E11{j11} - 0.5 * dot(uj11{j11}, uj11{j11});
ComputeEOSc11: ∀j11∈cells11(), c11{j11} = √(γ11*p11{j11}/ρ11{j11}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr11: ∀j11∈cells11(), ∀r11∈nodesOfCell11(j11), Ajr11{j11,r11} = ((ρ11{j11}*c11{j11})/l11{j11,r11}) * tensProduct11(C11{j11,r11}, C11{j11,r11});
ComputeFjr11: ∀j11∈cells11(), ∀r11∈nodesOfCell11(j11), F11{j11,r11} = p11{j11}*C11{j11,r11} + matVectProduct11(Ajr11{j11,r11}, (uj11{j11}-ur11{r11}));
ComputeAr11: ∀r11∈nodes11(), Ar11{r11} = ∑{j11∈cellsOfNode11(r11)}(Ajr11{j11,r11});
ComputeBr11: ∀r11∈nodes11(), b11{r11} = ∑{j11∈cellsOfNode11(r11)}(p11{j11}*C11{j11,r11} + matVectProduct11(Ajr11{j11,r11}, uj11{j11}));
ComputeMt11: ∀r11∈innerNodes11(), Mt11{r11} = Ar11{r11};
ComputeBt11: ∀r11∈innerNodes11(), bt11{r11} = b11{r11};

OuterFacesComputations11: ∀k11∈outerFaces11(), {
	const ℝ epsilon11 = 1.0e-10;
	ℝ²ˣ² I11 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN11 = 0.0;
	ℝ X_MAX11 = X_EDGE_ELEMS11 * LENGTH11;
	ℝ Y_MIN11 = 0.0; 
	ℝ Y_MAX11 = Y_EDGE_ELEMS11 * LENGTH11;
	ℝ² nY11 = {0.0,1.0};
	
	∀r11∈nodesOfFace11(k11), {
		// Y boundary conditions (must be done before X)
		if ((X11{r11}.y-Y_MIN11 < epsilon11) || (X11{r11}.y-Y_MAX11 < epsilon11)) {
			ℝ sign11 = 0.0;
			if (X11{r11}.y-Y_MIN11 < epsilon11) sign11 = -1.0;
			else sign11 = 1.0;
			ℝ² n11 = sign11 * nY11;
      		ℝ²ˣ² nxn11 = tensProduct11(n11,n11);
      		ℝ²ˣ² IcP11 = I11 - nxn11;
			bt1{r11} = matVectProduct11(IcP11, b11{r11});
			Mt1{r11} = IcP11 * (Ar11{r11} * IcP11) + nxn11*trace11(Ar11{r11});
		}

		// X boundary conditions
		if ((Math.fabs(X11{r11}.x-X_MIN11) < epsilon11) || ( (Math.fabs(X11{r11}.x-X_MAX11) < epsilon11) )) {
			Mt11{r11} = I11;
			bt11{r11} = {0.0, 0.0};
		}
	}
}


ComputeU11: ∀r11∈nodes11(), ur11{r11} = matVectProduct11(inverse11(Mt11{r11}), bt11{r11});
ComputeV11: ∀j11∈cells11(), V11{j11} = 0.5 * ∑{r11∈nodesOfCell11(j11)}(dot(C11{j11,r11},X11{r11}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn11: ∀n11∈ℕ, ∀r011∈nodes11(), X11{r011}^{n11=0}=coord11{r011}; , ∀r11∈nodes11(), X11{r11}^{n11+1}=X11{r11}^{n11}+δt11^{n11}*ur11{r11};
ComputeUn11: ∀n11∈ℕ, ∀j011∈cells11(), uj11{j011}^{n11=0}={0.0,0.0}; , ∀j11∈cells11(), uj11{j11}^{n11+1}=uj11{j11}^{n11}-(δt11^{n11}/m11{j11})*∑{r11∈nodesOfCell11(j11)}(F11{j11,r11});
ComputeEn11: ∀n11∈ℕ, ∀j011∈cells11(), E11{j011}^{n11=0}=p_ic11{j011}/((γ11-1.0)*ρ_ic11{j011}); , ∀j11∈cells11(), E11{j11}^{n11+1}=E11{j11}^{n11} - (δt11^{n11} / m11{j11}) * ∑{r11∈nodesOfCell11(j11)}(dot(F11{j11,r11},ur11{r11}));
ComputeDt11: ∀n11∈ℕ, δt11^{n11=0}=option_δt_ini11;, δt11^{n11+1}=option_δt_cfl11*reduceMin{j11∈cells11()}(δtj11{j11});
ComputeTn11: ∀n11∈ℕ, t11^{n11=0}=0.0; , t11^{n11+1}=t11^{n11}+δt11^{n11+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter12: ∀j12∈cells12(), center12{j12} = (1.0/4.0) * ∑{r12∈nodesOfCell12(j12)}(coord12{r12});
IniIc12: ∀j12∈cells12(), if (center12{j12}.x < option_x_interface12) {
  ρ_ic12{j12}=option_ρ_ini_zg12;
  p_ic12{j12}=option_p_ini_zg12;
} else {
  ρ_ic12{j12}=option_ρ_ini_zd12;
  p_ic12{j12}=option_p_ini_zd12;
}

ComputeCjrIc12: ∀j12∈cells12(), ∀r12∈nodesOfCell12(j12), 
	C_ic12{j12,r12} = 0.5 * perp12(coord12{►(r12)} - coord12{◄(r12)});
IniVIc12: ∀j12∈cells12(), V_ic12{j12} = 0.5 * ∑{r12∈nodesOfCell12(j12)}(dot(C_ic12{j12,r12}, coord12{r12}));
IniM12: ∀j12∈cells12(), m12{j12} = ρ_ic12{j12} * V_ic12{j12}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr12: ∀j12∈cells12(), ∀r12∈nodesOfCell12(j12), C12{j12,r12} = 0.5 * perp12(X12{►(r12)} - X12{◄(r12)});
ComputeLjr12: ∀j12∈cells12(), ∀r12∈nodesOfCell12(j12), l12{j12,r12} = norm(C12{j12,r12});
Computeδtj12: ∀j12∈cells12(), δtj12{j12} = 2.0 * V12{j12} / (c12{j12} * ∑{r12∈nodesOfCell12(j12)}(l12{j12,r12}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity12: ∀j12∈cells12(), ρ12{j12} = m12{j12} / V12{j12};
ComputeEOSp12: ∀j12∈cells12(), p12{j12} = (γ12-1.0) * ρ12{j12} * e12{j12};
ComputeInternalEngergy12: ∀j12∈cells12(), e12{j12} = E12{j12} - 0.5 * dot(uj12{j12}, uj12{j12});
ComputeEOSc12: ∀j12∈cells12(), c12{j12} = √(γ12*p12{j12}/ρ12{j12}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr12: ∀j12∈cells12(), ∀r12∈nodesOfCell12(j12), Ajr12{j12,r12} = ((ρ12{j12}*c12{j12})/l12{j12,r12}) * tensProduct12(C12{j12,r12}, C12{j12,r12});
ComputeFjr12: ∀j12∈cells12(), ∀r12∈nodesOfCell12(j12), F12{j12,r12} = p12{j12}*C12{j12,r12} + matVectProduct12(Ajr12{j12,r12}, (uj12{j12}-ur12{r12}));
ComputeAr12: ∀r12∈nodes12(), Ar12{r12} = ∑{j12∈cellsOfNode12(r12)}(Ajr12{j12,r12});
ComputeBr12: ∀r12∈nodes12(), b12{r12} = ∑{j12∈cellsOfNode12(r12)}(p12{j12}*C12{j12,r12} + matVectProduct12(Ajr12{j12,r12}, uj12{j12}));
ComputeMt12: ∀r12∈innerNodes12(), Mt12{r12} = Ar12{r12};
ComputeBt12: ∀r12∈innerNodes12(), bt12{r12} = b12{r12};

OuterFacesComputations12: ∀k12∈outerFaces12(), {
	const ℝ epsilon12 = 1.0e-10;
	ℝ²ˣ² I12 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN12 = 0.0;
	ℝ X_MAX12 = X_EDGE_ELEMS12 * LENGTH12;
	ℝ Y_MIN12 = 0.0; 
	ℝ Y_MAX12 = Y_EDGE_ELEMS12 * LENGTH12;
	ℝ² nY12 = {0.0,1.0};
	
	∀r12∈nodesOfFace12(k12), {
		// Y boundary conditions (must be done before X)
		if ((X12{r12}.y-Y_MIN12 < epsilon12) || (X12{r12}.y-Y_MAX12 < epsilon12)) {
			ℝ sign12 = 0.0;
			if (X12{r12}.y-Y_MIN12 < epsilon12) sign12 = -1.0;
			else sign12 = 1.0;
			ℝ² n12 = sign12 * nY12;
      		ℝ²ˣ² nxn12 = tensProduct12(n12,n12);
      		ℝ²ˣ² IcP12 = I12 - nxn12;
			bt1{r12} = matVectProduct12(IcP12, b12{r12});
			Mt1{r12} = IcP12 * (Ar12{r12} * IcP12) + nxn12*trace12(Ar12{r12});
		}

		// X boundary conditions
		if ((Math.fabs(X12{r12}.x-X_MIN12) < epsilon12) || ( (Math.fabs(X12{r12}.x-X_MAX12) < epsilon12) )) {
			Mt12{r12} = I12;
			bt12{r12} = {0.0, 0.0};
		}
	}
}


ComputeU12: ∀r12∈nodes12(), ur12{r12} = matVectProduct12(inverse12(Mt12{r12}), bt12{r12});
ComputeV12: ∀j12∈cells12(), V12{j12} = 0.5 * ∑{r12∈nodesOfCell12(j12)}(dot(C12{j12,r12},X12{r12}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn12: ∀n12∈ℕ, ∀r012∈nodes12(), X12{r012}^{n12=0}=coord12{r012}; , ∀r12∈nodes12(), X12{r12}^{n12+1}=X12{r12}^{n12}+δt12^{n12}*ur12{r12};
ComputeUn12: ∀n12∈ℕ, ∀j012∈cells12(), uj12{j012}^{n12=0}={0.0,0.0}; , ∀j12∈cells12(), uj12{j12}^{n12+1}=uj12{j12}^{n12}-(δt12^{n12}/m12{j12})*∑{r12∈nodesOfCell12(j12)}(F12{j12,r12});
ComputeEn12: ∀n12∈ℕ, ∀j012∈cells12(), E12{j012}^{n12=0}=p_ic12{j012}/((γ12-1.0)*ρ_ic12{j012}); , ∀j12∈cells12(), E12{j12}^{n12+1}=E12{j12}^{n12} - (δt12^{n12} / m12{j12}) * ∑{r12∈nodesOfCell12(j12)}(dot(F12{j12,r12},ur12{r12}));
ComputeDt12: ∀n12∈ℕ, δt12^{n12=0}=option_δt_ini12;, δt12^{n12+1}=option_δt_cfl12*reduceMin{j12∈cells12()}(δtj12{j12});
ComputeTn12: ∀n12∈ℕ, t12^{n12=0}=0.0; , t12^{n12+1}=t12^{n12}+δt12^{n12+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter13: ∀j13∈cells13(), center13{j13} = (1.0/4.0) * ∑{r13∈nodesOfCell13(j13)}(coord13{r13});
IniIc13: ∀j13∈cells13(), if (center13{j13}.x < option_x_interface13) {
  ρ_ic13{j13}=option_ρ_ini_zg13;
  p_ic13{j13}=option_p_ini_zg13;
} else {
  ρ_ic13{j13}=option_ρ_ini_zd13;
  p_ic13{j13}=option_p_ini_zd13;
}

ComputeCjrIc13: ∀j13∈cells13(), ∀r13∈nodesOfCell13(j13), 
	C_ic13{j13,r13} = 0.5 * perp13(coord13{►(r13)} - coord13{◄(r13)});
IniVIc13: ∀j13∈cells13(), V_ic13{j13} = 0.5 * ∑{r13∈nodesOfCell13(j13)}(dot(C_ic13{j13,r13}, coord13{r13}));
IniM13: ∀j13∈cells13(), m13{j13} = ρ_ic13{j13} * V_ic13{j13}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr13: ∀j13∈cells13(), ∀r13∈nodesOfCell13(j13), C13{j13,r13} = 0.5 * perp13(X13{►(r13)} - X13{◄(r13)});
ComputeLjr13: ∀j13∈cells13(), ∀r13∈nodesOfCell13(j13), l13{j13,r13} = norm(C13{j13,r13});
Computeδtj13: ∀j13∈cells13(), δtj13{j13} = 2.0 * V13{j13} / (c13{j13} * ∑{r13∈nodesOfCell13(j13)}(l13{j13,r13}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity13: ∀j13∈cells13(), ρ13{j13} = m13{j13} / V13{j13};
ComputeEOSp13: ∀j13∈cells13(), p13{j13} = (γ13-1.0) * ρ13{j13} * e13{j13};
ComputeInternalEngergy13: ∀j13∈cells13(), e13{j13} = E13{j13} - 0.5 * dot(uj13{j13}, uj13{j13});
ComputeEOSc13: ∀j13∈cells13(), c13{j13} = √(γ13*p13{j13}/ρ13{j13}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr13: ∀j13∈cells13(), ∀r13∈nodesOfCell13(j13), Ajr13{j13,r13} = ((ρ13{j13}*c13{j13})/l13{j13,r13}) * tensProduct13(C13{j13,r13}, C13{j13,r13});
ComputeFjr13: ∀j13∈cells13(), ∀r13∈nodesOfCell13(j13), F13{j13,r13} = p13{j13}*C13{j13,r13} + matVectProduct13(Ajr13{j13,r13}, (uj13{j13}-ur13{r13}));
ComputeAr13: ∀r13∈nodes13(), Ar13{r13} = ∑{j13∈cellsOfNode13(r13)}(Ajr13{j13,r13});
ComputeBr13: ∀r13∈nodes13(), b13{r13} = ∑{j13∈cellsOfNode13(r13)}(p13{j13}*C13{j13,r13} + matVectProduct13(Ajr13{j13,r13}, uj13{j13}));
ComputeMt13: ∀r13∈innerNodes13(), Mt13{r13} = Ar13{r13};
ComputeBt13: ∀r13∈innerNodes13(), bt13{r13} = b13{r13};

OuterFacesComputations13: ∀k13∈outerFaces13(), {
	const ℝ epsilon13 = 1.0e-10;
	ℝ²ˣ² I13 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN13 = 0.0;
	ℝ X_MAX13 = X_EDGE_ELEMS13 * LENGTH13;
	ℝ Y_MIN13 = 0.0; 
	ℝ Y_MAX13 = Y_EDGE_ELEMS13 * LENGTH13;
	ℝ² nY13 = {0.0,1.0};
	
	∀r13∈nodesOfFace13(k13), {
		// Y boundary conditions (must be done before X)
		if ((X13{r13}.y-Y_MIN13 < epsilon13) || (X13{r13}.y-Y_MAX13 < epsilon13)) {
			ℝ sign13 = 0.0;
			if (X13{r13}.y-Y_MIN13 < epsilon13) sign13 = -1.0;
			else sign13 = 1.0;
			ℝ² n13 = sign13 * nY13;
      		ℝ²ˣ² nxn13 = tensProduct13(n13,n13);
      		ℝ²ˣ² IcP13 = I13 - nxn13;
			bt1{r13} = matVectProduct13(IcP13, b13{r13});
			Mt1{r13} = IcP13 * (Ar13{r13} * IcP13) + nxn13*trace13(Ar13{r13});
		}

		// X boundary conditions
		if ((Math.fabs(X13{r13}.x-X_MIN13) < epsilon13) || ( (Math.fabs(X13{r13}.x-X_MAX13) < epsilon13) )) {
			Mt13{r13} = I13;
			bt13{r13} = {0.0, 0.0};
		}
	}
}


ComputeU13: ∀r13∈nodes13(), ur13{r13} = matVectProduct13(inverse13(Mt13{r13}), bt13{r13});
ComputeV13: ∀j13∈cells13(), V13{j13} = 0.5 * ∑{r13∈nodesOfCell13(j13)}(dot(C13{j13,r13},X13{r13}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn13: ∀n13∈ℕ, ∀r013∈nodes13(), X13{r013}^{n13=0}=coord13{r013}; , ∀r13∈nodes13(), X13{r13}^{n13+1}=X13{r13}^{n13}+δt13^{n13}*ur13{r13};
ComputeUn13: ∀n13∈ℕ, ∀j013∈cells13(), uj13{j013}^{n13=0}={0.0,0.0}; , ∀j13∈cells13(), uj13{j13}^{n13+1}=uj13{j13}^{n13}-(δt13^{n13}/m13{j13})*∑{r13∈nodesOfCell13(j13)}(F13{j13,r13});
ComputeEn13: ∀n13∈ℕ, ∀j013∈cells13(), E13{j013}^{n13=0}=p_ic13{j013}/((γ13-1.0)*ρ_ic13{j013}); , ∀j13∈cells13(), E13{j13}^{n13+1}=E13{j13}^{n13} - (δt13^{n13} / m13{j13}) * ∑{r13∈nodesOfCell13(j13)}(dot(F13{j13,r13},ur13{r13}));
ComputeDt13: ∀n13∈ℕ, δt13^{n13=0}=option_δt_ini13;, δt13^{n13+1}=option_δt_cfl13*reduceMin{j13∈cells13()}(δtj13{j13});
ComputeTn13: ∀n13∈ℕ, t13^{n13=0}=0.0; , t13^{n13+1}=t13^{n13}+δt13^{n13+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter14: ∀j14∈cells14(), center14{j14} = (1.0/4.0) * ∑{r14∈nodesOfCell14(j14)}(coord14{r14});
IniIc14: ∀j14∈cells14(), if (center14{j14}.x < option_x_interface14) {
  ρ_ic14{j14}=option_ρ_ini_zg14;
  p_ic14{j14}=option_p_ini_zg14;
} else {
  ρ_ic14{j14}=option_ρ_ini_zd14;
  p_ic14{j14}=option_p_ini_zd14;
}

ComputeCjrIc14: ∀j14∈cells14(), ∀r14∈nodesOfCell14(j14), 
	C_ic14{j14,r14} = 0.5 * perp14(coord14{►(r14)} - coord14{◄(r14)});
IniVIc14: ∀j14∈cells14(), V_ic14{j14} = 0.5 * ∑{r14∈nodesOfCell14(j14)}(dot(C_ic14{j14,r14}, coord14{r14}));
IniM14: ∀j14∈cells14(), m14{j14} = ρ_ic14{j14} * V_ic14{j14}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr14: ∀j14∈cells14(), ∀r14∈nodesOfCell14(j14), C14{j14,r14} = 0.5 * perp14(X14{►(r14)} - X14{◄(r14)});
ComputeLjr14: ∀j14∈cells14(), ∀r14∈nodesOfCell14(j14), l14{j14,r14} = norm(C14{j14,r14});
Computeδtj14: ∀j14∈cells14(), δtj14{j14} = 2.0 * V14{j14} / (c14{j14} * ∑{r14∈nodesOfCell14(j14)}(l14{j14,r14}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity14: ∀j14∈cells14(), ρ14{j14} = m14{j14} / V14{j14};
ComputeEOSp14: ∀j14∈cells14(), p14{j14} = (γ14-1.0) * ρ14{j14} * e14{j14};
ComputeInternalEngergy14: ∀j14∈cells14(), e14{j14} = E14{j14} - 0.5 * dot(uj14{j14}, uj14{j14});
ComputeEOSc14: ∀j14∈cells14(), c14{j14} = √(γ14*p14{j14}/ρ14{j14}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr14: ∀j14∈cells14(), ∀r14∈nodesOfCell14(j14), Ajr14{j14,r14} = ((ρ14{j14}*c14{j14})/l14{j14,r14}) * tensProduct14(C14{j14,r14}, C14{j14,r14});
ComputeFjr14: ∀j14∈cells14(), ∀r14∈nodesOfCell14(j14), F14{j14,r14} = p14{j14}*C14{j14,r14} + matVectProduct14(Ajr14{j14,r14}, (uj14{j14}-ur14{r14}));
ComputeAr14: ∀r14∈nodes14(), Ar14{r14} = ∑{j14∈cellsOfNode14(r14)}(Ajr14{j14,r14});
ComputeBr14: ∀r14∈nodes14(), b14{r14} = ∑{j14∈cellsOfNode14(r14)}(p14{j14}*C14{j14,r14} + matVectProduct14(Ajr14{j14,r14}, uj14{j14}));
ComputeMt14: ∀r14∈innerNodes14(), Mt14{r14} = Ar14{r14};
ComputeBt14: ∀r14∈innerNodes14(), bt14{r14} = b14{r14};

OuterFacesComputations14: ∀k14∈outerFaces14(), {
	const ℝ epsilon14 = 1.0e-10;
	ℝ²ˣ² I14 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN14 = 0.0;
	ℝ X_MAX14 = X_EDGE_ELEMS14 * LENGTH14;
	ℝ Y_MIN14 = 0.0; 
	ℝ Y_MAX14 = Y_EDGE_ELEMS14 * LENGTH14;
	ℝ² nY14 = {0.0,1.0};
	
	∀r14∈nodesOfFace14(k14), {
		// Y boundary conditions (must be done before X)
		if ((X14{r14}.y-Y_MIN14 < epsilon14) || (X14{r14}.y-Y_MAX14 < epsilon14)) {
			ℝ sign14 = 0.0;
			if (X14{r14}.y-Y_MIN14 < epsilon14) sign14 = -1.0;
			else sign14 = 1.0;
			ℝ² n14 = sign14 * nY14;
      		ℝ²ˣ² nxn14 = tensProduct14(n14,n14);
      		ℝ²ˣ² IcP14 = I14 - nxn14;
			bt1{r14} = matVectProduct14(IcP14, b14{r14});
			Mt1{r14} = IcP14 * (Ar14{r14} * IcP14) + nxn14*trace14(Ar14{r14});
		}

		// X boundary conditions
		if ((Math.fabs(X14{r14}.x-X_MIN14) < epsilon14) || ( (Math.fabs(X14{r14}.x-X_MAX14) < epsilon14) )) {
			Mt14{r14} = I14;
			bt14{r14} = {0.0, 0.0};
		}
	}
}


ComputeU14: ∀r14∈nodes14(), ur14{r14} = matVectProduct14(inverse14(Mt14{r14}), bt14{r14});
ComputeV14: ∀j14∈cells14(), V14{j14} = 0.5 * ∑{r14∈nodesOfCell14(j14)}(dot(C14{j14,r14},X14{r14}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn14: ∀n14∈ℕ, ∀r014∈nodes14(), X14{r014}^{n14=0}=coord14{r014}; , ∀r14∈nodes14(), X14{r14}^{n14+1}=X14{r14}^{n14}+δt14^{n14}*ur14{r14};
ComputeUn14: ∀n14∈ℕ, ∀j014∈cells14(), uj14{j014}^{n14=0}={0.0,0.0}; , ∀j14∈cells14(), uj14{j14}^{n14+1}=uj14{j14}^{n14}-(δt14^{n14}/m14{j14})*∑{r14∈nodesOfCell14(j14)}(F14{j14,r14});
ComputeEn14: ∀n14∈ℕ, ∀j014∈cells14(), E14{j014}^{n14=0}=p_ic14{j014}/((γ14-1.0)*ρ_ic14{j014}); , ∀j14∈cells14(), E14{j14}^{n14+1}=E14{j14}^{n14} - (δt14^{n14} / m14{j14}) * ∑{r14∈nodesOfCell14(j14)}(dot(F14{j14,r14},ur14{r14}));
ComputeDt14: ∀n14∈ℕ, δt14^{n14=0}=option_δt_ini14;, δt14^{n14+1}=option_δt_cfl14*reduceMin{j14∈cells14()}(δtj14{j14});
ComputeTn14: ∀n14∈ℕ, t14^{n14=0}=0.0; , t14^{n14+1}=t14^{n14}+δt14^{n14+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter15: ∀j15∈cells15(), center15{j15} = (1.0/4.0) * ∑{r15∈nodesOfCell15(j15)}(coord15{r15});
IniIc15: ∀j15∈cells15(), if (center15{j15}.x < option_x_interface15) {
  ρ_ic15{j15}=option_ρ_ini_zg15;
  p_ic15{j15}=option_p_ini_zg15;
} else {
  ρ_ic15{j15}=option_ρ_ini_zd15;
  p_ic15{j15}=option_p_ini_zd15;
}

ComputeCjrIc15: ∀j15∈cells15(), ∀r15∈nodesOfCell15(j15), 
	C_ic15{j15,r15} = 0.5 * perp15(coord15{►(r15)} - coord15{◄(r15)});
IniVIc15: ∀j15∈cells15(), V_ic15{j15} = 0.5 * ∑{r15∈nodesOfCell15(j15)}(dot(C_ic15{j15,r15}, coord15{r15}));
IniM15: ∀j15∈cells15(), m15{j15} = ρ_ic15{j15} * V_ic15{j15}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr15: ∀j15∈cells15(), ∀r15∈nodesOfCell15(j15), C15{j15,r15} = 0.5 * perp15(X15{►(r15)} - X15{◄(r15)});
ComputeLjr15: ∀j15∈cells15(), ∀r15∈nodesOfCell15(j15), l15{j15,r15} = norm(C15{j15,r15});
Computeδtj15: ∀j15∈cells15(), δtj15{j15} = 2.0 * V15{j15} / (c15{j15} * ∑{r15∈nodesOfCell15(j15)}(l15{j15,r15}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity15: ∀j15∈cells15(), ρ15{j15} = m15{j15} / V15{j15};
ComputeEOSp15: ∀j15∈cells15(), p15{j15} = (γ15-1.0) * ρ15{j15} * e15{j15};
ComputeInternalEngergy15: ∀j15∈cells15(), e15{j15} = E15{j15} - 0.5 * dot(uj15{j15}, uj15{j15});
ComputeEOSc15: ∀j15∈cells15(), c15{j15} = √(γ15*p15{j15}/ρ15{j15}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr15: ∀j15∈cells15(), ∀r15∈nodesOfCell15(j15), Ajr15{j15,r15} = ((ρ15{j15}*c15{j15})/l15{j15,r15}) * tensProduct15(C15{j15,r15}, C15{j15,r15});
ComputeFjr15: ∀j15∈cells15(), ∀r15∈nodesOfCell15(j15), F15{j15,r15} = p15{j15}*C15{j15,r15} + matVectProduct15(Ajr15{j15,r15}, (uj15{j15}-ur15{r15}));
ComputeAr15: ∀r15∈nodes15(), Ar15{r15} = ∑{j15∈cellsOfNode15(r15)}(Ajr15{j15,r15});
ComputeBr15: ∀r15∈nodes15(), b15{r15} = ∑{j15∈cellsOfNode15(r15)}(p15{j15}*C15{j15,r15} + matVectProduct15(Ajr15{j15,r15}, uj15{j15}));
ComputeMt15: ∀r15∈innerNodes15(), Mt15{r15} = Ar15{r15};
ComputeBt15: ∀r15∈innerNodes15(), bt15{r15} = b15{r15};

OuterFacesComputations15: ∀k15∈outerFaces15(), {
	const ℝ epsilon15 = 1.0e-10;
	ℝ²ˣ² I15 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN15 = 0.0;
	ℝ X_MAX15 = X_EDGE_ELEMS15 * LENGTH15;
	ℝ Y_MIN15 = 0.0; 
	ℝ Y_MAX15 = Y_EDGE_ELEMS15 * LENGTH15;
	ℝ² nY15 = {0.0,1.0};
	
	∀r15∈nodesOfFace15(k15), {
		// Y boundary conditions (must be done before X)
		if ((X15{r15}.y-Y_MIN15 < epsilon15) || (X15{r15}.y-Y_MAX15 < epsilon15)) {
			ℝ sign15 = 0.0;
			if (X15{r15}.y-Y_MIN15 < epsilon15) sign15 = -1.0;
			else sign15 = 1.0;
			ℝ² n15 = sign15 * nY15;
      		ℝ²ˣ² nxn15 = tensProduct15(n15,n15);
      		ℝ²ˣ² IcP15 = I15 - nxn15;
			bt1{r15} = matVectProduct15(IcP15, b15{r15});
			Mt1{r15} = IcP15 * (Ar15{r15} * IcP15) + nxn15*trace15(Ar15{r15});
		}

		// X boundary conditions
		if ((Math.fabs(X15{r15}.x-X_MIN15) < epsilon15) || ( (Math.fabs(X15{r15}.x-X_MAX15) < epsilon15) )) {
			Mt15{r15} = I15;
			bt15{r15} = {0.0, 0.0};
		}
	}
}


ComputeU15: ∀r15∈nodes15(), ur15{r15} = matVectProduct15(inverse15(Mt15{r15}), bt15{r15});
ComputeV15: ∀j15∈cells15(), V15{j15} = 0.5 * ∑{r15∈nodesOfCell15(j15)}(dot(C15{j15,r15},X15{r15}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn15: ∀n15∈ℕ, ∀r015∈nodes15(), X15{r015}^{n15=0}=coord15{r015}; , ∀r15∈nodes15(), X15{r15}^{n15+1}=X15{r15}^{n15}+δt15^{n15}*ur15{r15};
ComputeUn15: ∀n15∈ℕ, ∀j015∈cells15(), uj15{j015}^{n15=0}={0.0,0.0}; , ∀j15∈cells15(), uj15{j15}^{n15+1}=uj15{j15}^{n15}-(δt15^{n15}/m15{j15})*∑{r15∈nodesOfCell15(j15)}(F15{j15,r15});
ComputeEn15: ∀n15∈ℕ, ∀j015∈cells15(), E15{j015}^{n15=0}=p_ic15{j015}/((γ15-1.0)*ρ_ic15{j015}); , ∀j15∈cells15(), E15{j15}^{n15+1}=E15{j15}^{n15} - (δt15^{n15} / m15{j15}) * ∑{r15∈nodesOfCell15(j15)}(dot(F15{j15,r15},ur15{r15}));
ComputeDt15: ∀n15∈ℕ, δt15^{n15=0}=option_δt_ini15;, δt15^{n15+1}=option_δt_cfl15*reduceMin{j15∈cells15()}(δtj15{j15});
ComputeTn15: ∀n15∈ℕ, t15^{n15=0}=0.0; , t15^{n15+1}=t15^{n15}+δt15^{n15+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter16: ∀j16∈cells16(), center16{j16} = (1.0/4.0) * ∑{r16∈nodesOfCell16(j16)}(coord16{r16});
IniIc16: ∀j16∈cells16(), if (center16{j16}.x < option_x_interface16) {
  ρ_ic16{j16}=option_ρ_ini_zg16;
  p_ic16{j16}=option_p_ini_zg16;
} else {
  ρ_ic16{j16}=option_ρ_ini_zd16;
  p_ic16{j16}=option_p_ini_zd16;
}

ComputeCjrIc16: ∀j16∈cells16(), ∀r16∈nodesOfCell16(j16), 
	C_ic16{j16,r16} = 0.5 * perp16(coord16{►(r16)} - coord16{◄(r16)});
IniVIc16: ∀j16∈cells16(), V_ic16{j16} = 0.5 * ∑{r16∈nodesOfCell16(j16)}(dot(C_ic16{j16,r16}, coord16{r16}));
IniM16: ∀j16∈cells16(), m16{j16} = ρ_ic16{j16} * V_ic16{j16}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr16: ∀j16∈cells16(), ∀r16∈nodesOfCell16(j16), C16{j16,r16} = 0.5 * perp16(X16{►(r16)} - X16{◄(r16)});
ComputeLjr16: ∀j16∈cells16(), ∀r16∈nodesOfCell16(j16), l16{j16,r16} = norm(C16{j16,r16});
Computeδtj16: ∀j16∈cells16(), δtj16{j16} = 2.0 * V16{j16} / (c16{j16} * ∑{r16∈nodesOfCell16(j16)}(l16{j16,r16}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity16: ∀j16∈cells16(), ρ16{j16} = m16{j16} / V16{j16};
ComputeEOSp16: ∀j16∈cells16(), p16{j16} = (γ16-1.0) * ρ16{j16} * e16{j16};
ComputeInternalEngergy16: ∀j16∈cells16(), e16{j16} = E16{j16} - 0.5 * dot(uj16{j16}, uj16{j16});
ComputeEOSc16: ∀j16∈cells16(), c16{j16} = √(γ16*p16{j16}/ρ16{j16}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr16: ∀j16∈cells16(), ∀r16∈nodesOfCell16(j16), Ajr16{j16,r16} = ((ρ16{j16}*c16{j16})/l16{j16,r16}) * tensProduct16(C16{j16,r16}, C16{j16,r16});
ComputeFjr16: ∀j16∈cells16(), ∀r16∈nodesOfCell16(j16), F16{j16,r16} = p16{j16}*C16{j16,r16} + matVectProduct16(Ajr16{j16,r16}, (uj16{j16}-ur16{r16}));
ComputeAr16: ∀r16∈nodes16(), Ar16{r16} = ∑{j16∈cellsOfNode16(r16)}(Ajr16{j16,r16});
ComputeBr16: ∀r16∈nodes16(), b16{r16} = ∑{j16∈cellsOfNode16(r16)}(p16{j16}*C16{j16,r16} + matVectProduct16(Ajr16{j16,r16}, uj16{j16}));
ComputeMt16: ∀r16∈innerNodes16(), Mt16{r16} = Ar16{r16};
ComputeBt16: ∀r16∈innerNodes16(), bt16{r16} = b16{r16};

OuterFacesComputations16: ∀k16∈outerFaces16(), {
	const ℝ epsilon16 = 1.0e-10;
	ℝ²ˣ² I16 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN16 = 0.0;
	ℝ X_MAX16 = X_EDGE_ELEMS16 * LENGTH16;
	ℝ Y_MIN16 = 0.0; 
	ℝ Y_MAX16 = Y_EDGE_ELEMS16 * LENGTH16;
	ℝ² nY16 = {0.0,1.0};
	
	∀r16∈nodesOfFace16(k16), {
		// Y boundary conditions (must be done before X)
		if ((X16{r16}.y-Y_MIN16 < epsilon16) || (X16{r16}.y-Y_MAX16 < epsilon16)) {
			ℝ sign16 = 0.0;
			if (X16{r16}.y-Y_MIN16 < epsilon16) sign16 = -1.0;
			else sign16 = 1.0;
			ℝ² n16 = sign16 * nY16;
      		ℝ²ˣ² nxn16 = tensProduct16(n16,n16);
      		ℝ²ˣ² IcP16 = I16 - nxn16;
			bt1{r16} = matVectProduct16(IcP16, b16{r16});
			Mt1{r16} = IcP16 * (Ar16{r16} * IcP16) + nxn16*trace16(Ar16{r16});
		}

		// X boundary conditions
		if ((Math.fabs(X16{r16}.x-X_MIN16) < epsilon16) || ( (Math.fabs(X16{r16}.x-X_MAX16) < epsilon16) )) {
			Mt16{r16} = I16;
			bt16{r16} = {0.0, 0.0};
		}
	}
}


ComputeU16: ∀r16∈nodes16(), ur16{r16} = matVectProduct16(inverse16(Mt16{r16}), bt16{r16});
ComputeV16: ∀j16∈cells16(), V16{j16} = 0.5 * ∑{r16∈nodesOfCell16(j16)}(dot(C16{j16,r16},X16{r16}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn16: ∀n16∈ℕ, ∀r016∈nodes16(), X16{r016}^{n16=0}=coord16{r016}; , ∀r16∈nodes16(), X16{r16}^{n16+1}=X16{r16}^{n16}+δt16^{n16}*ur16{r16};
ComputeUn16: ∀n16∈ℕ, ∀j016∈cells16(), uj16{j016}^{n16=0}={0.0,0.0}; , ∀j16∈cells16(), uj16{j16}^{n16+1}=uj16{j16}^{n16}-(δt16^{n16}/m16{j16})*∑{r16∈nodesOfCell16(j16)}(F16{j16,r16});
ComputeEn16: ∀n16∈ℕ, ∀j016∈cells16(), E16{j016}^{n16=0}=p_ic16{j016}/((γ16-1.0)*ρ_ic16{j016}); , ∀j16∈cells16(), E16{j16}^{n16+1}=E16{j16}^{n16} - (δt16^{n16} / m16{j16}) * ∑{r16∈nodesOfCell16(j16)}(dot(F16{j16,r16},ur16{r16}));
ComputeDt16: ∀n16∈ℕ, δt16^{n16=0}=option_δt_ini16;, δt16^{n16+1}=option_δt_cfl16*reduceMin{j16∈cells16()}(δtj16{j16});
ComputeTn16: ∀n16∈ℕ, t16^{n16=0}=0.0; , t16^{n16+1}=t16^{n16}+δt16^{n16+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter17: ∀j17∈cells17(), center17{j17} = (1.0/4.0) * ∑{r17∈nodesOfCell17(j17)}(coord17{r17});
IniIc17: ∀j17∈cells17(), if (center17{j17}.x < option_x_interface17) {
  ρ_ic17{j17}=option_ρ_ini_zg17;
  p_ic17{j17}=option_p_ini_zg17;
} else {
  ρ_ic17{j17}=option_ρ_ini_zd17;
  p_ic17{j17}=option_p_ini_zd17;
}

ComputeCjrIc17: ∀j17∈cells17(), ∀r17∈nodesOfCell17(j17), 
	C_ic17{j17,r17} = 0.5 * perp17(coord17{►(r17)} - coord17{◄(r17)});
IniVIc17: ∀j17∈cells17(), V_ic17{j17} = 0.5 * ∑{r17∈nodesOfCell17(j17)}(dot(C_ic17{j17,r17}, coord17{r17}));
IniM17: ∀j17∈cells17(), m17{j17} = ρ_ic17{j17} * V_ic17{j17}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr17: ∀j17∈cells17(), ∀r17∈nodesOfCell17(j17), C17{j17,r17} = 0.5 * perp17(X17{►(r17)} - X17{◄(r17)});
ComputeLjr17: ∀j17∈cells17(), ∀r17∈nodesOfCell17(j17), l17{j17,r17} = norm(C17{j17,r17});
Computeδtj17: ∀j17∈cells17(), δtj17{j17} = 2.0 * V17{j17} / (c17{j17} * ∑{r17∈nodesOfCell17(j17)}(l17{j17,r17}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity17: ∀j17∈cells17(), ρ17{j17} = m17{j17} / V17{j17};
ComputeEOSp17: ∀j17∈cells17(), p17{j17} = (γ17-1.0) * ρ17{j17} * e17{j17};
ComputeInternalEngergy17: ∀j17∈cells17(), e17{j17} = E17{j17} - 0.5 * dot(uj17{j17}, uj17{j17});
ComputeEOSc17: ∀j17∈cells17(), c17{j17} = √(γ17*p17{j17}/ρ17{j17}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr17: ∀j17∈cells17(), ∀r17∈nodesOfCell17(j17), Ajr17{j17,r17} = ((ρ17{j17}*c17{j17})/l17{j17,r17}) * tensProduct17(C17{j17,r17}, C17{j17,r17});
ComputeFjr17: ∀j17∈cells17(), ∀r17∈nodesOfCell17(j17), F17{j17,r17} = p17{j17}*C17{j17,r17} + matVectProduct17(Ajr17{j17,r17}, (uj17{j17}-ur17{r17}));
ComputeAr17: ∀r17∈nodes17(), Ar17{r17} = ∑{j17∈cellsOfNode17(r17)}(Ajr17{j17,r17});
ComputeBr17: ∀r17∈nodes17(), b17{r17} = ∑{j17∈cellsOfNode17(r17)}(p17{j17}*C17{j17,r17} + matVectProduct17(Ajr17{j17,r17}, uj17{j17}));
ComputeMt17: ∀r17∈innerNodes17(), Mt17{r17} = Ar17{r17};
ComputeBt17: ∀r17∈innerNodes17(), bt17{r17} = b17{r17};

OuterFacesComputations17: ∀k17∈outerFaces17(), {
	const ℝ epsilon17 = 1.0e-10;
	ℝ²ˣ² I17 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN17 = 0.0;
	ℝ X_MAX17 = X_EDGE_ELEMS17 * LENGTH17;
	ℝ Y_MIN17 = 0.0; 
	ℝ Y_MAX17 = Y_EDGE_ELEMS17 * LENGTH17;
	ℝ² nY17 = {0.0,1.0};
	
	∀r17∈nodesOfFace17(k17), {
		// Y boundary conditions (must be done before X)
		if ((X17{r17}.y-Y_MIN17 < epsilon17) || (X17{r17}.y-Y_MAX17 < epsilon17)) {
			ℝ sign17 = 0.0;
			if (X17{r17}.y-Y_MIN17 < epsilon17) sign17 = -1.0;
			else sign17 = 1.0;
			ℝ² n17 = sign17 * nY17;
      		ℝ²ˣ² nxn17 = tensProduct17(n17,n17);
      		ℝ²ˣ² IcP17 = I17 - nxn17;
			bt1{r17} = matVectProduct17(IcP17, b17{r17});
			Mt1{r17} = IcP17 * (Ar17{r17} * IcP17) + nxn17*trace17(Ar17{r17});
		}

		// X boundary conditions
		if ((Math.fabs(X17{r17}.x-X_MIN17) < epsilon17) || ( (Math.fabs(X17{r17}.x-X_MAX17) < epsilon17) )) {
			Mt17{r17} = I17;
			bt17{r17} = {0.0, 0.0};
		}
	}
}


ComputeU17: ∀r17∈nodes17(), ur17{r17} = matVectProduct17(inverse17(Mt17{r17}), bt17{r17});
ComputeV17: ∀j17∈cells17(), V17{j17} = 0.5 * ∑{r17∈nodesOfCell17(j17)}(dot(C17{j17,r17},X17{r17}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn17: ∀n17∈ℕ, ∀r017∈nodes17(), X17{r017}^{n17=0}=coord17{r017}; , ∀r17∈nodes17(), X17{r17}^{n17+1}=X17{r17}^{n17}+δt17^{n17}*ur17{r17};
ComputeUn17: ∀n17∈ℕ, ∀j017∈cells17(), uj17{j017}^{n17=0}={0.0,0.0}; , ∀j17∈cells17(), uj17{j17}^{n17+1}=uj17{j17}^{n17}-(δt17^{n17}/m17{j17})*∑{r17∈nodesOfCell17(j17)}(F17{j17,r17});
ComputeEn17: ∀n17∈ℕ, ∀j017∈cells17(), E17{j017}^{n17=0}=p_ic17{j017}/((γ17-1.0)*ρ_ic17{j017}); , ∀j17∈cells17(), E17{j17}^{n17+1}=E17{j17}^{n17} - (δt17^{n17} / m17{j17}) * ∑{r17∈nodesOfCell17(j17)}(dot(F17{j17,r17},ur17{r17}));
ComputeDt17: ∀n17∈ℕ, δt17^{n17=0}=option_δt_ini17;, δt17^{n17+1}=option_δt_cfl17*reduceMin{j17∈cells17()}(δtj17{j17});
ComputeTn17: ∀n17∈ℕ, t17^{n17=0}=0.0; , t17^{n17+1}=t17^{n17}+δt17^{n17+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter18: ∀j18∈cells18(), center18{j18} = (1.0/4.0) * ∑{r18∈nodesOfCell18(j18)}(coord18{r18});
IniIc18: ∀j18∈cells18(), if (center18{j18}.x < option_x_interface18) {
  ρ_ic18{j18}=option_ρ_ini_zg18;
  p_ic18{j18}=option_p_ini_zg18;
} else {
  ρ_ic18{j18}=option_ρ_ini_zd18;
  p_ic18{j18}=option_p_ini_zd18;
}

ComputeCjrIc18: ∀j18∈cells18(), ∀r18∈nodesOfCell18(j18), 
	C_ic18{j18,r18} = 0.5 * perp18(coord18{►(r18)} - coord18{◄(r18)});
IniVIc18: ∀j18∈cells18(), V_ic18{j18} = 0.5 * ∑{r18∈nodesOfCell18(j18)}(dot(C_ic18{j18,r18}, coord18{r18}));
IniM18: ∀j18∈cells18(), m18{j18} = ρ_ic18{j18} * V_ic18{j18}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr18: ∀j18∈cells18(), ∀r18∈nodesOfCell18(j18), C18{j18,r18} = 0.5 * perp18(X18{►(r18)} - X18{◄(r18)});
ComputeLjr18: ∀j18∈cells18(), ∀r18∈nodesOfCell18(j18), l18{j18,r18} = norm(C18{j18,r18});
Computeδtj18: ∀j18∈cells18(), δtj18{j18} = 2.0 * V18{j18} / (c18{j18} * ∑{r18∈nodesOfCell18(j18)}(l18{j18,r18}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity18: ∀j18∈cells18(), ρ18{j18} = m18{j18} / V18{j18};
ComputeEOSp18: ∀j18∈cells18(), p18{j18} = (γ18-1.0) * ρ18{j18} * e18{j18};
ComputeInternalEngergy18: ∀j18∈cells18(), e18{j18} = E18{j18} - 0.5 * dot(uj18{j18}, uj18{j18});
ComputeEOSc18: ∀j18∈cells18(), c18{j18} = √(γ18*p18{j18}/ρ18{j18}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr18: ∀j18∈cells18(), ∀r18∈nodesOfCell18(j18), Ajr18{j18,r18} = ((ρ18{j18}*c18{j18})/l18{j18,r18}) * tensProduct18(C18{j18,r18}, C18{j18,r18});
ComputeFjr18: ∀j18∈cells18(), ∀r18∈nodesOfCell18(j18), F18{j18,r18} = p18{j18}*C18{j18,r18} + matVectProduct18(Ajr18{j18,r18}, (uj18{j18}-ur18{r18}));
ComputeAr18: ∀r18∈nodes18(), Ar18{r18} = ∑{j18∈cellsOfNode18(r18)}(Ajr18{j18,r18});
ComputeBr18: ∀r18∈nodes18(), b18{r18} = ∑{j18∈cellsOfNode18(r18)}(p18{j18}*C18{j18,r18} + matVectProduct18(Ajr18{j18,r18}, uj18{j18}));
ComputeMt18: ∀r18∈innerNodes18(), Mt18{r18} = Ar18{r18};
ComputeBt18: ∀r18∈innerNodes18(), bt18{r18} = b18{r18};

OuterFacesComputations18: ∀k18∈outerFaces18(), {
	const ℝ epsilon18 = 1.0e-10;
	ℝ²ˣ² I18 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN18 = 0.0;
	ℝ X_MAX18 = X_EDGE_ELEMS18 * LENGTH18;
	ℝ Y_MIN18 = 0.0; 
	ℝ Y_MAX18 = Y_EDGE_ELEMS18 * LENGTH18;
	ℝ² nY18 = {0.0,1.0};
	
	∀r18∈nodesOfFace18(k18), {
		// Y boundary conditions (must be done before X)
		if ((X18{r18}.y-Y_MIN18 < epsilon18) || (X18{r18}.y-Y_MAX18 < epsilon18)) {
			ℝ sign18 = 0.0;
			if (X18{r18}.y-Y_MIN18 < epsilon18) sign18 = -1.0;
			else sign18 = 1.0;
			ℝ² n18 = sign18 * nY18;
      		ℝ²ˣ² nxn18 = tensProduct18(n18,n18);
      		ℝ²ˣ² IcP18 = I18 - nxn18;
			bt1{r18} = matVectProduct18(IcP18, b18{r18});
			Mt1{r18} = IcP18 * (Ar18{r18} * IcP18) + nxn18*trace18(Ar18{r18});
		}

		// X boundary conditions
		if ((Math.fabs(X18{r18}.x-X_MIN18) < epsilon18) || ( (Math.fabs(X18{r18}.x-X_MAX18) < epsilon18) )) {
			Mt18{r18} = I18;
			bt18{r18} = {0.0, 0.0};
		}
	}
}


ComputeU18: ∀r18∈nodes18(), ur18{r18} = matVectProduct18(inverse18(Mt18{r18}), bt18{r18});
ComputeV18: ∀j18∈cells18(), V18{j18} = 0.5 * ∑{r18∈nodesOfCell18(j18)}(dot(C18{j18,r18},X18{r18}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn18: ∀n18∈ℕ, ∀r018∈nodes18(), X18{r018}^{n18=0}=coord18{r018}; , ∀r18∈nodes18(), X18{r18}^{n18+1}=X18{r18}^{n18}+δt18^{n18}*ur18{r18};
ComputeUn18: ∀n18∈ℕ, ∀j018∈cells18(), uj18{j018}^{n18=0}={0.0,0.0}; , ∀j18∈cells18(), uj18{j18}^{n18+1}=uj18{j18}^{n18}-(δt18^{n18}/m18{j18})*∑{r18∈nodesOfCell18(j18)}(F18{j18,r18});
ComputeEn18: ∀n18∈ℕ, ∀j018∈cells18(), E18{j018}^{n18=0}=p_ic18{j018}/((γ18-1.0)*ρ_ic18{j018}); , ∀j18∈cells18(), E18{j18}^{n18+1}=E18{j18}^{n18} - (δt18^{n18} / m18{j18}) * ∑{r18∈nodesOfCell18(j18)}(dot(F18{j18,r18},ur18{r18}));
ComputeDt18: ∀n18∈ℕ, δt18^{n18=0}=option_δt_ini18;, δt18^{n18+1}=option_δt_cfl18*reduceMin{j18∈cells18()}(δtj18{j18});
ComputeTn18: ∀n18∈ℕ, t18^{n18=0}=0.0; , t18^{n18+1}=t18^{n18}+δt18^{n18+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter19: ∀j19∈cells19(), center19{j19} = (1.0/4.0) * ∑{r19∈nodesOfCell19(j19)}(coord19{r19});
IniIc19: ∀j19∈cells19(), if (center19{j19}.x < option_x_interface19) {
  ρ_ic19{j19}=option_ρ_ini_zg19;
  p_ic19{j19}=option_p_ini_zg19;
} else {
  ρ_ic19{j19}=option_ρ_ini_zd19;
  p_ic19{j19}=option_p_ini_zd19;
}

ComputeCjrIc19: ∀j19∈cells19(), ∀r19∈nodesOfCell19(j19), 
	C_ic19{j19,r19} = 0.5 * perp19(coord19{►(r19)} - coord19{◄(r19)});
IniVIc19: ∀j19∈cells19(), V_ic19{j19} = 0.5 * ∑{r19∈nodesOfCell19(j19)}(dot(C_ic19{j19,r19}, coord19{r19}));
IniM19: ∀j19∈cells19(), m19{j19} = ρ_ic19{j19} * V_ic19{j19}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr19: ∀j19∈cells19(), ∀r19∈nodesOfCell19(j19), C19{j19,r19} = 0.5 * perp19(X19{►(r19)} - X19{◄(r19)});
ComputeLjr19: ∀j19∈cells19(), ∀r19∈nodesOfCell19(j19), l19{j19,r19} = norm(C19{j19,r19});
Computeδtj19: ∀j19∈cells19(), δtj19{j19} = 2.0 * V19{j19} / (c19{j19} * ∑{r19∈nodesOfCell19(j19)}(l19{j19,r19}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity19: ∀j19∈cells19(), ρ19{j19} = m19{j19} / V19{j19};
ComputeEOSp19: ∀j19∈cells19(), p19{j19} = (γ19-1.0) * ρ19{j19} * e19{j19};
ComputeInternalEngergy19: ∀j19∈cells19(), e19{j19} = E19{j19} - 0.5 * dot(uj19{j19}, uj19{j19});
ComputeEOSc19: ∀j19∈cells19(), c19{j19} = √(γ19*p19{j19}/ρ19{j19}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr19: ∀j19∈cells19(), ∀r19∈nodesOfCell19(j19), Ajr19{j19,r19} = ((ρ19{j19}*c19{j19})/l19{j19,r19}) * tensProduct19(C19{j19,r19}, C19{j19,r19});
ComputeFjr19: ∀j19∈cells19(), ∀r19∈nodesOfCell19(j19), F19{j19,r19} = p19{j19}*C19{j19,r19} + matVectProduct19(Ajr19{j19,r19}, (uj19{j19}-ur19{r19}));
ComputeAr19: ∀r19∈nodes19(), Ar19{r19} = ∑{j19∈cellsOfNode19(r19)}(Ajr19{j19,r19});
ComputeBr19: ∀r19∈nodes19(), b19{r19} = ∑{j19∈cellsOfNode19(r19)}(p19{j19}*C19{j19,r19} + matVectProduct19(Ajr19{j19,r19}, uj19{j19}));
ComputeMt19: ∀r19∈innerNodes19(), Mt19{r19} = Ar19{r19};
ComputeBt19: ∀r19∈innerNodes19(), bt19{r19} = b19{r19};

OuterFacesComputations19: ∀k19∈outerFaces19(), {
	const ℝ epsilon19 = 1.0e-10;
	ℝ²ˣ² I19 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN19 = 0.0;
	ℝ X_MAX19 = X_EDGE_ELEMS19 * LENGTH19;
	ℝ Y_MIN19 = 0.0; 
	ℝ Y_MAX19 = Y_EDGE_ELEMS19 * LENGTH19;
	ℝ² nY19 = {0.0,1.0};
	
	∀r19∈nodesOfFace19(k19), {
		// Y boundary conditions (must be done before X)
		if ((X19{r19}.y-Y_MIN19 < epsilon19) || (X19{r19}.y-Y_MAX19 < epsilon19)) {
			ℝ sign19 = 0.0;
			if (X19{r19}.y-Y_MIN19 < epsilon19) sign19 = -1.0;
			else sign19 = 1.0;
			ℝ² n19 = sign19 * nY19;
      		ℝ²ˣ² nxn19 = tensProduct19(n19,n19);
      		ℝ²ˣ² IcP19 = I19 - nxn19;
			bt1{r19} = matVectProduct19(IcP19, b19{r19});
			Mt1{r19} = IcP19 * (Ar19{r19} * IcP19) + nxn19*trace19(Ar19{r19});
		}

		// X boundary conditions
		if ((Math.fabs(X19{r19}.x-X_MIN19) < epsilon19) || ( (Math.fabs(X19{r19}.x-X_MAX19) < epsilon19) )) {
			Mt19{r19} = I19;
			bt19{r19} = {0.0, 0.0};
		}
	}
}


ComputeU19: ∀r19∈nodes19(), ur19{r19} = matVectProduct19(inverse19(Mt19{r19}), bt19{r19});
ComputeV19: ∀j19∈cells19(), V19{j19} = 0.5 * ∑{r19∈nodesOfCell19(j19)}(dot(C19{j19,r19},X19{r19}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn19: ∀n19∈ℕ, ∀r019∈nodes19(), X19{r019}^{n19=0}=coord19{r019}; , ∀r19∈nodes19(), X19{r19}^{n19+1}=X19{r19}^{n19}+δt19^{n19}*ur19{r19};
ComputeUn19: ∀n19∈ℕ, ∀j019∈cells19(), uj19{j019}^{n19=0}={0.0,0.0}; , ∀j19∈cells19(), uj19{j19}^{n19+1}=uj19{j19}^{n19}-(δt19^{n19}/m19{j19})*∑{r19∈nodesOfCell19(j19)}(F19{j19,r19});
ComputeEn19: ∀n19∈ℕ, ∀j019∈cells19(), E19{j019}^{n19=0}=p_ic19{j019}/((γ19-1.0)*ρ_ic19{j019}); , ∀j19∈cells19(), E19{j19}^{n19+1}=E19{j19}^{n19} - (δt19^{n19} / m19{j19}) * ∑{r19∈nodesOfCell19(j19)}(dot(F19{j19,r19},ur19{r19}));
ComputeDt19: ∀n19∈ℕ, δt19^{n19=0}=option_δt_ini19;, δt19^{n19+1}=option_δt_cfl19*reduceMin{j19∈cells19()}(δtj19{j19});
ComputeTn19: ∀n19∈ℕ, t19^{n19=0}=0.0; , t19^{n19+1}=t19^{n19}+δt19^{n19+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter20: ∀j20∈cells20(), center20{j20} = (1.0/4.0) * ∑{r20∈nodesOfCell20(j20)}(coord20{r20});
IniIc20: ∀j20∈cells20(), if (center20{j20}.x < option_x_interface20) {
  ρ_ic20{j20}=option_ρ_ini_zg20;
  p_ic20{j20}=option_p_ini_zg20;
} else {
  ρ_ic20{j20}=option_ρ_ini_zd20;
  p_ic20{j20}=option_p_ini_zd20;
}

ComputeCjrIc20: ∀j20∈cells20(), ∀r20∈nodesOfCell20(j20), 
	C_ic20{j20,r20} = 0.5 * perp20(coord20{►(r20)} - coord20{◄(r20)});
IniVIc20: ∀j20∈cells20(), V_ic20{j20} = 0.5 * ∑{r20∈nodesOfCell20(j20)}(dot(C_ic20{j20,r20}, coord20{r20}));
IniM20: ∀j20∈cells20(), m20{j20} = ρ_ic20{j20} * V_ic20{j20}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr20: ∀j20∈cells20(), ∀r20∈nodesOfCell20(j20), C20{j20,r20} = 0.5 * perp20(X20{►(r20)} - X20{◄(r20)});
ComputeLjr20: ∀j20∈cells20(), ∀r20∈nodesOfCell20(j20), l20{j20,r20} = norm(C20{j20,r20});
Computeδtj20: ∀j20∈cells20(), δtj20{j20} = 2.0 * V20{j20} / (c20{j20} * ∑{r20∈nodesOfCell20(j20)}(l20{j20,r20}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity20: ∀j20∈cells20(), ρ20{j20} = m20{j20} / V20{j20};
ComputeEOSp20: ∀j20∈cells20(), p20{j20} = (γ20-1.0) * ρ20{j20} * e20{j20};
ComputeInternalEngergy20: ∀j20∈cells20(), e20{j20} = E20{j20} - 0.5 * dot(uj20{j20}, uj20{j20});
ComputeEOSc20: ∀j20∈cells20(), c20{j20} = √(γ20*p20{j20}/ρ20{j20}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr20: ∀j20∈cells20(), ∀r20∈nodesOfCell20(j20), Ajr20{j20,r20} = ((ρ20{j20}*c20{j20})/l20{j20,r20}) * tensProduct20(C20{j20,r20}, C20{j20,r20});
ComputeFjr20: ∀j20∈cells20(), ∀r20∈nodesOfCell20(j20), F20{j20,r20} = p20{j20}*C20{j20,r20} + matVectProduct20(Ajr20{j20,r20}, (uj20{j20}-ur20{r20}));
ComputeAr20: ∀r20∈nodes20(), Ar20{r20} = ∑{j20∈cellsOfNode20(r20)}(Ajr20{j20,r20});
ComputeBr20: ∀r20∈nodes20(), b20{r20} = ∑{j20∈cellsOfNode20(r20)}(p20{j20}*C20{j20,r20} + matVectProduct20(Ajr20{j20,r20}, uj20{j20}));
ComputeMt20: ∀r20∈innerNodes20(), Mt20{r20} = Ar20{r20};
ComputeBt20: ∀r20∈innerNodes20(), bt20{r20} = b20{r20};

OuterFacesComputations20: ∀k20∈outerFaces20(), {
	const ℝ epsilon20 = 1.0e-10;
	ℝ²ˣ² I20 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN20 = 0.0;
	ℝ X_MAX20 = X_EDGE_ELEMS20 * LENGTH20;
	ℝ Y_MIN20 = 0.0; 
	ℝ Y_MAX20 = Y_EDGE_ELEMS20 * LENGTH20;
	ℝ² nY20 = {0.0,1.0};
	
	∀r20∈nodesOfFace20(k20), {
		// Y boundary conditions (must be done before X)
		if ((X20{r20}.y-Y_MIN20 < epsilon20) || (X20{r20}.y-Y_MAX20 < epsilon20)) {
			ℝ sign20 = 0.0;
			if (X20{r20}.y-Y_MIN20 < epsilon20) sign20 = -1.0;
			else sign20 = 1.0;
			ℝ² n20 = sign20 * nY20;
      		ℝ²ˣ² nxn20 = tensProduct20(n20,n20);
      		ℝ²ˣ² IcP20 = I20 - nxn20;
			bt1{r20} = matVectProduct20(IcP20, b20{r20});
			Mt1{r20} = IcP20 * (Ar20{r20} * IcP20) + nxn20*trace20(Ar20{r20});
		}

		// X boundary conditions
		if ((Math.fabs(X20{r20}.x-X_MIN20) < epsilon20) || ( (Math.fabs(X20{r20}.x-X_MAX20) < epsilon20) )) {
			Mt20{r20} = I20;
			bt20{r20} = {0.0, 0.0};
		}
	}
}


ComputeU20: ∀r20∈nodes20(), ur20{r20} = matVectProduct20(inverse20(Mt20{r20}), bt20{r20});
ComputeV20: ∀j20∈cells20(), V20{j20} = 0.5 * ∑{r20∈nodesOfCell20(j20)}(dot(C20{j20,r20},X20{r20}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn20: ∀n20∈ℕ, ∀r020∈nodes20(), X20{r020}^{n20=0}=coord20{r020}; , ∀r20∈nodes20(), X20{r20}^{n20+1}=X20{r20}^{n20}+δt20^{n20}*ur20{r20};
ComputeUn20: ∀n20∈ℕ, ∀j020∈cells20(), uj20{j020}^{n20=0}={0.0,0.0}; , ∀j20∈cells20(), uj20{j20}^{n20+1}=uj20{j20}^{n20}-(δt20^{n20}/m20{j20})*∑{r20∈nodesOfCell20(j20)}(F20{j20,r20});
ComputeEn20: ∀n20∈ℕ, ∀j020∈cells20(), E20{j020}^{n20=0}=p_ic20{j020}/((γ20-1.0)*ρ_ic20{j020}); , ∀j20∈cells20(), E20{j20}^{n20+1}=E20{j20}^{n20} - (δt20^{n20} / m20{j20}) * ∑{r20∈nodesOfCell20(j20)}(dot(F20{j20,r20},ur20{r20}));
ComputeDt20: ∀n20∈ℕ, δt20^{n20=0}=option_δt_ini20;, δt20^{n20+1}=option_δt_cfl20*reduceMin{j20∈cells20()}(δtj20{j20});
ComputeTn20: ∀n20∈ℕ, t20^{n20=0}=0.0; , t20^{n20+1}=t20^{n20}+δt20^{n20+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter21: ∀j21∈cells21(), center21{j21} = (1.0/4.0) * ∑{r21∈nodesOfCell21(j21)}(coord21{r21});
IniIc21: ∀j21∈cells21(), if (center21{j21}.x < option_x_interface21) {
  ρ_ic21{j21}=option_ρ_ini_zg21;
  p_ic21{j21}=option_p_ini_zg21;
} else {
  ρ_ic21{j21}=option_ρ_ini_zd21;
  p_ic21{j21}=option_p_ini_zd21;
}

ComputeCjrIc21: ∀j21∈cells21(), ∀r21∈nodesOfCell21(j21), 
	C_ic21{j21,r21} = 0.5 * perp21(coord21{►(r21)} - coord21{◄(r21)});
IniVIc21: ∀j21∈cells21(), V_ic21{j21} = 0.5 * ∑{r21∈nodesOfCell21(j21)}(dot(C_ic21{j21,r21}, coord21{r21}));
IniM21: ∀j21∈cells21(), m21{j21} = ρ_ic21{j21} * V_ic21{j21}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr21: ∀j21∈cells21(), ∀r21∈nodesOfCell21(j21), C21{j21,r21} = 0.5 * perp21(X21{►(r21)} - X21{◄(r21)});
ComputeLjr21: ∀j21∈cells21(), ∀r21∈nodesOfCell21(j21), l21{j21,r21} = norm(C21{j21,r21});
Computeδtj21: ∀j21∈cells21(), δtj21{j21} = 2.0 * V21{j21} / (c21{j21} * ∑{r21∈nodesOfCell21(j21)}(l21{j21,r21}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity21: ∀j21∈cells21(), ρ21{j21} = m21{j21} / V21{j21};
ComputeEOSp21: ∀j21∈cells21(), p21{j21} = (γ21-1.0) * ρ21{j21} * e21{j21};
ComputeInternalEngergy21: ∀j21∈cells21(), e21{j21} = E21{j21} - 0.5 * dot(uj21{j21}, uj21{j21});
ComputeEOSc21: ∀j21∈cells21(), c21{j21} = √(γ21*p21{j21}/ρ21{j21}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr21: ∀j21∈cells21(), ∀r21∈nodesOfCell21(j21), Ajr21{j21,r21} = ((ρ21{j21}*c21{j21})/l21{j21,r21}) * tensProduct21(C21{j21,r21}, C21{j21,r21});
ComputeFjr21: ∀j21∈cells21(), ∀r21∈nodesOfCell21(j21), F21{j21,r21} = p21{j21}*C21{j21,r21} + matVectProduct21(Ajr21{j21,r21}, (uj21{j21}-ur21{r21}));
ComputeAr21: ∀r21∈nodes21(), Ar21{r21} = ∑{j21∈cellsOfNode21(r21)}(Ajr21{j21,r21});
ComputeBr21: ∀r21∈nodes21(), b21{r21} = ∑{j21∈cellsOfNode21(r21)}(p21{j21}*C21{j21,r21} + matVectProduct21(Ajr21{j21,r21}, uj21{j21}));
ComputeMt21: ∀r21∈innerNodes21(), Mt21{r21} = Ar21{r21};
ComputeBt21: ∀r21∈innerNodes21(), bt21{r21} = b21{r21};

OuterFacesComputations21: ∀k21∈outerFaces21(), {
	const ℝ epsilon21 = 1.0e-10;
	ℝ²ˣ² I21 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN21 = 0.0;
	ℝ X_MAX21 = X_EDGE_ELEMS21 * LENGTH21;
	ℝ Y_MIN21 = 0.0; 
	ℝ Y_MAX21 = Y_EDGE_ELEMS21 * LENGTH21;
	ℝ² nY21 = {0.0,1.0};
	
	∀r21∈nodesOfFace21(k21), {
		// Y boundary conditions (must be done before X)
		if ((X21{r21}.y-Y_MIN21 < epsilon21) || (X21{r21}.y-Y_MAX21 < epsilon21)) {
			ℝ sign21 = 0.0;
			if (X21{r21}.y-Y_MIN21 < epsilon21) sign21 = -1.0;
			else sign21 = 1.0;
			ℝ² n21 = sign21 * nY21;
      		ℝ²ˣ² nxn21 = tensProduct21(n21,n21);
      		ℝ²ˣ² IcP21 = I21 - nxn21;
			bt1{r21} = matVectProduct21(IcP21, b21{r21});
			Mt1{r21} = IcP21 * (Ar21{r21} * IcP21) + nxn21*trace21(Ar21{r21});
		}

		// X boundary conditions
		if ((Math.fabs(X21{r21}.x-X_MIN21) < epsilon21) || ( (Math.fabs(X21{r21}.x-X_MAX21) < epsilon21) )) {
			Mt21{r21} = I21;
			bt21{r21} = {0.0, 0.0};
		}
	}
}


ComputeU21: ∀r21∈nodes21(), ur21{r21} = matVectProduct21(inverse21(Mt21{r21}), bt21{r21});
ComputeV21: ∀j21∈cells21(), V21{j21} = 0.5 * ∑{r21∈nodesOfCell21(j21)}(dot(C21{j21,r21},X21{r21}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn21: ∀n21∈ℕ, ∀r021∈nodes21(), X21{r021}^{n21=0}=coord21{r021}; , ∀r21∈nodes21(), X21{r21}^{n21+1}=X21{r21}^{n21}+δt21^{n21}*ur21{r21};
ComputeUn21: ∀n21∈ℕ, ∀j021∈cells21(), uj21{j021}^{n21=0}={0.0,0.0}; , ∀j21∈cells21(), uj21{j21}^{n21+1}=uj21{j21}^{n21}-(δt21^{n21}/m21{j21})*∑{r21∈nodesOfCell21(j21)}(F21{j21,r21});
ComputeEn21: ∀n21∈ℕ, ∀j021∈cells21(), E21{j021}^{n21=0}=p_ic21{j021}/((γ21-1.0)*ρ_ic21{j021}); , ∀j21∈cells21(), E21{j21}^{n21+1}=E21{j21}^{n21} - (δt21^{n21} / m21{j21}) * ∑{r21∈nodesOfCell21(j21)}(dot(F21{j21,r21},ur21{r21}));
ComputeDt21: ∀n21∈ℕ, δt21^{n21=0}=option_δt_ini21;, δt21^{n21+1}=option_δt_cfl21*reduceMin{j21∈cells21()}(δtj21{j21});
ComputeTn21: ∀n21∈ℕ, t21^{n21=0}=0.0; , t21^{n21+1}=t21^{n21}+δt21^{n21+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter22: ∀j22∈cells22(), center22{j22} = (1.0/4.0) * ∑{r22∈nodesOfCell22(j22)}(coord22{r22});
IniIc22: ∀j22∈cells22(), if (center22{j22}.x < option_x_interface22) {
  ρ_ic22{j22}=option_ρ_ini_zg22;
  p_ic22{j22}=option_p_ini_zg22;
} else {
  ρ_ic22{j22}=option_ρ_ini_zd22;
  p_ic22{j22}=option_p_ini_zd22;
}

ComputeCjrIc22: ∀j22∈cells22(), ∀r22∈nodesOfCell22(j22), 
	C_ic22{j22,r22} = 0.5 * perp22(coord22{►(r22)} - coord22{◄(r22)});
IniVIc22: ∀j22∈cells22(), V_ic22{j22} = 0.5 * ∑{r22∈nodesOfCell22(j22)}(dot(C_ic22{j22,r22}, coord22{r22}));
IniM22: ∀j22∈cells22(), m22{j22} = ρ_ic22{j22} * V_ic22{j22}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr22: ∀j22∈cells22(), ∀r22∈nodesOfCell22(j22), C22{j22,r22} = 0.5 * perp22(X22{►(r22)} - X22{◄(r22)});
ComputeLjr22: ∀j22∈cells22(), ∀r22∈nodesOfCell22(j22), l22{j22,r22} = norm(C22{j22,r22});
Computeδtj22: ∀j22∈cells22(), δtj22{j22} = 2.0 * V22{j22} / (c22{j22} * ∑{r22∈nodesOfCell22(j22)}(l22{j22,r22}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity22: ∀j22∈cells22(), ρ22{j22} = m22{j22} / V22{j22};
ComputeEOSp22: ∀j22∈cells22(), p22{j22} = (γ22-1.0) * ρ22{j22} * e22{j22};
ComputeInternalEngergy22: ∀j22∈cells22(), e22{j22} = E22{j22} - 0.5 * dot(uj22{j22}, uj22{j22});
ComputeEOSc22: ∀j22∈cells22(), c22{j22} = √(γ22*p22{j22}/ρ22{j22}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr22: ∀j22∈cells22(), ∀r22∈nodesOfCell22(j22), Ajr22{j22,r22} = ((ρ22{j22}*c22{j22})/l22{j22,r22}) * tensProduct22(C22{j22,r22}, C22{j22,r22});
ComputeFjr22: ∀j22∈cells22(), ∀r22∈nodesOfCell22(j22), F22{j22,r22} = p22{j22}*C22{j22,r22} + matVectProduct22(Ajr22{j22,r22}, (uj22{j22}-ur22{r22}));
ComputeAr22: ∀r22∈nodes22(), Ar22{r22} = ∑{j22∈cellsOfNode22(r22)}(Ajr22{j22,r22});
ComputeBr22: ∀r22∈nodes22(), b22{r22} = ∑{j22∈cellsOfNode22(r22)}(p22{j22}*C22{j22,r22} + matVectProduct22(Ajr22{j22,r22}, uj22{j22}));
ComputeMt22: ∀r22∈innerNodes22(), Mt22{r22} = Ar22{r22};
ComputeBt22: ∀r22∈innerNodes22(), bt22{r22} = b22{r22};

OuterFacesComputations22: ∀k22∈outerFaces22(), {
	const ℝ epsilon22 = 1.0e-10;
	ℝ²ˣ² I22 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN22 = 0.0;
	ℝ X_MAX22 = X_EDGE_ELEMS22 * LENGTH22;
	ℝ Y_MIN22 = 0.0; 
	ℝ Y_MAX22 = Y_EDGE_ELEMS22 * LENGTH22;
	ℝ² nY22 = {0.0,1.0};
	
	∀r22∈nodesOfFace22(k22), {
		// Y boundary conditions (must be done before X)
		if ((X22{r22}.y-Y_MIN22 < epsilon22) || (X22{r22}.y-Y_MAX22 < epsilon22)) {
			ℝ sign22 = 0.0;
			if (X22{r22}.y-Y_MIN22 < epsilon22) sign22 = -1.0;
			else sign22 = 1.0;
			ℝ² n22 = sign22 * nY22;
      		ℝ²ˣ² nxn22 = tensProduct22(n22,n22);
      		ℝ²ˣ² IcP22 = I22 - nxn22;
			bt1{r22} = matVectProduct22(IcP22, b22{r22});
			Mt1{r22} = IcP22 * (Ar22{r22} * IcP22) + nxn22*trace22(Ar22{r22});
		}

		// X boundary conditions
		if ((Math.fabs(X22{r22}.x-X_MIN22) < epsilon22) || ( (Math.fabs(X22{r22}.x-X_MAX22) < epsilon22) )) {
			Mt22{r22} = I22;
			bt22{r22} = {0.0, 0.0};
		}
	}
}


ComputeU22: ∀r22∈nodes22(), ur22{r22} = matVectProduct22(inverse22(Mt22{r22}), bt22{r22});
ComputeV22: ∀j22∈cells22(), V22{j22} = 0.5 * ∑{r22∈nodesOfCell22(j22)}(dot(C22{j22,r22},X22{r22}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn22: ∀n22∈ℕ, ∀r022∈nodes22(), X22{r022}^{n22=0}=coord22{r022}; , ∀r22∈nodes22(), X22{r22}^{n22+1}=X22{r22}^{n22}+δt22^{n22}*ur22{r22};
ComputeUn22: ∀n22∈ℕ, ∀j022∈cells22(), uj22{j022}^{n22=0}={0.0,0.0}; , ∀j22∈cells22(), uj22{j22}^{n22+1}=uj22{j22}^{n22}-(δt22^{n22}/m22{j22})*∑{r22∈nodesOfCell22(j22)}(F22{j22,r22});
ComputeEn22: ∀n22∈ℕ, ∀j022∈cells22(), E22{j022}^{n22=0}=p_ic22{j022}/((γ22-1.0)*ρ_ic22{j022}); , ∀j22∈cells22(), E22{j22}^{n22+1}=E22{j22}^{n22} - (δt22^{n22} / m22{j22}) * ∑{r22∈nodesOfCell22(j22)}(dot(F22{j22,r22},ur22{r22}));
ComputeDt22: ∀n22∈ℕ, δt22^{n22=0}=option_δt_ini22;, δt22^{n22+1}=option_δt_cfl22*reduceMin{j22∈cells22()}(δtj22{j22});
ComputeTn22: ∀n22∈ℕ, t22^{n22=0}=0.0; , t22^{n22+1}=t22^{n22}+δt22^{n22+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter23: ∀j23∈cells23(), center23{j23} = (1.0/4.0) * ∑{r23∈nodesOfCell23(j23)}(coord23{r23});
IniIc23: ∀j23∈cells23(), if (center23{j23}.x < option_x_interface23) {
  ρ_ic23{j23}=option_ρ_ini_zg23;
  p_ic23{j23}=option_p_ini_zg23;
} else {
  ρ_ic23{j23}=option_ρ_ini_zd23;
  p_ic23{j23}=option_p_ini_zd23;
}

ComputeCjrIc23: ∀j23∈cells23(), ∀r23∈nodesOfCell23(j23), 
	C_ic23{j23,r23} = 0.5 * perp23(coord23{►(r23)} - coord23{◄(r23)});
IniVIc23: ∀j23∈cells23(), V_ic23{j23} = 0.5 * ∑{r23∈nodesOfCell23(j23)}(dot(C_ic23{j23,r23}, coord23{r23}));
IniM23: ∀j23∈cells23(), m23{j23} = ρ_ic23{j23} * V_ic23{j23}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr23: ∀j23∈cells23(), ∀r23∈nodesOfCell23(j23), C23{j23,r23} = 0.5 * perp23(X23{►(r23)} - X23{◄(r23)});
ComputeLjr23: ∀j23∈cells23(), ∀r23∈nodesOfCell23(j23), l23{j23,r23} = norm(C23{j23,r23});
Computeδtj23: ∀j23∈cells23(), δtj23{j23} = 2.0 * V23{j23} / (c23{j23} * ∑{r23∈nodesOfCell23(j23)}(l23{j23,r23}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity23: ∀j23∈cells23(), ρ23{j23} = m23{j23} / V23{j23};
ComputeEOSp23: ∀j23∈cells23(), p23{j23} = (γ23-1.0) * ρ23{j23} * e23{j23};
ComputeInternalEngergy23: ∀j23∈cells23(), e23{j23} = E23{j23} - 0.5 * dot(uj23{j23}, uj23{j23});
ComputeEOSc23: ∀j23∈cells23(), c23{j23} = √(γ23*p23{j23}/ρ23{j23}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr23: ∀j23∈cells23(), ∀r23∈nodesOfCell23(j23), Ajr23{j23,r23} = ((ρ23{j23}*c23{j23})/l23{j23,r23}) * tensProduct23(C23{j23,r23}, C23{j23,r23});
ComputeFjr23: ∀j23∈cells23(), ∀r23∈nodesOfCell23(j23), F23{j23,r23} = p23{j23}*C23{j23,r23} + matVectProduct23(Ajr23{j23,r23}, (uj23{j23}-ur23{r23}));
ComputeAr23: ∀r23∈nodes23(), Ar23{r23} = ∑{j23∈cellsOfNode23(r23)}(Ajr23{j23,r23});
ComputeBr23: ∀r23∈nodes23(), b23{r23} = ∑{j23∈cellsOfNode23(r23)}(p23{j23}*C23{j23,r23} + matVectProduct23(Ajr23{j23,r23}, uj23{j23}));
ComputeMt23: ∀r23∈innerNodes23(), Mt23{r23} = Ar23{r23};
ComputeBt23: ∀r23∈innerNodes23(), bt23{r23} = b23{r23};

OuterFacesComputations23: ∀k23∈outerFaces23(), {
	const ℝ epsilon23 = 1.0e-10;
	ℝ²ˣ² I23 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN23 = 0.0;
	ℝ X_MAX23 = X_EDGE_ELEMS23 * LENGTH23;
	ℝ Y_MIN23 = 0.0; 
	ℝ Y_MAX23 = Y_EDGE_ELEMS23 * LENGTH23;
	ℝ² nY23 = {0.0,1.0};
	
	∀r23∈nodesOfFace23(k23), {
		// Y boundary conditions (must be done before X)
		if ((X23{r23}.y-Y_MIN23 < epsilon23) || (X23{r23}.y-Y_MAX23 < epsilon23)) {
			ℝ sign23 = 0.0;
			if (X23{r23}.y-Y_MIN23 < epsilon23) sign23 = -1.0;
			else sign23 = 1.0;
			ℝ² n23 = sign23 * nY23;
      		ℝ²ˣ² nxn23 = tensProduct23(n23,n23);
      		ℝ²ˣ² IcP23 = I23 - nxn23;
			bt1{r23} = matVectProduct23(IcP23, b23{r23});
			Mt1{r23} = IcP23 * (Ar23{r23} * IcP23) + nxn23*trace23(Ar23{r23});
		}

		// X boundary conditions
		if ((Math.fabs(X23{r23}.x-X_MIN23) < epsilon23) || ( (Math.fabs(X23{r23}.x-X_MAX23) < epsilon23) )) {
			Mt23{r23} = I23;
			bt23{r23} = {0.0, 0.0};
		}
	}
}


ComputeU23: ∀r23∈nodes23(), ur23{r23} = matVectProduct23(inverse23(Mt23{r23}), bt23{r23});
ComputeV23: ∀j23∈cells23(), V23{j23} = 0.5 * ∑{r23∈nodesOfCell23(j23)}(dot(C23{j23,r23},X23{r23}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn23: ∀n23∈ℕ, ∀r023∈nodes23(), X23{r023}^{n23=0}=coord23{r023}; , ∀r23∈nodes23(), X23{r23}^{n23+1}=X23{r23}^{n23}+δt23^{n23}*ur23{r23};
ComputeUn23: ∀n23∈ℕ, ∀j023∈cells23(), uj23{j023}^{n23=0}={0.0,0.0}; , ∀j23∈cells23(), uj23{j23}^{n23+1}=uj23{j23}^{n23}-(δt23^{n23}/m23{j23})*∑{r23∈nodesOfCell23(j23)}(F23{j23,r23});
ComputeEn23: ∀n23∈ℕ, ∀j023∈cells23(), E23{j023}^{n23=0}=p_ic23{j023}/((γ23-1.0)*ρ_ic23{j023}); , ∀j23∈cells23(), E23{j23}^{n23+1}=E23{j23}^{n23} - (δt23^{n23} / m23{j23}) * ∑{r23∈nodesOfCell23(j23)}(dot(F23{j23,r23},ur23{r23}));
ComputeDt23: ∀n23∈ℕ, δt23^{n23=0}=option_δt_ini23;, δt23^{n23+1}=option_δt_cfl23*reduceMin{j23∈cells23()}(δtj23{j23});
ComputeTn23: ∀n23∈ℕ, t23^{n23=0}=0.0; , t23^{n23+1}=t23^{n23}+δt23^{n23+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter24: ∀j24∈cells24(), center24{j24} = (1.0/4.0) * ∑{r24∈nodesOfCell24(j24)}(coord24{r24});
IniIc24: ∀j24∈cells24(), if (center24{j24}.x < option_x_interface24) {
  ρ_ic24{j24}=option_ρ_ini_zg24;
  p_ic24{j24}=option_p_ini_zg24;
} else {
  ρ_ic24{j24}=option_ρ_ini_zd24;
  p_ic24{j24}=option_p_ini_zd24;
}

ComputeCjrIc24: ∀j24∈cells24(), ∀r24∈nodesOfCell24(j24), 
	C_ic24{j24,r24} = 0.5 * perp24(coord24{►(r24)} - coord24{◄(r24)});
IniVIc24: ∀j24∈cells24(), V_ic24{j24} = 0.5 * ∑{r24∈nodesOfCell24(j24)}(dot(C_ic24{j24,r24}, coord24{r24}));
IniM24: ∀j24∈cells24(), m24{j24} = ρ_ic24{j24} * V_ic24{j24}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr24: ∀j24∈cells24(), ∀r24∈nodesOfCell24(j24), C24{j24,r24} = 0.5 * perp24(X24{►(r24)} - X24{◄(r24)});
ComputeLjr24: ∀j24∈cells24(), ∀r24∈nodesOfCell24(j24), l24{j24,r24} = norm(C24{j24,r24});
Computeδtj24: ∀j24∈cells24(), δtj24{j24} = 2.0 * V24{j24} / (c24{j24} * ∑{r24∈nodesOfCell24(j24)}(l24{j24,r24}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity24: ∀j24∈cells24(), ρ24{j24} = m24{j24} / V24{j24};
ComputeEOSp24: ∀j24∈cells24(), p24{j24} = (γ24-1.0) * ρ24{j24} * e24{j24};
ComputeInternalEngergy24: ∀j24∈cells24(), e24{j24} = E24{j24} - 0.5 * dot(uj24{j24}, uj24{j24});
ComputeEOSc24: ∀j24∈cells24(), c24{j24} = √(γ24*p24{j24}/ρ24{j24}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr24: ∀j24∈cells24(), ∀r24∈nodesOfCell24(j24), Ajr24{j24,r24} = ((ρ24{j24}*c24{j24})/l24{j24,r24}) * tensProduct24(C24{j24,r24}, C24{j24,r24});
ComputeFjr24: ∀j24∈cells24(), ∀r24∈nodesOfCell24(j24), F24{j24,r24} = p24{j24}*C24{j24,r24} + matVectProduct24(Ajr24{j24,r24}, (uj24{j24}-ur24{r24}));
ComputeAr24: ∀r24∈nodes24(), Ar24{r24} = ∑{j24∈cellsOfNode24(r24)}(Ajr24{j24,r24});
ComputeBr24: ∀r24∈nodes24(), b24{r24} = ∑{j24∈cellsOfNode24(r24)}(p24{j24}*C24{j24,r24} + matVectProduct24(Ajr24{j24,r24}, uj24{j24}));
ComputeMt24: ∀r24∈innerNodes24(), Mt24{r24} = Ar24{r24};
ComputeBt24: ∀r24∈innerNodes24(), bt24{r24} = b24{r24};

OuterFacesComputations24: ∀k24∈outerFaces24(), {
	const ℝ epsilon24 = 1.0e-10;
	ℝ²ˣ² I24 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN24 = 0.0;
	ℝ X_MAX24 = X_EDGE_ELEMS24 * LENGTH24;
	ℝ Y_MIN24 = 0.0; 
	ℝ Y_MAX24 = Y_EDGE_ELEMS24 * LENGTH24;
	ℝ² nY24 = {0.0,1.0};
	
	∀r24∈nodesOfFace24(k24), {
		// Y boundary conditions (must be done before X)
		if ((X24{r24}.y-Y_MIN24 < epsilon24) || (X24{r24}.y-Y_MAX24 < epsilon24)) {
			ℝ sign24 = 0.0;
			if (X24{r24}.y-Y_MIN24 < epsilon24) sign24 = -1.0;
			else sign24 = 1.0;
			ℝ² n24 = sign24 * nY24;
      		ℝ²ˣ² nxn24 = tensProduct24(n24,n24);
      		ℝ²ˣ² IcP24 = I24 - nxn24;
			bt1{r24} = matVectProduct24(IcP24, b24{r24});
			Mt1{r24} = IcP24 * (Ar24{r24} * IcP24) + nxn24*trace24(Ar24{r24});
		}

		// X boundary conditions
		if ((Math.fabs(X24{r24}.x-X_MIN24) < epsilon24) || ( (Math.fabs(X24{r24}.x-X_MAX24) < epsilon24) )) {
			Mt24{r24} = I24;
			bt24{r24} = {0.0, 0.0};
		}
	}
}


ComputeU24: ∀r24∈nodes24(), ur24{r24} = matVectProduct24(inverse24(Mt24{r24}), bt24{r24});
ComputeV24: ∀j24∈cells24(), V24{j24} = 0.5 * ∑{r24∈nodesOfCell24(j24)}(dot(C24{j24,r24},X24{r24}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn24: ∀n24∈ℕ, ∀r024∈nodes24(), X24{r024}^{n24=0}=coord24{r024}; , ∀r24∈nodes24(), X24{r24}^{n24+1}=X24{r24}^{n24}+δt24^{n24}*ur24{r24};
ComputeUn24: ∀n24∈ℕ, ∀j024∈cells24(), uj24{j024}^{n24=0}={0.0,0.0}; , ∀j24∈cells24(), uj24{j24}^{n24+1}=uj24{j24}^{n24}-(δt24^{n24}/m24{j24})*∑{r24∈nodesOfCell24(j24)}(F24{j24,r24});
ComputeEn24: ∀n24∈ℕ, ∀j024∈cells24(), E24{j024}^{n24=0}=p_ic24{j024}/((γ24-1.0)*ρ_ic24{j024}); , ∀j24∈cells24(), E24{j24}^{n24+1}=E24{j24}^{n24} - (δt24^{n24} / m24{j24}) * ∑{r24∈nodesOfCell24(j24)}(dot(F24{j24,r24},ur24{r24}));
ComputeDt24: ∀n24∈ℕ, δt24^{n24=0}=option_δt_ini24;, δt24^{n24+1}=option_δt_cfl24*reduceMin{j24∈cells24()}(δtj24{j24});
ComputeTn24: ∀n24∈ℕ, t24^{n24=0}=0.0; , t24^{n24+1}=t24^{n24}+δt24^{n24+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter25: ∀j25∈cells25(), center25{j25} = (1.0/4.0) * ∑{r25∈nodesOfCell25(j25)}(coord25{r25});
IniIc25: ∀j25∈cells25(), if (center25{j25}.x < option_x_interface25) {
  ρ_ic25{j25}=option_ρ_ini_zg25;
  p_ic25{j25}=option_p_ini_zg25;
} else {
  ρ_ic25{j25}=option_ρ_ini_zd25;
  p_ic25{j25}=option_p_ini_zd25;
}

ComputeCjrIc25: ∀j25∈cells25(), ∀r25∈nodesOfCell25(j25), 
	C_ic25{j25,r25} = 0.5 * perp25(coord25{►(r25)} - coord25{◄(r25)});
IniVIc25: ∀j25∈cells25(), V_ic25{j25} = 0.5 * ∑{r25∈nodesOfCell25(j25)}(dot(C_ic25{j25,r25}, coord25{r25}));
IniM25: ∀j25∈cells25(), m25{j25} = ρ_ic25{j25} * V_ic25{j25}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr25: ∀j25∈cells25(), ∀r25∈nodesOfCell25(j25), C25{j25,r25} = 0.5 * perp25(X25{►(r25)} - X25{◄(r25)});
ComputeLjr25: ∀j25∈cells25(), ∀r25∈nodesOfCell25(j25), l25{j25,r25} = norm(C25{j25,r25});
Computeδtj25: ∀j25∈cells25(), δtj25{j25} = 2.0 * V25{j25} / (c25{j25} * ∑{r25∈nodesOfCell25(j25)}(l25{j25,r25}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity25: ∀j25∈cells25(), ρ25{j25} = m25{j25} / V25{j25};
ComputeEOSp25: ∀j25∈cells25(), p25{j25} = (γ25-1.0) * ρ25{j25} * e25{j25};
ComputeInternalEngergy25: ∀j25∈cells25(), e25{j25} = E25{j25} - 0.5 * dot(uj25{j25}, uj25{j25});
ComputeEOSc25: ∀j25∈cells25(), c25{j25} = √(γ25*p25{j25}/ρ25{j25}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr25: ∀j25∈cells25(), ∀r25∈nodesOfCell25(j25), Ajr25{j25,r25} = ((ρ25{j25}*c25{j25})/l25{j25,r25}) * tensProduct25(C25{j25,r25}, C25{j25,r25});
ComputeFjr25: ∀j25∈cells25(), ∀r25∈nodesOfCell25(j25), F25{j25,r25} = p25{j25}*C25{j25,r25} + matVectProduct25(Ajr25{j25,r25}, (uj25{j25}-ur25{r25}));
ComputeAr25: ∀r25∈nodes25(), Ar25{r25} = ∑{j25∈cellsOfNode25(r25)}(Ajr25{j25,r25});
ComputeBr25: ∀r25∈nodes25(), b25{r25} = ∑{j25∈cellsOfNode25(r25)}(p25{j25}*C25{j25,r25} + matVectProduct25(Ajr25{j25,r25}, uj25{j25}));
ComputeMt25: ∀r25∈innerNodes25(), Mt25{r25} = Ar25{r25};
ComputeBt25: ∀r25∈innerNodes25(), bt25{r25} = b25{r25};

OuterFacesComputations25: ∀k25∈outerFaces25(), {
	const ℝ epsilon25 = 1.0e-10;
	ℝ²ˣ² I25 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN25 = 0.0;
	ℝ X_MAX25 = X_EDGE_ELEMS25 * LENGTH25;
	ℝ Y_MIN25 = 0.0; 
	ℝ Y_MAX25 = Y_EDGE_ELEMS25 * LENGTH25;
	ℝ² nY25 = {0.0,1.0};
	
	∀r25∈nodesOfFace25(k25), {
		// Y boundary conditions (must be done before X)
		if ((X25{r25}.y-Y_MIN25 < epsilon25) || (X25{r25}.y-Y_MAX25 < epsilon25)) {
			ℝ sign25 = 0.0;
			if (X25{r25}.y-Y_MIN25 < epsilon25) sign25 = -1.0;
			else sign25 = 1.0;
			ℝ² n25 = sign25 * nY25;
      		ℝ²ˣ² nxn25 = tensProduct25(n25,n25);
      		ℝ²ˣ² IcP25 = I25 - nxn25;
			bt1{r25} = matVectProduct25(IcP25, b25{r25});
			Mt1{r25} = IcP25 * (Ar25{r25} * IcP25) + nxn25*trace25(Ar25{r25});
		}

		// X boundary conditions
		if ((Math.fabs(X25{r25}.x-X_MIN25) < epsilon25) || ( (Math.fabs(X25{r25}.x-X_MAX25) < epsilon25) )) {
			Mt25{r25} = I25;
			bt25{r25} = {0.0, 0.0};
		}
	}
}


ComputeU25: ∀r25∈nodes25(), ur25{r25} = matVectProduct25(inverse25(Mt25{r25}), bt25{r25});
ComputeV25: ∀j25∈cells25(), V25{j25} = 0.5 * ∑{r25∈nodesOfCell25(j25)}(dot(C25{j25,r25},X25{r25}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn25: ∀n25∈ℕ, ∀r025∈nodes25(), X25{r025}^{n25=0}=coord25{r025}; , ∀r25∈nodes25(), X25{r25}^{n25+1}=X25{r25}^{n25}+δt25^{n25}*ur25{r25};
ComputeUn25: ∀n25∈ℕ, ∀j025∈cells25(), uj25{j025}^{n25=0}={0.0,0.0}; , ∀j25∈cells25(), uj25{j25}^{n25+1}=uj25{j25}^{n25}-(δt25^{n25}/m25{j25})*∑{r25∈nodesOfCell25(j25)}(F25{j25,r25});
ComputeEn25: ∀n25∈ℕ, ∀j025∈cells25(), E25{j025}^{n25=0}=p_ic25{j025}/((γ25-1.0)*ρ_ic25{j025}); , ∀j25∈cells25(), E25{j25}^{n25+1}=E25{j25}^{n25} - (δt25^{n25} / m25{j25}) * ∑{r25∈nodesOfCell25(j25)}(dot(F25{j25,r25},ur25{r25}));
ComputeDt25: ∀n25∈ℕ, δt25^{n25=0}=option_δt_ini25;, δt25^{n25+1}=option_δt_cfl25*reduceMin{j25∈cells25()}(δtj25{j25});
ComputeTn25: ∀n25∈ℕ, t25^{n25=0}=0.0; , t25^{n25+1}=t25^{n25}+δt25^{n25+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter26: ∀j26∈cells26(), center26{j26} = (1.0/4.0) * ∑{r26∈nodesOfCell26(j26)}(coord26{r26});
IniIc26: ∀j26∈cells26(), if (center26{j26}.x < option_x_interface26) {
  ρ_ic26{j26}=option_ρ_ini_zg26;
  p_ic26{j26}=option_p_ini_zg26;
} else {
  ρ_ic26{j26}=option_ρ_ini_zd26;
  p_ic26{j26}=option_p_ini_zd26;
}

ComputeCjrIc26: ∀j26∈cells26(), ∀r26∈nodesOfCell26(j26), 
	C_ic26{j26,r26} = 0.5 * perp26(coord26{►(r26)} - coord26{◄(r26)});
IniVIc26: ∀j26∈cells26(), V_ic26{j26} = 0.5 * ∑{r26∈nodesOfCell26(j26)}(dot(C_ic26{j26,r26}, coord26{r26}));
IniM26: ∀j26∈cells26(), m26{j26} = ρ_ic26{j26} * V_ic26{j26}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr26: ∀j26∈cells26(), ∀r26∈nodesOfCell26(j26), C26{j26,r26} = 0.5 * perp26(X26{►(r26)} - X26{◄(r26)});
ComputeLjr26: ∀j26∈cells26(), ∀r26∈nodesOfCell26(j26), l26{j26,r26} = norm(C26{j26,r26});
Computeδtj26: ∀j26∈cells26(), δtj26{j26} = 2.0 * V26{j26} / (c26{j26} * ∑{r26∈nodesOfCell26(j26)}(l26{j26,r26}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity26: ∀j26∈cells26(), ρ26{j26} = m26{j26} / V26{j26};
ComputeEOSp26: ∀j26∈cells26(), p26{j26} = (γ26-1.0) * ρ26{j26} * e26{j26};
ComputeInternalEngergy26: ∀j26∈cells26(), e26{j26} = E26{j26} - 0.5 * dot(uj26{j26}, uj26{j26});
ComputeEOSc26: ∀j26∈cells26(), c26{j26} = √(γ26*p26{j26}/ρ26{j26}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr26: ∀j26∈cells26(), ∀r26∈nodesOfCell26(j26), Ajr26{j26,r26} = ((ρ26{j26}*c26{j26})/l26{j26,r26}) * tensProduct26(C26{j26,r26}, C26{j26,r26});
ComputeFjr26: ∀j26∈cells26(), ∀r26∈nodesOfCell26(j26), F26{j26,r26} = p26{j26}*C26{j26,r26} + matVectProduct26(Ajr26{j26,r26}, (uj26{j26}-ur26{r26}));
ComputeAr26: ∀r26∈nodes26(), Ar26{r26} = ∑{j26∈cellsOfNode26(r26)}(Ajr26{j26,r26});
ComputeBr26: ∀r26∈nodes26(), b26{r26} = ∑{j26∈cellsOfNode26(r26)}(p26{j26}*C26{j26,r26} + matVectProduct26(Ajr26{j26,r26}, uj26{j26}));
ComputeMt26: ∀r26∈innerNodes26(), Mt26{r26} = Ar26{r26};
ComputeBt26: ∀r26∈innerNodes26(), bt26{r26} = b26{r26};

OuterFacesComputations26: ∀k26∈outerFaces26(), {
	const ℝ epsilon26 = 1.0e-10;
	ℝ²ˣ² I26 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN26 = 0.0;
	ℝ X_MAX26 = X_EDGE_ELEMS26 * LENGTH26;
	ℝ Y_MIN26 = 0.0; 
	ℝ Y_MAX26 = Y_EDGE_ELEMS26 * LENGTH26;
	ℝ² nY26 = {0.0,1.0};
	
	∀r26∈nodesOfFace26(k26), {
		// Y boundary conditions (must be done before X)
		if ((X26{r26}.y-Y_MIN26 < epsilon26) || (X26{r26}.y-Y_MAX26 < epsilon26)) {
			ℝ sign26 = 0.0;
			if (X26{r26}.y-Y_MIN26 < epsilon26) sign26 = -1.0;
			else sign26 = 1.0;
			ℝ² n26 = sign26 * nY26;
      		ℝ²ˣ² nxn26 = tensProduct26(n26,n26);
      		ℝ²ˣ² IcP26 = I26 - nxn26;
			bt1{r26} = matVectProduct26(IcP26, b26{r26});
			Mt1{r26} = IcP26 * (Ar26{r26} * IcP26) + nxn26*trace26(Ar26{r26});
		}

		// X boundary conditions
		if ((Math.fabs(X26{r26}.x-X_MIN26) < epsilon26) || ( (Math.fabs(X26{r26}.x-X_MAX26) < epsilon26) )) {
			Mt26{r26} = I26;
			bt26{r26} = {0.0, 0.0};
		}
	}
}


ComputeU26: ∀r26∈nodes26(), ur26{r26} = matVectProduct26(inverse26(Mt26{r26}), bt26{r26});
ComputeV26: ∀j26∈cells26(), V26{j26} = 0.5 * ∑{r26∈nodesOfCell26(j26)}(dot(C26{j26,r26},X26{r26}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn26: ∀n26∈ℕ, ∀r026∈nodes26(), X26{r026}^{n26=0}=coord26{r026}; , ∀r26∈nodes26(), X26{r26}^{n26+1}=X26{r26}^{n26}+δt26^{n26}*ur26{r26};
ComputeUn26: ∀n26∈ℕ, ∀j026∈cells26(), uj26{j026}^{n26=0}={0.0,0.0}; , ∀j26∈cells26(), uj26{j26}^{n26+1}=uj26{j26}^{n26}-(δt26^{n26}/m26{j26})*∑{r26∈nodesOfCell26(j26)}(F26{j26,r26});
ComputeEn26: ∀n26∈ℕ, ∀j026∈cells26(), E26{j026}^{n26=0}=p_ic26{j026}/((γ26-1.0)*ρ_ic26{j026}); , ∀j26∈cells26(), E26{j26}^{n26+1}=E26{j26}^{n26} - (δt26^{n26} / m26{j26}) * ∑{r26∈nodesOfCell26(j26)}(dot(F26{j26,r26},ur26{r26}));
ComputeDt26: ∀n26∈ℕ, δt26^{n26=0}=option_δt_ini26;, δt26^{n26+1}=option_δt_cfl26*reduceMin{j26∈cells26()}(δtj26{j26});
ComputeTn26: ∀n26∈ℕ, t26^{n26=0}=0.0; , t26^{n26+1}=t26^{n26}+δt26^{n26+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter27: ∀j27∈cells27(), center27{j27} = (1.0/4.0) * ∑{r27∈nodesOfCell27(j27)}(coord27{r27});
IniIc27: ∀j27∈cells27(), if (center27{j27}.x < option_x_interface27) {
  ρ_ic27{j27}=option_ρ_ini_zg27;
  p_ic27{j27}=option_p_ini_zg27;
} else {
  ρ_ic27{j27}=option_ρ_ini_zd27;
  p_ic27{j27}=option_p_ini_zd27;
}

ComputeCjrIc27: ∀j27∈cells27(), ∀r27∈nodesOfCell27(j27), 
	C_ic27{j27,r27} = 0.5 * perp27(coord27{►(r27)} - coord27{◄(r27)});
IniVIc27: ∀j27∈cells27(), V_ic27{j27} = 0.5 * ∑{r27∈nodesOfCell27(j27)}(dot(C_ic27{j27,r27}, coord27{r27}));
IniM27: ∀j27∈cells27(), m27{j27} = ρ_ic27{j27} * V_ic27{j27}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr27: ∀j27∈cells27(), ∀r27∈nodesOfCell27(j27), C27{j27,r27} = 0.5 * perp27(X27{►(r27)} - X27{◄(r27)});
ComputeLjr27: ∀j27∈cells27(), ∀r27∈nodesOfCell27(j27), l27{j27,r27} = norm(C27{j27,r27});
Computeδtj27: ∀j27∈cells27(), δtj27{j27} = 2.0 * V27{j27} / (c27{j27} * ∑{r27∈nodesOfCell27(j27)}(l27{j27,r27}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity27: ∀j27∈cells27(), ρ27{j27} = m27{j27} / V27{j27};
ComputeEOSp27: ∀j27∈cells27(), p27{j27} = (γ27-1.0) * ρ27{j27} * e27{j27};
ComputeInternalEngergy27: ∀j27∈cells27(), e27{j27} = E27{j27} - 0.5 * dot(uj27{j27}, uj27{j27});
ComputeEOSc27: ∀j27∈cells27(), c27{j27} = √(γ27*p27{j27}/ρ27{j27}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr27: ∀j27∈cells27(), ∀r27∈nodesOfCell27(j27), Ajr27{j27,r27} = ((ρ27{j27}*c27{j27})/l27{j27,r27}) * tensProduct27(C27{j27,r27}, C27{j27,r27});
ComputeFjr27: ∀j27∈cells27(), ∀r27∈nodesOfCell27(j27), F27{j27,r27} = p27{j27}*C27{j27,r27} + matVectProduct27(Ajr27{j27,r27}, (uj27{j27}-ur27{r27}));
ComputeAr27: ∀r27∈nodes27(), Ar27{r27} = ∑{j27∈cellsOfNode27(r27)}(Ajr27{j27,r27});
ComputeBr27: ∀r27∈nodes27(), b27{r27} = ∑{j27∈cellsOfNode27(r27)}(p27{j27}*C27{j27,r27} + matVectProduct27(Ajr27{j27,r27}, uj27{j27}));
ComputeMt27: ∀r27∈innerNodes27(), Mt27{r27} = Ar27{r27};
ComputeBt27: ∀r27∈innerNodes27(), bt27{r27} = b27{r27};

OuterFacesComputations27: ∀k27∈outerFaces27(), {
	const ℝ epsilon27 = 1.0e-10;
	ℝ²ˣ² I27 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN27 = 0.0;
	ℝ X_MAX27 = X_EDGE_ELEMS27 * LENGTH27;
	ℝ Y_MIN27 = 0.0; 
	ℝ Y_MAX27 = Y_EDGE_ELEMS27 * LENGTH27;
	ℝ² nY27 = {0.0,1.0};
	
	∀r27∈nodesOfFace27(k27), {
		// Y boundary conditions (must be done before X)
		if ((X27{r27}.y-Y_MIN27 < epsilon27) || (X27{r27}.y-Y_MAX27 < epsilon27)) {
			ℝ sign27 = 0.0;
			if (X27{r27}.y-Y_MIN27 < epsilon27) sign27 = -1.0;
			else sign27 = 1.0;
			ℝ² n27 = sign27 * nY27;
      		ℝ²ˣ² nxn27 = tensProduct27(n27,n27);
      		ℝ²ˣ² IcP27 = I27 - nxn27;
			bt1{r27} = matVectProduct27(IcP27, b27{r27});
			Mt1{r27} = IcP27 * (Ar27{r27} * IcP27) + nxn27*trace27(Ar27{r27});
		}

		// X boundary conditions
		if ((Math.fabs(X27{r27}.x-X_MIN27) < epsilon27) || ( (Math.fabs(X27{r27}.x-X_MAX27) < epsilon27) )) {
			Mt27{r27} = I27;
			bt27{r27} = {0.0, 0.0};
		}
	}
}


ComputeU27: ∀r27∈nodes27(), ur27{r27} = matVectProduct27(inverse27(Mt27{r27}), bt27{r27});
ComputeV27: ∀j27∈cells27(), V27{j27} = 0.5 * ∑{r27∈nodesOfCell27(j27)}(dot(C27{j27,r27},X27{r27}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn27: ∀n27∈ℕ, ∀r027∈nodes27(), X27{r027}^{n27=0}=coord27{r027}; , ∀r27∈nodes27(), X27{r27}^{n27+1}=X27{r27}^{n27}+δt27^{n27}*ur27{r27};
ComputeUn27: ∀n27∈ℕ, ∀j027∈cells27(), uj27{j027}^{n27=0}={0.0,0.0}; , ∀j27∈cells27(), uj27{j27}^{n27+1}=uj27{j27}^{n27}-(δt27^{n27}/m27{j27})*∑{r27∈nodesOfCell27(j27)}(F27{j27,r27});
ComputeEn27: ∀n27∈ℕ, ∀j027∈cells27(), E27{j027}^{n27=0}=p_ic27{j027}/((γ27-1.0)*ρ_ic27{j027}); , ∀j27∈cells27(), E27{j27}^{n27+1}=E27{j27}^{n27} - (δt27^{n27} / m27{j27}) * ∑{r27∈nodesOfCell27(j27)}(dot(F27{j27,r27},ur27{r27}));
ComputeDt27: ∀n27∈ℕ, δt27^{n27=0}=option_δt_ini27;, δt27^{n27+1}=option_δt_cfl27*reduceMin{j27∈cells27()}(δtj27{j27});
ComputeTn27: ∀n27∈ℕ, t27^{n27=0}=0.0; , t27^{n27+1}=t27^{n27}+δt27^{n27+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter28: ∀j28∈cells28(), center28{j28} = (1.0/4.0) * ∑{r28∈nodesOfCell28(j28)}(coord28{r28});
IniIc28: ∀j28∈cells28(), if (center28{j28}.x < option_x_interface28) {
  ρ_ic28{j28}=option_ρ_ini_zg28;
  p_ic28{j28}=option_p_ini_zg28;
} else {
  ρ_ic28{j28}=option_ρ_ini_zd28;
  p_ic28{j28}=option_p_ini_zd28;
}

ComputeCjrIc28: ∀j28∈cells28(), ∀r28∈nodesOfCell28(j28), 
	C_ic28{j28,r28} = 0.5 * perp28(coord28{►(r28)} - coord28{◄(r28)});
IniVIc28: ∀j28∈cells28(), V_ic28{j28} = 0.5 * ∑{r28∈nodesOfCell28(j28)}(dot(C_ic28{j28,r28}, coord28{r28}));
IniM28: ∀j28∈cells28(), m28{j28} = ρ_ic28{j28} * V_ic28{j28}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr28: ∀j28∈cells28(), ∀r28∈nodesOfCell28(j28), C28{j28,r28} = 0.5 * perp28(X28{►(r28)} - X28{◄(r28)});
ComputeLjr28: ∀j28∈cells28(), ∀r28∈nodesOfCell28(j28), l28{j28,r28} = norm(C28{j28,r28});
Computeδtj28: ∀j28∈cells28(), δtj28{j28} = 2.0 * V28{j28} / (c28{j28} * ∑{r28∈nodesOfCell28(j28)}(l28{j28,r28}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity28: ∀j28∈cells28(), ρ28{j28} = m28{j28} / V28{j28};
ComputeEOSp28: ∀j28∈cells28(), p28{j28} = (γ28-1.0) * ρ28{j28} * e28{j28};
ComputeInternalEngergy28: ∀j28∈cells28(), e28{j28} = E28{j28} - 0.5 * dot(uj28{j28}, uj28{j28});
ComputeEOSc28: ∀j28∈cells28(), c28{j28} = √(γ28*p28{j28}/ρ28{j28}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr28: ∀j28∈cells28(), ∀r28∈nodesOfCell28(j28), Ajr28{j28,r28} = ((ρ28{j28}*c28{j28})/l28{j28,r28}) * tensProduct28(C28{j28,r28}, C28{j28,r28});
ComputeFjr28: ∀j28∈cells28(), ∀r28∈nodesOfCell28(j28), F28{j28,r28} = p28{j28}*C28{j28,r28} + matVectProduct28(Ajr28{j28,r28}, (uj28{j28}-ur28{r28}));
ComputeAr28: ∀r28∈nodes28(), Ar28{r28} = ∑{j28∈cellsOfNode28(r28)}(Ajr28{j28,r28});
ComputeBr28: ∀r28∈nodes28(), b28{r28} = ∑{j28∈cellsOfNode28(r28)}(p28{j28}*C28{j28,r28} + matVectProduct28(Ajr28{j28,r28}, uj28{j28}));
ComputeMt28: ∀r28∈innerNodes28(), Mt28{r28} = Ar28{r28};
ComputeBt28: ∀r28∈innerNodes28(), bt28{r28} = b28{r28};

OuterFacesComputations28: ∀k28∈outerFaces28(), {
	const ℝ epsilon28 = 1.0e-10;
	ℝ²ˣ² I28 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN28 = 0.0;
	ℝ X_MAX28 = X_EDGE_ELEMS28 * LENGTH28;
	ℝ Y_MIN28 = 0.0; 
	ℝ Y_MAX28 = Y_EDGE_ELEMS28 * LENGTH28;
	ℝ² nY28 = {0.0,1.0};
	
	∀r28∈nodesOfFace28(k28), {
		// Y boundary conditions (must be done before X)
		if ((X28{r28}.y-Y_MIN28 < epsilon28) || (X28{r28}.y-Y_MAX28 < epsilon28)) {
			ℝ sign28 = 0.0;
			if (X28{r28}.y-Y_MIN28 < epsilon28) sign28 = -1.0;
			else sign28 = 1.0;
			ℝ² n28 = sign28 * nY28;
      		ℝ²ˣ² nxn28 = tensProduct28(n28,n28);
      		ℝ²ˣ² IcP28 = I28 - nxn28;
			bt1{r28} = matVectProduct28(IcP28, b28{r28});
			Mt1{r28} = IcP28 * (Ar28{r28} * IcP28) + nxn28*trace28(Ar28{r28});
		}

		// X boundary conditions
		if ((Math.fabs(X28{r28}.x-X_MIN28) < epsilon28) || ( (Math.fabs(X28{r28}.x-X_MAX28) < epsilon28) )) {
			Mt28{r28} = I28;
			bt28{r28} = {0.0, 0.0};
		}
	}
}


ComputeU28: ∀r28∈nodes28(), ur28{r28} = matVectProduct28(inverse28(Mt28{r28}), bt28{r28});
ComputeV28: ∀j28∈cells28(), V28{j28} = 0.5 * ∑{r28∈nodesOfCell28(j28)}(dot(C28{j28,r28},X28{r28}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn28: ∀n28∈ℕ, ∀r028∈nodes28(), X28{r028}^{n28=0}=coord28{r028}; , ∀r28∈nodes28(), X28{r28}^{n28+1}=X28{r28}^{n28}+δt28^{n28}*ur28{r28};
ComputeUn28: ∀n28∈ℕ, ∀j028∈cells28(), uj28{j028}^{n28=0}={0.0,0.0}; , ∀j28∈cells28(), uj28{j28}^{n28+1}=uj28{j28}^{n28}-(δt28^{n28}/m28{j28})*∑{r28∈nodesOfCell28(j28)}(F28{j28,r28});
ComputeEn28: ∀n28∈ℕ, ∀j028∈cells28(), E28{j028}^{n28=0}=p_ic28{j028}/((γ28-1.0)*ρ_ic28{j028}); , ∀j28∈cells28(), E28{j28}^{n28+1}=E28{j28}^{n28} - (δt28^{n28} / m28{j28}) * ∑{r28∈nodesOfCell28(j28)}(dot(F28{j28,r28},ur28{r28}));
ComputeDt28: ∀n28∈ℕ, δt28^{n28=0}=option_δt_ini28;, δt28^{n28+1}=option_δt_cfl28*reduceMin{j28∈cells28()}(δtj28{j28});
ComputeTn28: ∀n28∈ℕ, t28^{n28=0}=0.0; , t28^{n28+1}=t28^{n28}+δt28^{n28+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter29: ∀j29∈cells29(), center29{j29} = (1.0/4.0) * ∑{r29∈nodesOfCell29(j29)}(coord29{r29});
IniIc29: ∀j29∈cells29(), if (center29{j29}.x < option_x_interface29) {
  ρ_ic29{j29}=option_ρ_ini_zg29;
  p_ic29{j29}=option_p_ini_zg29;
} else {
  ρ_ic29{j29}=option_ρ_ini_zd29;
  p_ic29{j29}=option_p_ini_zd29;
}

ComputeCjrIc29: ∀j29∈cells29(), ∀r29∈nodesOfCell29(j29), 
	C_ic29{j29,r29} = 0.5 * perp29(coord29{►(r29)} - coord29{◄(r29)});
IniVIc29: ∀j29∈cells29(), V_ic29{j29} = 0.5 * ∑{r29∈nodesOfCell29(j29)}(dot(C_ic29{j29,r29}, coord29{r29}));
IniM29: ∀j29∈cells29(), m29{j29} = ρ_ic29{j29} * V_ic29{j29}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr29: ∀j29∈cells29(), ∀r29∈nodesOfCell29(j29), C29{j29,r29} = 0.5 * perp29(X29{►(r29)} - X29{◄(r29)});
ComputeLjr29: ∀j29∈cells29(), ∀r29∈nodesOfCell29(j29), l29{j29,r29} = norm(C29{j29,r29});
Computeδtj29: ∀j29∈cells29(), δtj29{j29} = 2.0 * V29{j29} / (c29{j29} * ∑{r29∈nodesOfCell29(j29)}(l29{j29,r29}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity29: ∀j29∈cells29(), ρ29{j29} = m29{j29} / V29{j29};
ComputeEOSp29: ∀j29∈cells29(), p29{j29} = (γ29-1.0) * ρ29{j29} * e29{j29};
ComputeInternalEngergy29: ∀j29∈cells29(), e29{j29} = E29{j29} - 0.5 * dot(uj29{j29}, uj29{j29});
ComputeEOSc29: ∀j29∈cells29(), c29{j29} = √(γ29*p29{j29}/ρ29{j29}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr29: ∀j29∈cells29(), ∀r29∈nodesOfCell29(j29), Ajr29{j29,r29} = ((ρ29{j29}*c29{j29})/l29{j29,r29}) * tensProduct29(C29{j29,r29}, C29{j29,r29});
ComputeFjr29: ∀j29∈cells29(), ∀r29∈nodesOfCell29(j29), F29{j29,r29} = p29{j29}*C29{j29,r29} + matVectProduct29(Ajr29{j29,r29}, (uj29{j29}-ur29{r29}));
ComputeAr29: ∀r29∈nodes29(), Ar29{r29} = ∑{j29∈cellsOfNode29(r29)}(Ajr29{j29,r29});
ComputeBr29: ∀r29∈nodes29(), b29{r29} = ∑{j29∈cellsOfNode29(r29)}(p29{j29}*C29{j29,r29} + matVectProduct29(Ajr29{j29,r29}, uj29{j29}));
ComputeMt29: ∀r29∈innerNodes29(), Mt29{r29} = Ar29{r29};
ComputeBt29: ∀r29∈innerNodes29(), bt29{r29} = b29{r29};

OuterFacesComputations29: ∀k29∈outerFaces29(), {
	const ℝ epsilon29 = 1.0e-10;
	ℝ²ˣ² I29 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN29 = 0.0;
	ℝ X_MAX29 = X_EDGE_ELEMS29 * LENGTH29;
	ℝ Y_MIN29 = 0.0; 
	ℝ Y_MAX29 = Y_EDGE_ELEMS29 * LENGTH29;
	ℝ² nY29 = {0.0,1.0};
	
	∀r29∈nodesOfFace29(k29), {
		// Y boundary conditions (must be done before X)
		if ((X29{r29}.y-Y_MIN29 < epsilon29) || (X29{r29}.y-Y_MAX29 < epsilon29)) {
			ℝ sign29 = 0.0;
			if (X29{r29}.y-Y_MIN29 < epsilon29) sign29 = -1.0;
			else sign29 = 1.0;
			ℝ² n29 = sign29 * nY29;
      		ℝ²ˣ² nxn29 = tensProduct29(n29,n29);
      		ℝ²ˣ² IcP29 = I29 - nxn29;
			bt1{r29} = matVectProduct29(IcP29, b29{r29});
			Mt1{r29} = IcP29 * (Ar29{r29} * IcP29) + nxn29*trace29(Ar29{r29});
		}

		// X boundary conditions
		if ((Math.fabs(X29{r29}.x-X_MIN29) < epsilon29) || ( (Math.fabs(X29{r29}.x-X_MAX29) < epsilon29) )) {
			Mt29{r29} = I29;
			bt29{r29} = {0.0, 0.0};
		}
	}
}


ComputeU29: ∀r29∈nodes29(), ur29{r29} = matVectProduct29(inverse29(Mt29{r29}), bt29{r29});
ComputeV29: ∀j29∈cells29(), V29{j29} = 0.5 * ∑{r29∈nodesOfCell29(j29)}(dot(C29{j29,r29},X29{r29}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn29: ∀n29∈ℕ, ∀r029∈nodes29(), X29{r029}^{n29=0}=coord29{r029}; , ∀r29∈nodes29(), X29{r29}^{n29+1}=X29{r29}^{n29}+δt29^{n29}*ur29{r29};
ComputeUn29: ∀n29∈ℕ, ∀j029∈cells29(), uj29{j029}^{n29=0}={0.0,0.0}; , ∀j29∈cells29(), uj29{j29}^{n29+1}=uj29{j29}^{n29}-(δt29^{n29}/m29{j29})*∑{r29∈nodesOfCell29(j29)}(F29{j29,r29});
ComputeEn29: ∀n29∈ℕ, ∀j029∈cells29(), E29{j029}^{n29=0}=p_ic29{j029}/((γ29-1.0)*ρ_ic29{j029}); , ∀j29∈cells29(), E29{j29}^{n29+1}=E29{j29}^{n29} - (δt29^{n29} / m29{j29}) * ∑{r29∈nodesOfCell29(j29)}(dot(F29{j29,r29},ur29{r29}));
ComputeDt29: ∀n29∈ℕ, δt29^{n29=0}=option_δt_ini29;, δt29^{n29+1}=option_δt_cfl29*reduceMin{j29∈cells29()}(δtj29{j29});
ComputeTn29: ∀n29∈ℕ, t29^{n29=0}=0.0; , t29^{n29+1}=t29^{n29}+δt29^{n29+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter30: ∀j30∈cells30(), center30{j30} = (1.0/4.0) * ∑{r30∈nodesOfCell30(j30)}(coord30{r30});
IniIc30: ∀j30∈cells30(), if (center30{j30}.x < option_x_interface30) {
  ρ_ic30{j30}=option_ρ_ini_zg30;
  p_ic30{j30}=option_p_ini_zg30;
} else {
  ρ_ic30{j30}=option_ρ_ini_zd30;
  p_ic30{j30}=option_p_ini_zd30;
}

ComputeCjrIc30: ∀j30∈cells30(), ∀r30∈nodesOfCell30(j30), 
	C_ic30{j30,r30} = 0.5 * perp30(coord30{►(r30)} - coord30{◄(r30)});
IniVIc30: ∀j30∈cells30(), V_ic30{j30} = 0.5 * ∑{r30∈nodesOfCell30(j30)}(dot(C_ic30{j30,r30}, coord30{r30}));
IniM30: ∀j30∈cells30(), m30{j30} = ρ_ic30{j30} * V_ic30{j30}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr30: ∀j30∈cells30(), ∀r30∈nodesOfCell30(j30), C30{j30,r30} = 0.5 * perp30(X30{►(r30)} - X30{◄(r30)});
ComputeLjr30: ∀j30∈cells30(), ∀r30∈nodesOfCell30(j30), l30{j30,r30} = norm(C30{j30,r30});
Computeδtj30: ∀j30∈cells30(), δtj30{j30} = 2.0 * V30{j30} / (c30{j30} * ∑{r30∈nodesOfCell30(j30)}(l30{j30,r30}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity30: ∀j30∈cells30(), ρ30{j30} = m30{j30} / V30{j30};
ComputeEOSp30: ∀j30∈cells30(), p30{j30} = (γ30-1.0) * ρ30{j30} * e30{j30};
ComputeInternalEngergy30: ∀j30∈cells30(), e30{j30} = E30{j30} - 0.5 * dot(uj30{j30}, uj30{j30});
ComputeEOSc30: ∀j30∈cells30(), c30{j30} = √(γ30*p30{j30}/ρ30{j30}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr30: ∀j30∈cells30(), ∀r30∈nodesOfCell30(j30), Ajr30{j30,r30} = ((ρ30{j30}*c30{j30})/l30{j30,r30}) * tensProduct30(C30{j30,r30}, C30{j30,r30});
ComputeFjr30: ∀j30∈cells30(), ∀r30∈nodesOfCell30(j30), F30{j30,r30} = p30{j30}*C30{j30,r30} + matVectProduct30(Ajr30{j30,r30}, (uj30{j30}-ur30{r30}));
ComputeAr30: ∀r30∈nodes30(), Ar30{r30} = ∑{j30∈cellsOfNode30(r30)}(Ajr30{j30,r30});
ComputeBr30: ∀r30∈nodes30(), b30{r30} = ∑{j30∈cellsOfNode30(r30)}(p30{j30}*C30{j30,r30} + matVectProduct30(Ajr30{j30,r30}, uj30{j30}));
ComputeMt30: ∀r30∈innerNodes30(), Mt30{r30} = Ar30{r30};
ComputeBt30: ∀r30∈innerNodes30(), bt30{r30} = b30{r30};

OuterFacesComputations30: ∀k30∈outerFaces30(), {
	const ℝ epsilon30 = 1.0e-10;
	ℝ²ˣ² I30 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN30 = 0.0;
	ℝ X_MAX30 = X_EDGE_ELEMS30 * LENGTH30;
	ℝ Y_MIN30 = 0.0; 
	ℝ Y_MAX30 = Y_EDGE_ELEMS30 * LENGTH30;
	ℝ² nY30 = {0.0,1.0};
	
	∀r30∈nodesOfFace30(k30), {
		// Y boundary conditions (must be done before X)
		if ((X30{r30}.y-Y_MIN30 < epsilon30) || (X30{r30}.y-Y_MAX30 < epsilon30)) {
			ℝ sign30 = 0.0;
			if (X30{r30}.y-Y_MIN30 < epsilon30) sign30 = -1.0;
			else sign30 = 1.0;
			ℝ² n30 = sign30 * nY30;
      		ℝ²ˣ² nxn30 = tensProduct30(n30,n30);
      		ℝ²ˣ² IcP30 = I30 - nxn30;
			bt1{r30} = matVectProduct30(IcP30, b30{r30});
			Mt1{r30} = IcP30 * (Ar30{r30} * IcP30) + nxn30*trace30(Ar30{r30});
		}

		// X boundary conditions
		if ((Math.fabs(X30{r30}.x-X_MIN30) < epsilon30) || ( (Math.fabs(X30{r30}.x-X_MAX30) < epsilon30) )) {
			Mt30{r30} = I30;
			bt30{r30} = {0.0, 0.0};
		}
	}
}


ComputeU30: ∀r30∈nodes30(), ur30{r30} = matVectProduct30(inverse30(Mt30{r30}), bt30{r30});
ComputeV30: ∀j30∈cells30(), V30{j30} = 0.5 * ∑{r30∈nodesOfCell30(j30)}(dot(C30{j30,r30},X30{r30}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn30: ∀n30∈ℕ, ∀r030∈nodes30(), X30{r030}^{n30=0}=coord30{r030}; , ∀r30∈nodes30(), X30{r30}^{n30+1}=X30{r30}^{n30}+δt30^{n30}*ur30{r30};
ComputeUn30: ∀n30∈ℕ, ∀j030∈cells30(), uj30{j030}^{n30=0}={0.0,0.0}; , ∀j30∈cells30(), uj30{j30}^{n30+1}=uj30{j30}^{n30}-(δt30^{n30}/m30{j30})*∑{r30∈nodesOfCell30(j30)}(F30{j30,r30});
ComputeEn30: ∀n30∈ℕ, ∀j030∈cells30(), E30{j030}^{n30=0}=p_ic30{j030}/((γ30-1.0)*ρ_ic30{j030}); , ∀j30∈cells30(), E30{j30}^{n30+1}=E30{j30}^{n30} - (δt30^{n30} / m30{j30}) * ∑{r30∈nodesOfCell30(j30)}(dot(F30{j30,r30},ur30{r30}));
ComputeDt30: ∀n30∈ℕ, δt30^{n30=0}=option_δt_ini30;, δt30^{n30+1}=option_δt_cfl30*reduceMin{j30∈cells30()}(δtj30{j30});
ComputeTn30: ∀n30∈ℕ, t30^{n30=0}=0.0; , t30^{n30+1}=t30^{n30}+δt30^{n30+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter31: ∀j31∈cells31(), center31{j31} = (1.0/4.0) * ∑{r31∈nodesOfCell31(j31)}(coord31{r31});
IniIc31: ∀j31∈cells31(), if (center31{j31}.x < option_x_interface31) {
  ρ_ic31{j31}=option_ρ_ini_zg31;
  p_ic31{j31}=option_p_ini_zg31;
} else {
  ρ_ic31{j31}=option_ρ_ini_zd31;
  p_ic31{j31}=option_p_ini_zd31;
}

ComputeCjrIc31: ∀j31∈cells31(), ∀r31∈nodesOfCell31(j31), 
	C_ic31{j31,r31} = 0.5 * perp31(coord31{►(r31)} - coord31{◄(r31)});
IniVIc31: ∀j31∈cells31(), V_ic31{j31} = 0.5 * ∑{r31∈nodesOfCell31(j31)}(dot(C_ic31{j31,r31}, coord31{r31}));
IniM31: ∀j31∈cells31(), m31{j31} = ρ_ic31{j31} * V_ic31{j31}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr31: ∀j31∈cells31(), ∀r31∈nodesOfCell31(j31), C31{j31,r31} = 0.5 * perp31(X31{►(r31)} - X31{◄(r31)});
ComputeLjr31: ∀j31∈cells31(), ∀r31∈nodesOfCell31(j31), l31{j31,r31} = norm(C31{j31,r31});
Computeδtj31: ∀j31∈cells31(), δtj31{j31} = 2.0 * V31{j31} / (c31{j31} * ∑{r31∈nodesOfCell31(j31)}(l31{j31,r31}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity31: ∀j31∈cells31(), ρ31{j31} = m31{j31} / V31{j31};
ComputeEOSp31: ∀j31∈cells31(), p31{j31} = (γ31-1.0) * ρ31{j31} * e31{j31};
ComputeInternalEngergy31: ∀j31∈cells31(), e31{j31} = E31{j31} - 0.5 * dot(uj31{j31}, uj31{j31});
ComputeEOSc31: ∀j31∈cells31(), c31{j31} = √(γ31*p31{j31}/ρ31{j31}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr31: ∀j31∈cells31(), ∀r31∈nodesOfCell31(j31), Ajr31{j31,r31} = ((ρ31{j31}*c31{j31})/l31{j31,r31}) * tensProduct31(C31{j31,r31}, C31{j31,r31});
ComputeFjr31: ∀j31∈cells31(), ∀r31∈nodesOfCell31(j31), F31{j31,r31} = p31{j31}*C31{j31,r31} + matVectProduct31(Ajr31{j31,r31}, (uj31{j31}-ur31{r31}));
ComputeAr31: ∀r31∈nodes31(), Ar31{r31} = ∑{j31∈cellsOfNode31(r31)}(Ajr31{j31,r31});
ComputeBr31: ∀r31∈nodes31(), b31{r31} = ∑{j31∈cellsOfNode31(r31)}(p31{j31}*C31{j31,r31} + matVectProduct31(Ajr31{j31,r31}, uj31{j31}));
ComputeMt31: ∀r31∈innerNodes31(), Mt31{r31} = Ar31{r31};
ComputeBt31: ∀r31∈innerNodes31(), bt31{r31} = b31{r31};

OuterFacesComputations31: ∀k31∈outerFaces31(), {
	const ℝ epsilon31 = 1.0e-10;
	ℝ²ˣ² I31 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN31 = 0.0;
	ℝ X_MAX31 = X_EDGE_ELEMS31 * LENGTH31;
	ℝ Y_MIN31 = 0.0; 
	ℝ Y_MAX31 = Y_EDGE_ELEMS31 * LENGTH31;
	ℝ² nY31 = {0.0,1.0};
	
	∀r31∈nodesOfFace31(k31), {
		// Y boundary conditions (must be done before X)
		if ((X31{r31}.y-Y_MIN31 < epsilon31) || (X31{r31}.y-Y_MAX31 < epsilon31)) {
			ℝ sign31 = 0.0;
			if (X31{r31}.y-Y_MIN31 < epsilon31) sign31 = -1.0;
			else sign31 = 1.0;
			ℝ² n31 = sign31 * nY31;
      		ℝ²ˣ² nxn31 = tensProduct31(n31,n31);
      		ℝ²ˣ² IcP31 = I31 - nxn31;
			bt1{r31} = matVectProduct31(IcP31, b31{r31});
			Mt1{r31} = IcP31 * (Ar31{r31} * IcP31) + nxn31*trace31(Ar31{r31});
		}

		// X boundary conditions
		if ((Math.fabs(X31{r31}.x-X_MIN31) < epsilon31) || ( (Math.fabs(X31{r31}.x-X_MAX31) < epsilon31) )) {
			Mt31{r31} = I31;
			bt31{r31} = {0.0, 0.0};
		}
	}
}


ComputeU31: ∀r31∈nodes31(), ur31{r31} = matVectProduct31(inverse31(Mt31{r31}), bt31{r31});
ComputeV31: ∀j31∈cells31(), V31{j31} = 0.5 * ∑{r31∈nodesOfCell31(j31)}(dot(C31{j31,r31},X31{r31}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn31: ∀n31∈ℕ, ∀r031∈nodes31(), X31{r031}^{n31=0}=coord31{r031}; , ∀r31∈nodes31(), X31{r31}^{n31+1}=X31{r31}^{n31}+δt31^{n31}*ur31{r31};
ComputeUn31: ∀n31∈ℕ, ∀j031∈cells31(), uj31{j031}^{n31=0}={0.0,0.0}; , ∀j31∈cells31(), uj31{j31}^{n31+1}=uj31{j31}^{n31}-(δt31^{n31}/m31{j31})*∑{r31∈nodesOfCell31(j31)}(F31{j31,r31});
ComputeEn31: ∀n31∈ℕ, ∀j031∈cells31(), E31{j031}^{n31=0}=p_ic31{j031}/((γ31-1.0)*ρ_ic31{j031}); , ∀j31∈cells31(), E31{j31}^{n31+1}=E31{j31}^{n31} - (δt31^{n31} / m31{j31}) * ∑{r31∈nodesOfCell31(j31)}(dot(F31{j31,r31},ur31{r31}));
ComputeDt31: ∀n31∈ℕ, δt31^{n31=0}=option_δt_ini31;, δt31^{n31+1}=option_δt_cfl31*reduceMin{j31∈cells31()}(δtj31{j31});
ComputeTn31: ∀n31∈ℕ, t31^{n31=0}=0.0; , t31^{n31+1}=t31^{n31}+δt31^{n31+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter32: ∀j32∈cells32(), center32{j32} = (1.0/4.0) * ∑{r32∈nodesOfCell32(j32)}(coord32{r32});
IniIc32: ∀j32∈cells32(), if (center32{j32}.x < option_x_interface32) {
  ρ_ic32{j32}=option_ρ_ini_zg32;
  p_ic32{j32}=option_p_ini_zg32;
} else {
  ρ_ic32{j32}=option_ρ_ini_zd32;
  p_ic32{j32}=option_p_ini_zd32;
}

ComputeCjrIc32: ∀j32∈cells32(), ∀r32∈nodesOfCell32(j32), 
	C_ic32{j32,r32} = 0.5 * perp32(coord32{►(r32)} - coord32{◄(r32)});
IniVIc32: ∀j32∈cells32(), V_ic32{j32} = 0.5 * ∑{r32∈nodesOfCell32(j32)}(dot(C_ic32{j32,r32}, coord32{r32}));
IniM32: ∀j32∈cells32(), m32{j32} = ρ_ic32{j32} * V_ic32{j32}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr32: ∀j32∈cells32(), ∀r32∈nodesOfCell32(j32), C32{j32,r32} = 0.5 * perp32(X32{►(r32)} - X32{◄(r32)});
ComputeLjr32: ∀j32∈cells32(), ∀r32∈nodesOfCell32(j32), l32{j32,r32} = norm(C32{j32,r32});
Computeδtj32: ∀j32∈cells32(), δtj32{j32} = 2.0 * V32{j32} / (c32{j32} * ∑{r32∈nodesOfCell32(j32)}(l32{j32,r32}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity32: ∀j32∈cells32(), ρ32{j32} = m32{j32} / V32{j32};
ComputeEOSp32: ∀j32∈cells32(), p32{j32} = (γ32-1.0) * ρ32{j32} * e32{j32};
ComputeInternalEngergy32: ∀j32∈cells32(), e32{j32} = E32{j32} - 0.5 * dot(uj32{j32}, uj32{j32});
ComputeEOSc32: ∀j32∈cells32(), c32{j32} = √(γ32*p32{j32}/ρ32{j32}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr32: ∀j32∈cells32(), ∀r32∈nodesOfCell32(j32), Ajr32{j32,r32} = ((ρ32{j32}*c32{j32})/l32{j32,r32}) * tensProduct32(C32{j32,r32}, C32{j32,r32});
ComputeFjr32: ∀j32∈cells32(), ∀r32∈nodesOfCell32(j32), F32{j32,r32} = p32{j32}*C32{j32,r32} + matVectProduct32(Ajr32{j32,r32}, (uj32{j32}-ur32{r32}));
ComputeAr32: ∀r32∈nodes32(), Ar32{r32} = ∑{j32∈cellsOfNode32(r32)}(Ajr32{j32,r32});
ComputeBr32: ∀r32∈nodes32(), b32{r32} = ∑{j32∈cellsOfNode32(r32)}(p32{j32}*C32{j32,r32} + matVectProduct32(Ajr32{j32,r32}, uj32{j32}));
ComputeMt32: ∀r32∈innerNodes32(), Mt32{r32} = Ar32{r32};
ComputeBt32: ∀r32∈innerNodes32(), bt32{r32} = b32{r32};

OuterFacesComputations32: ∀k32∈outerFaces32(), {
	const ℝ epsilon32 = 1.0e-10;
	ℝ²ˣ² I32 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN32 = 0.0;
	ℝ X_MAX32 = X_EDGE_ELEMS32 * LENGTH32;
	ℝ Y_MIN32 = 0.0; 
	ℝ Y_MAX32 = Y_EDGE_ELEMS32 * LENGTH32;
	ℝ² nY32 = {0.0,1.0};
	
	∀r32∈nodesOfFace32(k32), {
		// Y boundary conditions (must be done before X)
		if ((X32{r32}.y-Y_MIN32 < epsilon32) || (X32{r32}.y-Y_MAX32 < epsilon32)) {
			ℝ sign32 = 0.0;
			if (X32{r32}.y-Y_MIN32 < epsilon32) sign32 = -1.0;
			else sign32 = 1.0;
			ℝ² n32 = sign32 * nY32;
      		ℝ²ˣ² nxn32 = tensProduct32(n32,n32);
      		ℝ²ˣ² IcP32 = I32 - nxn32;
			bt1{r32} = matVectProduct32(IcP32, b32{r32});
			Mt1{r32} = IcP32 * (Ar32{r32} * IcP32) + nxn32*trace32(Ar32{r32});
		}

		// X boundary conditions
		if ((Math.fabs(X32{r32}.x-X_MIN32) < epsilon32) || ( (Math.fabs(X32{r32}.x-X_MAX32) < epsilon32) )) {
			Mt32{r32} = I32;
			bt32{r32} = {0.0, 0.0};
		}
	}
}


ComputeU32: ∀r32∈nodes32(), ur32{r32} = matVectProduct32(inverse32(Mt32{r32}), bt32{r32});
ComputeV32: ∀j32∈cells32(), V32{j32} = 0.5 * ∑{r32∈nodesOfCell32(j32)}(dot(C32{j32,r32},X32{r32}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn32: ∀n32∈ℕ, ∀r032∈nodes32(), X32{r032}^{n32=0}=coord32{r032}; , ∀r32∈nodes32(), X32{r32}^{n32+1}=X32{r32}^{n32}+δt32^{n32}*ur32{r32};
ComputeUn32: ∀n32∈ℕ, ∀j032∈cells32(), uj32{j032}^{n32=0}={0.0,0.0}; , ∀j32∈cells32(), uj32{j32}^{n32+1}=uj32{j32}^{n32}-(δt32^{n32}/m32{j32})*∑{r32∈nodesOfCell32(j32)}(F32{j32,r32});
ComputeEn32: ∀n32∈ℕ, ∀j032∈cells32(), E32{j032}^{n32=0}=p_ic32{j032}/((γ32-1.0)*ρ_ic32{j032}); , ∀j32∈cells32(), E32{j32}^{n32+1}=E32{j32}^{n32} - (δt32^{n32} / m32{j32}) * ∑{r32∈nodesOfCell32(j32)}(dot(F32{j32,r32},ur32{r32}));
ComputeDt32: ∀n32∈ℕ, δt32^{n32=0}=option_δt_ini32;, δt32^{n32+1}=option_δt_cfl32*reduceMin{j32∈cells32()}(δtj32{j32});
ComputeTn32: ∀n32∈ℕ, t32^{n32=0}=0.0; , t32^{n32+1}=t32^{n32}+δt32^{n32+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter33: ∀j33∈cells33(), center33{j33} = (1.0/4.0) * ∑{r33∈nodesOfCell33(j33)}(coord33{r33});
IniIc33: ∀j33∈cells33(), if (center33{j33}.x < option_x_interface33) {
  ρ_ic33{j33}=option_ρ_ini_zg33;
  p_ic33{j33}=option_p_ini_zg33;
} else {
  ρ_ic33{j33}=option_ρ_ini_zd33;
  p_ic33{j33}=option_p_ini_zd33;
}

ComputeCjrIc33: ∀j33∈cells33(), ∀r33∈nodesOfCell33(j33), 
	C_ic33{j33,r33} = 0.5 * perp33(coord33{►(r33)} - coord33{◄(r33)});
IniVIc33: ∀j33∈cells33(), V_ic33{j33} = 0.5 * ∑{r33∈nodesOfCell33(j33)}(dot(C_ic33{j33,r33}, coord33{r33}));
IniM33: ∀j33∈cells33(), m33{j33} = ρ_ic33{j33} * V_ic33{j33}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr33: ∀j33∈cells33(), ∀r33∈nodesOfCell33(j33), C33{j33,r33} = 0.5 * perp33(X33{►(r33)} - X33{◄(r33)});
ComputeLjr33: ∀j33∈cells33(), ∀r33∈nodesOfCell33(j33), l33{j33,r33} = norm(C33{j33,r33});
Computeδtj33: ∀j33∈cells33(), δtj33{j33} = 2.0 * V33{j33} / (c33{j33} * ∑{r33∈nodesOfCell33(j33)}(l33{j33,r33}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity33: ∀j33∈cells33(), ρ33{j33} = m33{j33} / V33{j33};
ComputeEOSp33: ∀j33∈cells33(), p33{j33} = (γ33-1.0) * ρ33{j33} * e33{j33};
ComputeInternalEngergy33: ∀j33∈cells33(), e33{j33} = E33{j33} - 0.5 * dot(uj33{j33}, uj33{j33});
ComputeEOSc33: ∀j33∈cells33(), c33{j33} = √(γ33*p33{j33}/ρ33{j33}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr33: ∀j33∈cells33(), ∀r33∈nodesOfCell33(j33), Ajr33{j33,r33} = ((ρ33{j33}*c33{j33})/l33{j33,r33}) * tensProduct33(C33{j33,r33}, C33{j33,r33});
ComputeFjr33: ∀j33∈cells33(), ∀r33∈nodesOfCell33(j33), F33{j33,r33} = p33{j33}*C33{j33,r33} + matVectProduct33(Ajr33{j33,r33}, (uj33{j33}-ur33{r33}));
ComputeAr33: ∀r33∈nodes33(), Ar33{r33} = ∑{j33∈cellsOfNode33(r33)}(Ajr33{j33,r33});
ComputeBr33: ∀r33∈nodes33(), b33{r33} = ∑{j33∈cellsOfNode33(r33)}(p33{j33}*C33{j33,r33} + matVectProduct33(Ajr33{j33,r33}, uj33{j33}));
ComputeMt33: ∀r33∈innerNodes33(), Mt33{r33} = Ar33{r33};
ComputeBt33: ∀r33∈innerNodes33(), bt33{r33} = b33{r33};

OuterFacesComputations33: ∀k33∈outerFaces33(), {
	const ℝ epsilon33 = 1.0e-10;
	ℝ²ˣ² I33 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN33 = 0.0;
	ℝ X_MAX33 = X_EDGE_ELEMS33 * LENGTH33;
	ℝ Y_MIN33 = 0.0; 
	ℝ Y_MAX33 = Y_EDGE_ELEMS33 * LENGTH33;
	ℝ² nY33 = {0.0,1.0};
	
	∀r33∈nodesOfFace33(k33), {
		// Y boundary conditions (must be done before X)
		if ((X33{r33}.y-Y_MIN33 < epsilon33) || (X33{r33}.y-Y_MAX33 < epsilon33)) {
			ℝ sign33 = 0.0;
			if (X33{r33}.y-Y_MIN33 < epsilon33) sign33 = -1.0;
			else sign33 = 1.0;
			ℝ² n33 = sign33 * nY33;
      		ℝ²ˣ² nxn33 = tensProduct33(n33,n33);
      		ℝ²ˣ² IcP33 = I33 - nxn33;
			bt1{r33} = matVectProduct33(IcP33, b33{r33});
			Mt1{r33} = IcP33 * (Ar33{r33} * IcP33) + nxn33*trace33(Ar33{r33});
		}

		// X boundary conditions
		if ((Math.fabs(X33{r33}.x-X_MIN33) < epsilon33) || ( (Math.fabs(X33{r33}.x-X_MAX33) < epsilon33) )) {
			Mt33{r33} = I33;
			bt33{r33} = {0.0, 0.0};
		}
	}
}


ComputeU33: ∀r33∈nodes33(), ur33{r33} = matVectProduct33(inverse33(Mt33{r33}), bt33{r33});
ComputeV33: ∀j33∈cells33(), V33{j33} = 0.5 * ∑{r33∈nodesOfCell33(j33)}(dot(C33{j33,r33},X33{r33}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn33: ∀n33∈ℕ, ∀r033∈nodes33(), X33{r033}^{n33=0}=coord33{r033}; , ∀r33∈nodes33(), X33{r33}^{n33+1}=X33{r33}^{n33}+δt33^{n33}*ur33{r33};
ComputeUn33: ∀n33∈ℕ, ∀j033∈cells33(), uj33{j033}^{n33=0}={0.0,0.0}; , ∀j33∈cells33(), uj33{j33}^{n33+1}=uj33{j33}^{n33}-(δt33^{n33}/m33{j33})*∑{r33∈nodesOfCell33(j33)}(F33{j33,r33});
ComputeEn33: ∀n33∈ℕ, ∀j033∈cells33(), E33{j033}^{n33=0}=p_ic33{j033}/((γ33-1.0)*ρ_ic33{j033}); , ∀j33∈cells33(), E33{j33}^{n33+1}=E33{j33}^{n33} - (δt33^{n33} / m33{j33}) * ∑{r33∈nodesOfCell33(j33)}(dot(F33{j33,r33},ur33{r33}));
ComputeDt33: ∀n33∈ℕ, δt33^{n33=0}=option_δt_ini33;, δt33^{n33+1}=option_δt_cfl33*reduceMin{j33∈cells33()}(δtj33{j33});
ComputeTn33: ∀n33∈ℕ, t33^{n33=0}=0.0; , t33^{n33+1}=t33^{n33}+δt33^{n33+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter34: ∀j34∈cells34(), center34{j34} = (1.0/4.0) * ∑{r34∈nodesOfCell34(j34)}(coord34{r34});
IniIc34: ∀j34∈cells34(), if (center34{j34}.x < option_x_interface34) {
  ρ_ic34{j34}=option_ρ_ini_zg34;
  p_ic34{j34}=option_p_ini_zg34;
} else {
  ρ_ic34{j34}=option_ρ_ini_zd34;
  p_ic34{j34}=option_p_ini_zd34;
}

ComputeCjrIc34: ∀j34∈cells34(), ∀r34∈nodesOfCell34(j34), 
	C_ic34{j34,r34} = 0.5 * perp34(coord34{►(r34)} - coord34{◄(r34)});
IniVIc34: ∀j34∈cells34(), V_ic34{j34} = 0.5 * ∑{r34∈nodesOfCell34(j34)}(dot(C_ic34{j34,r34}, coord34{r34}));
IniM34: ∀j34∈cells34(), m34{j34} = ρ_ic34{j34} * V_ic34{j34}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr34: ∀j34∈cells34(), ∀r34∈nodesOfCell34(j34), C34{j34,r34} = 0.5 * perp34(X34{►(r34)} - X34{◄(r34)});
ComputeLjr34: ∀j34∈cells34(), ∀r34∈nodesOfCell34(j34), l34{j34,r34} = norm(C34{j34,r34});
Computeδtj34: ∀j34∈cells34(), δtj34{j34} = 2.0 * V34{j34} / (c34{j34} * ∑{r34∈nodesOfCell34(j34)}(l34{j34,r34}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity34: ∀j34∈cells34(), ρ34{j34} = m34{j34} / V34{j34};
ComputeEOSp34: ∀j34∈cells34(), p34{j34} = (γ34-1.0) * ρ34{j34} * e34{j34};
ComputeInternalEngergy34: ∀j34∈cells34(), e34{j34} = E34{j34} - 0.5 * dot(uj34{j34}, uj34{j34});
ComputeEOSc34: ∀j34∈cells34(), c34{j34} = √(γ34*p34{j34}/ρ34{j34}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr34: ∀j34∈cells34(), ∀r34∈nodesOfCell34(j34), Ajr34{j34,r34} = ((ρ34{j34}*c34{j34})/l34{j34,r34}) * tensProduct34(C34{j34,r34}, C34{j34,r34});
ComputeFjr34: ∀j34∈cells34(), ∀r34∈nodesOfCell34(j34), F34{j34,r34} = p34{j34}*C34{j34,r34} + matVectProduct34(Ajr34{j34,r34}, (uj34{j34}-ur34{r34}));
ComputeAr34: ∀r34∈nodes34(), Ar34{r34} = ∑{j34∈cellsOfNode34(r34)}(Ajr34{j34,r34});
ComputeBr34: ∀r34∈nodes34(), b34{r34} = ∑{j34∈cellsOfNode34(r34)}(p34{j34}*C34{j34,r34} + matVectProduct34(Ajr34{j34,r34}, uj34{j34}));
ComputeMt34: ∀r34∈innerNodes34(), Mt34{r34} = Ar34{r34};
ComputeBt34: ∀r34∈innerNodes34(), bt34{r34} = b34{r34};

OuterFacesComputations34: ∀k34∈outerFaces34(), {
	const ℝ epsilon34 = 1.0e-10;
	ℝ²ˣ² I34 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN34 = 0.0;
	ℝ X_MAX34 = X_EDGE_ELEMS34 * LENGTH34;
	ℝ Y_MIN34 = 0.0; 
	ℝ Y_MAX34 = Y_EDGE_ELEMS34 * LENGTH34;
	ℝ² nY34 = {0.0,1.0};
	
	∀r34∈nodesOfFace34(k34), {
		// Y boundary conditions (must be done before X)
		if ((X34{r34}.y-Y_MIN34 < epsilon34) || (X34{r34}.y-Y_MAX34 < epsilon34)) {
			ℝ sign34 = 0.0;
			if (X34{r34}.y-Y_MIN34 < epsilon34) sign34 = -1.0;
			else sign34 = 1.0;
			ℝ² n34 = sign34 * nY34;
      		ℝ²ˣ² nxn34 = tensProduct34(n34,n34);
      		ℝ²ˣ² IcP34 = I34 - nxn34;
			bt1{r34} = matVectProduct34(IcP34, b34{r34});
			Mt1{r34} = IcP34 * (Ar34{r34} * IcP34) + nxn34*trace34(Ar34{r34});
		}

		// X boundary conditions
		if ((Math.fabs(X34{r34}.x-X_MIN34) < epsilon34) || ( (Math.fabs(X34{r34}.x-X_MAX34) < epsilon34) )) {
			Mt34{r34} = I34;
			bt34{r34} = {0.0, 0.0};
		}
	}
}


ComputeU34: ∀r34∈nodes34(), ur34{r34} = matVectProduct34(inverse34(Mt34{r34}), bt34{r34});
ComputeV34: ∀j34∈cells34(), V34{j34} = 0.5 * ∑{r34∈nodesOfCell34(j34)}(dot(C34{j34,r34},X34{r34}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn34: ∀n34∈ℕ, ∀r034∈nodes34(), X34{r034}^{n34=0}=coord34{r034}; , ∀r34∈nodes34(), X34{r34}^{n34+1}=X34{r34}^{n34}+δt34^{n34}*ur34{r34};
ComputeUn34: ∀n34∈ℕ, ∀j034∈cells34(), uj34{j034}^{n34=0}={0.0,0.0}; , ∀j34∈cells34(), uj34{j34}^{n34+1}=uj34{j34}^{n34}-(δt34^{n34}/m34{j34})*∑{r34∈nodesOfCell34(j34)}(F34{j34,r34});
ComputeEn34: ∀n34∈ℕ, ∀j034∈cells34(), E34{j034}^{n34=0}=p_ic34{j034}/((γ34-1.0)*ρ_ic34{j034}); , ∀j34∈cells34(), E34{j34}^{n34+1}=E34{j34}^{n34} - (δt34^{n34} / m34{j34}) * ∑{r34∈nodesOfCell34(j34)}(dot(F34{j34,r34},ur34{r34}));
ComputeDt34: ∀n34∈ℕ, δt34^{n34=0}=option_δt_ini34;, δt34^{n34+1}=option_δt_cfl34*reduceMin{j34∈cells34()}(δtj34{j34});
ComputeTn34: ∀n34∈ℕ, t34^{n34=0}=0.0; , t34^{n34+1}=t34^{n34}+δt34^{n34+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter35: ∀j35∈cells35(), center35{j35} = (1.0/4.0) * ∑{r35∈nodesOfCell35(j35)}(coord35{r35});
IniIc35: ∀j35∈cells35(), if (center35{j35}.x < option_x_interface35) {
  ρ_ic35{j35}=option_ρ_ini_zg35;
  p_ic35{j35}=option_p_ini_zg35;
} else {
  ρ_ic35{j35}=option_ρ_ini_zd35;
  p_ic35{j35}=option_p_ini_zd35;
}

ComputeCjrIc35: ∀j35∈cells35(), ∀r35∈nodesOfCell35(j35), 
	C_ic35{j35,r35} = 0.5 * perp35(coord35{►(r35)} - coord35{◄(r35)});
IniVIc35: ∀j35∈cells35(), V_ic35{j35} = 0.5 * ∑{r35∈nodesOfCell35(j35)}(dot(C_ic35{j35,r35}, coord35{r35}));
IniM35: ∀j35∈cells35(), m35{j35} = ρ_ic35{j35} * V_ic35{j35}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr35: ∀j35∈cells35(), ∀r35∈nodesOfCell35(j35), C35{j35,r35} = 0.5 * perp35(X35{►(r35)} - X35{◄(r35)});
ComputeLjr35: ∀j35∈cells35(), ∀r35∈nodesOfCell35(j35), l35{j35,r35} = norm(C35{j35,r35});
Computeδtj35: ∀j35∈cells35(), δtj35{j35} = 2.0 * V35{j35} / (c35{j35} * ∑{r35∈nodesOfCell35(j35)}(l35{j35,r35}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity35: ∀j35∈cells35(), ρ35{j35} = m35{j35} / V35{j35};
ComputeEOSp35: ∀j35∈cells35(), p35{j35} = (γ35-1.0) * ρ35{j35} * e35{j35};
ComputeInternalEngergy35: ∀j35∈cells35(), e35{j35} = E35{j35} - 0.5 * dot(uj35{j35}, uj35{j35});
ComputeEOSc35: ∀j35∈cells35(), c35{j35} = √(γ35*p35{j35}/ρ35{j35}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr35: ∀j35∈cells35(), ∀r35∈nodesOfCell35(j35), Ajr35{j35,r35} = ((ρ35{j35}*c35{j35})/l35{j35,r35}) * tensProduct35(C35{j35,r35}, C35{j35,r35});
ComputeFjr35: ∀j35∈cells35(), ∀r35∈nodesOfCell35(j35), F35{j35,r35} = p35{j35}*C35{j35,r35} + matVectProduct35(Ajr35{j35,r35}, (uj35{j35}-ur35{r35}));
ComputeAr35: ∀r35∈nodes35(), Ar35{r35} = ∑{j35∈cellsOfNode35(r35)}(Ajr35{j35,r35});
ComputeBr35: ∀r35∈nodes35(), b35{r35} = ∑{j35∈cellsOfNode35(r35)}(p35{j35}*C35{j35,r35} + matVectProduct35(Ajr35{j35,r35}, uj35{j35}));
ComputeMt35: ∀r35∈innerNodes35(), Mt35{r35} = Ar35{r35};
ComputeBt35: ∀r35∈innerNodes35(), bt35{r35} = b35{r35};

OuterFacesComputations35: ∀k35∈outerFaces35(), {
	const ℝ epsilon35 = 1.0e-10;
	ℝ²ˣ² I35 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN35 = 0.0;
	ℝ X_MAX35 = X_EDGE_ELEMS35 * LENGTH35;
	ℝ Y_MIN35 = 0.0; 
	ℝ Y_MAX35 = Y_EDGE_ELEMS35 * LENGTH35;
	ℝ² nY35 = {0.0,1.0};
	
	∀r35∈nodesOfFace35(k35), {
		// Y boundary conditions (must be done before X)
		if ((X35{r35}.y-Y_MIN35 < epsilon35) || (X35{r35}.y-Y_MAX35 < epsilon35)) {
			ℝ sign35 = 0.0;
			if (X35{r35}.y-Y_MIN35 < epsilon35) sign35 = -1.0;
			else sign35 = 1.0;
			ℝ² n35 = sign35 * nY35;
      		ℝ²ˣ² nxn35 = tensProduct35(n35,n35);
      		ℝ²ˣ² IcP35 = I35 - nxn35;
			bt1{r35} = matVectProduct35(IcP35, b35{r35});
			Mt1{r35} = IcP35 * (Ar35{r35} * IcP35) + nxn35*trace35(Ar35{r35});
		}

		// X boundary conditions
		if ((Math.fabs(X35{r35}.x-X_MIN35) < epsilon35) || ( (Math.fabs(X35{r35}.x-X_MAX35) < epsilon35) )) {
			Mt35{r35} = I35;
			bt35{r35} = {0.0, 0.0};
		}
	}
}


ComputeU35: ∀r35∈nodes35(), ur35{r35} = matVectProduct35(inverse35(Mt35{r35}), bt35{r35});
ComputeV35: ∀j35∈cells35(), V35{j35} = 0.5 * ∑{r35∈nodesOfCell35(j35)}(dot(C35{j35,r35},X35{r35}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn35: ∀n35∈ℕ, ∀r035∈nodes35(), X35{r035}^{n35=0}=coord35{r035}; , ∀r35∈nodes35(), X35{r35}^{n35+1}=X35{r35}^{n35}+δt35^{n35}*ur35{r35};
ComputeUn35: ∀n35∈ℕ, ∀j035∈cells35(), uj35{j035}^{n35=0}={0.0,0.0}; , ∀j35∈cells35(), uj35{j35}^{n35+1}=uj35{j35}^{n35}-(δt35^{n35}/m35{j35})*∑{r35∈nodesOfCell35(j35)}(F35{j35,r35});
ComputeEn35: ∀n35∈ℕ, ∀j035∈cells35(), E35{j035}^{n35=0}=p_ic35{j035}/((γ35-1.0)*ρ_ic35{j035}); , ∀j35∈cells35(), E35{j35}^{n35+1}=E35{j35}^{n35} - (δt35^{n35} / m35{j35}) * ∑{r35∈nodesOfCell35(j35)}(dot(F35{j35,r35},ur35{r35}));
ComputeDt35: ∀n35∈ℕ, δt35^{n35=0}=option_δt_ini35;, δt35^{n35+1}=option_δt_cfl35*reduceMin{j35∈cells35()}(δtj35{j35});
ComputeTn35: ∀n35∈ℕ, t35^{n35=0}=0.0; , t35^{n35+1}=t35^{n35}+δt35^{n35+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter36: ∀j36∈cells36(), center36{j36} = (1.0/4.0) * ∑{r36∈nodesOfCell36(j36)}(coord36{r36});
IniIc36: ∀j36∈cells36(), if (center36{j36}.x < option_x_interface36) {
  ρ_ic36{j36}=option_ρ_ini_zg36;
  p_ic36{j36}=option_p_ini_zg36;
} else {
  ρ_ic36{j36}=option_ρ_ini_zd36;
  p_ic36{j36}=option_p_ini_zd36;
}

ComputeCjrIc36: ∀j36∈cells36(), ∀r36∈nodesOfCell36(j36), 
	C_ic36{j36,r36} = 0.5 * perp36(coord36{►(r36)} - coord36{◄(r36)});
IniVIc36: ∀j36∈cells36(), V_ic36{j36} = 0.5 * ∑{r36∈nodesOfCell36(j36)}(dot(C_ic36{j36,r36}, coord36{r36}));
IniM36: ∀j36∈cells36(), m36{j36} = ρ_ic36{j36} * V_ic36{j36}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr36: ∀j36∈cells36(), ∀r36∈nodesOfCell36(j36), C36{j36,r36} = 0.5 * perp36(X36{►(r36)} - X36{◄(r36)});
ComputeLjr36: ∀j36∈cells36(), ∀r36∈nodesOfCell36(j36), l36{j36,r36} = norm(C36{j36,r36});
Computeδtj36: ∀j36∈cells36(), δtj36{j36} = 2.0 * V36{j36} / (c36{j36} * ∑{r36∈nodesOfCell36(j36)}(l36{j36,r36}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity36: ∀j36∈cells36(), ρ36{j36} = m36{j36} / V36{j36};
ComputeEOSp36: ∀j36∈cells36(), p36{j36} = (γ36-1.0) * ρ36{j36} * e36{j36};
ComputeInternalEngergy36: ∀j36∈cells36(), e36{j36} = E36{j36} - 0.5 * dot(uj36{j36}, uj36{j36});
ComputeEOSc36: ∀j36∈cells36(), c36{j36} = √(γ36*p36{j36}/ρ36{j36}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr36: ∀j36∈cells36(), ∀r36∈nodesOfCell36(j36), Ajr36{j36,r36} = ((ρ36{j36}*c36{j36})/l36{j36,r36}) * tensProduct36(C36{j36,r36}, C36{j36,r36});
ComputeFjr36: ∀j36∈cells36(), ∀r36∈nodesOfCell36(j36), F36{j36,r36} = p36{j36}*C36{j36,r36} + matVectProduct36(Ajr36{j36,r36}, (uj36{j36}-ur36{r36}));
ComputeAr36: ∀r36∈nodes36(), Ar36{r36} = ∑{j36∈cellsOfNode36(r36)}(Ajr36{j36,r36});
ComputeBr36: ∀r36∈nodes36(), b36{r36} = ∑{j36∈cellsOfNode36(r36)}(p36{j36}*C36{j36,r36} + matVectProduct36(Ajr36{j36,r36}, uj36{j36}));
ComputeMt36: ∀r36∈innerNodes36(), Mt36{r36} = Ar36{r36};
ComputeBt36: ∀r36∈innerNodes36(), bt36{r36} = b36{r36};

OuterFacesComputations36: ∀k36∈outerFaces36(), {
	const ℝ epsilon36 = 1.0e-10;
	ℝ²ˣ² I36 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN36 = 0.0;
	ℝ X_MAX36 = X_EDGE_ELEMS36 * LENGTH36;
	ℝ Y_MIN36 = 0.0; 
	ℝ Y_MAX36 = Y_EDGE_ELEMS36 * LENGTH36;
	ℝ² nY36 = {0.0,1.0};
	
	∀r36∈nodesOfFace36(k36), {
		// Y boundary conditions (must be done before X)
		if ((X36{r36}.y-Y_MIN36 < epsilon36) || (X36{r36}.y-Y_MAX36 < epsilon36)) {
			ℝ sign36 = 0.0;
			if (X36{r36}.y-Y_MIN36 < epsilon36) sign36 = -1.0;
			else sign36 = 1.0;
			ℝ² n36 = sign36 * nY36;
      		ℝ²ˣ² nxn36 = tensProduct36(n36,n36);
      		ℝ²ˣ² IcP36 = I36 - nxn36;
			bt1{r36} = matVectProduct36(IcP36, b36{r36});
			Mt1{r36} = IcP36 * (Ar36{r36} * IcP36) + nxn36*trace36(Ar36{r36});
		}

		// X boundary conditions
		if ((Math.fabs(X36{r36}.x-X_MIN36) < epsilon36) || ( (Math.fabs(X36{r36}.x-X_MAX36) < epsilon36) )) {
			Mt36{r36} = I36;
			bt36{r36} = {0.0, 0.0};
		}
	}
}


ComputeU36: ∀r36∈nodes36(), ur36{r36} = matVectProduct36(inverse36(Mt36{r36}), bt36{r36});
ComputeV36: ∀j36∈cells36(), V36{j36} = 0.5 * ∑{r36∈nodesOfCell36(j36)}(dot(C36{j36,r36},X36{r36}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn36: ∀n36∈ℕ, ∀r036∈nodes36(), X36{r036}^{n36=0}=coord36{r036}; , ∀r36∈nodes36(), X36{r36}^{n36+1}=X36{r36}^{n36}+δt36^{n36}*ur36{r36};
ComputeUn36: ∀n36∈ℕ, ∀j036∈cells36(), uj36{j036}^{n36=0}={0.0,0.0}; , ∀j36∈cells36(), uj36{j36}^{n36+1}=uj36{j36}^{n36}-(δt36^{n36}/m36{j36})*∑{r36∈nodesOfCell36(j36)}(F36{j36,r36});
ComputeEn36: ∀n36∈ℕ, ∀j036∈cells36(), E36{j036}^{n36=0}=p_ic36{j036}/((γ36-1.0)*ρ_ic36{j036}); , ∀j36∈cells36(), E36{j36}^{n36+1}=E36{j36}^{n36} - (δt36^{n36} / m36{j36}) * ∑{r36∈nodesOfCell36(j36)}(dot(F36{j36,r36},ur36{r36}));
ComputeDt36: ∀n36∈ℕ, δt36^{n36=0}=option_δt_ini36;, δt36^{n36+1}=option_δt_cfl36*reduceMin{j36∈cells36()}(δtj36{j36});
ComputeTn36: ∀n36∈ℕ, t36^{n36=0}=0.0; , t36^{n36+1}=t36^{n36}+δt36^{n36+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter37: ∀j37∈cells37(), center37{j37} = (1.0/4.0) * ∑{r37∈nodesOfCell37(j37)}(coord37{r37});
IniIc37: ∀j37∈cells37(), if (center37{j37}.x < option_x_interface37) {
  ρ_ic37{j37}=option_ρ_ini_zg37;
  p_ic37{j37}=option_p_ini_zg37;
} else {
  ρ_ic37{j37}=option_ρ_ini_zd37;
  p_ic37{j37}=option_p_ini_zd37;
}

ComputeCjrIc37: ∀j37∈cells37(), ∀r37∈nodesOfCell37(j37), 
	C_ic37{j37,r37} = 0.5 * perp37(coord37{►(r37)} - coord37{◄(r37)});
IniVIc37: ∀j37∈cells37(), V_ic37{j37} = 0.5 * ∑{r37∈nodesOfCell37(j37)}(dot(C_ic37{j37,r37}, coord37{r37}));
IniM37: ∀j37∈cells37(), m37{j37} = ρ_ic37{j37} * V_ic37{j37}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr37: ∀j37∈cells37(), ∀r37∈nodesOfCell37(j37), C37{j37,r37} = 0.5 * perp37(X37{►(r37)} - X37{◄(r37)});
ComputeLjr37: ∀j37∈cells37(), ∀r37∈nodesOfCell37(j37), l37{j37,r37} = norm(C37{j37,r37});
Computeδtj37: ∀j37∈cells37(), δtj37{j37} = 2.0 * V37{j37} / (c37{j37} * ∑{r37∈nodesOfCell37(j37)}(l37{j37,r37}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity37: ∀j37∈cells37(), ρ37{j37} = m37{j37} / V37{j37};
ComputeEOSp37: ∀j37∈cells37(), p37{j37} = (γ37-1.0) * ρ37{j37} * e37{j37};
ComputeInternalEngergy37: ∀j37∈cells37(), e37{j37} = E37{j37} - 0.5 * dot(uj37{j37}, uj37{j37});
ComputeEOSc37: ∀j37∈cells37(), c37{j37} = √(γ37*p37{j37}/ρ37{j37}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr37: ∀j37∈cells37(), ∀r37∈nodesOfCell37(j37), Ajr37{j37,r37} = ((ρ37{j37}*c37{j37})/l37{j37,r37}) * tensProduct37(C37{j37,r37}, C37{j37,r37});
ComputeFjr37: ∀j37∈cells37(), ∀r37∈nodesOfCell37(j37), F37{j37,r37} = p37{j37}*C37{j37,r37} + matVectProduct37(Ajr37{j37,r37}, (uj37{j37}-ur37{r37}));
ComputeAr37: ∀r37∈nodes37(), Ar37{r37} = ∑{j37∈cellsOfNode37(r37)}(Ajr37{j37,r37});
ComputeBr37: ∀r37∈nodes37(), b37{r37} = ∑{j37∈cellsOfNode37(r37)}(p37{j37}*C37{j37,r37} + matVectProduct37(Ajr37{j37,r37}, uj37{j37}));
ComputeMt37: ∀r37∈innerNodes37(), Mt37{r37} = Ar37{r37};
ComputeBt37: ∀r37∈innerNodes37(), bt37{r37} = b37{r37};

OuterFacesComputations37: ∀k37∈outerFaces37(), {
	const ℝ epsilon37 = 1.0e-10;
	ℝ²ˣ² I37 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN37 = 0.0;
	ℝ X_MAX37 = X_EDGE_ELEMS37 * LENGTH37;
	ℝ Y_MIN37 = 0.0; 
	ℝ Y_MAX37 = Y_EDGE_ELEMS37 * LENGTH37;
	ℝ² nY37 = {0.0,1.0};
	
	∀r37∈nodesOfFace37(k37), {
		// Y boundary conditions (must be done before X)
		if ((X37{r37}.y-Y_MIN37 < epsilon37) || (X37{r37}.y-Y_MAX37 < epsilon37)) {
			ℝ sign37 = 0.0;
			if (X37{r37}.y-Y_MIN37 < epsilon37) sign37 = -1.0;
			else sign37 = 1.0;
			ℝ² n37 = sign37 * nY37;
      		ℝ²ˣ² nxn37 = tensProduct37(n37,n37);
      		ℝ²ˣ² IcP37 = I37 - nxn37;
			bt1{r37} = matVectProduct37(IcP37, b37{r37});
			Mt1{r37} = IcP37 * (Ar37{r37} * IcP37) + nxn37*trace37(Ar37{r37});
		}

		// X boundary conditions
		if ((Math.fabs(X37{r37}.x-X_MIN37) < epsilon37) || ( (Math.fabs(X37{r37}.x-X_MAX37) < epsilon37) )) {
			Mt37{r37} = I37;
			bt37{r37} = {0.0, 0.0};
		}
	}
}


ComputeU37: ∀r37∈nodes37(), ur37{r37} = matVectProduct37(inverse37(Mt37{r37}), bt37{r37});
ComputeV37: ∀j37∈cells37(), V37{j37} = 0.5 * ∑{r37∈nodesOfCell37(j37)}(dot(C37{j37,r37},X37{r37}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn37: ∀n37∈ℕ, ∀r037∈nodes37(), X37{r037}^{n37=0}=coord37{r037}; , ∀r37∈nodes37(), X37{r37}^{n37+1}=X37{r37}^{n37}+δt37^{n37}*ur37{r37};
ComputeUn37: ∀n37∈ℕ, ∀j037∈cells37(), uj37{j037}^{n37=0}={0.0,0.0}; , ∀j37∈cells37(), uj37{j37}^{n37+1}=uj37{j37}^{n37}-(δt37^{n37}/m37{j37})*∑{r37∈nodesOfCell37(j37)}(F37{j37,r37});
ComputeEn37: ∀n37∈ℕ, ∀j037∈cells37(), E37{j037}^{n37=0}=p_ic37{j037}/((γ37-1.0)*ρ_ic37{j037}); , ∀j37∈cells37(), E37{j37}^{n37+1}=E37{j37}^{n37} - (δt37^{n37} / m37{j37}) * ∑{r37∈nodesOfCell37(j37)}(dot(F37{j37,r37},ur37{r37}));
ComputeDt37: ∀n37∈ℕ, δt37^{n37=0}=option_δt_ini37;, δt37^{n37+1}=option_δt_cfl37*reduceMin{j37∈cells37()}(δtj37{j37});
ComputeTn37: ∀n37∈ℕ, t37^{n37=0}=0.0; , t37^{n37+1}=t37^{n37}+δt37^{n37+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter38: ∀j38∈cells38(), center38{j38} = (1.0/4.0) * ∑{r38∈nodesOfCell38(j38)}(coord38{r38});
IniIc38: ∀j38∈cells38(), if (center38{j38}.x < option_x_interface38) {
  ρ_ic38{j38}=option_ρ_ini_zg38;
  p_ic38{j38}=option_p_ini_zg38;
} else {
  ρ_ic38{j38}=option_ρ_ini_zd38;
  p_ic38{j38}=option_p_ini_zd38;
}

ComputeCjrIc38: ∀j38∈cells38(), ∀r38∈nodesOfCell38(j38), 
	C_ic38{j38,r38} = 0.5 * perp38(coord38{►(r38)} - coord38{◄(r38)});
IniVIc38: ∀j38∈cells38(), V_ic38{j38} = 0.5 * ∑{r38∈nodesOfCell38(j38)}(dot(C_ic38{j38,r38}, coord38{r38}));
IniM38: ∀j38∈cells38(), m38{j38} = ρ_ic38{j38} * V_ic38{j38}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr38: ∀j38∈cells38(), ∀r38∈nodesOfCell38(j38), C38{j38,r38} = 0.5 * perp38(X38{►(r38)} - X38{◄(r38)});
ComputeLjr38: ∀j38∈cells38(), ∀r38∈nodesOfCell38(j38), l38{j38,r38} = norm(C38{j38,r38});
Computeδtj38: ∀j38∈cells38(), δtj38{j38} = 2.0 * V38{j38} / (c38{j38} * ∑{r38∈nodesOfCell38(j38)}(l38{j38,r38}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity38: ∀j38∈cells38(), ρ38{j38} = m38{j38} / V38{j38};
ComputeEOSp38: ∀j38∈cells38(), p38{j38} = (γ38-1.0) * ρ38{j38} * e38{j38};
ComputeInternalEngergy38: ∀j38∈cells38(), e38{j38} = E38{j38} - 0.5 * dot(uj38{j38}, uj38{j38});
ComputeEOSc38: ∀j38∈cells38(), c38{j38} = √(γ38*p38{j38}/ρ38{j38}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr38: ∀j38∈cells38(), ∀r38∈nodesOfCell38(j38), Ajr38{j38,r38} = ((ρ38{j38}*c38{j38})/l38{j38,r38}) * tensProduct38(C38{j38,r38}, C38{j38,r38});
ComputeFjr38: ∀j38∈cells38(), ∀r38∈nodesOfCell38(j38), F38{j38,r38} = p38{j38}*C38{j38,r38} + matVectProduct38(Ajr38{j38,r38}, (uj38{j38}-ur38{r38}));
ComputeAr38: ∀r38∈nodes38(), Ar38{r38} = ∑{j38∈cellsOfNode38(r38)}(Ajr38{j38,r38});
ComputeBr38: ∀r38∈nodes38(), b38{r38} = ∑{j38∈cellsOfNode38(r38)}(p38{j38}*C38{j38,r38} + matVectProduct38(Ajr38{j38,r38}, uj38{j38}));
ComputeMt38: ∀r38∈innerNodes38(), Mt38{r38} = Ar38{r38};
ComputeBt38: ∀r38∈innerNodes38(), bt38{r38} = b38{r38};

OuterFacesComputations38: ∀k38∈outerFaces38(), {
	const ℝ epsilon38 = 1.0e-10;
	ℝ²ˣ² I38 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN38 = 0.0;
	ℝ X_MAX38 = X_EDGE_ELEMS38 * LENGTH38;
	ℝ Y_MIN38 = 0.0; 
	ℝ Y_MAX38 = Y_EDGE_ELEMS38 * LENGTH38;
	ℝ² nY38 = {0.0,1.0};
	
	∀r38∈nodesOfFace38(k38), {
		// Y boundary conditions (must be done before X)
		if ((X38{r38}.y-Y_MIN38 < epsilon38) || (X38{r38}.y-Y_MAX38 < epsilon38)) {
			ℝ sign38 = 0.0;
			if (X38{r38}.y-Y_MIN38 < epsilon38) sign38 = -1.0;
			else sign38 = 1.0;
			ℝ² n38 = sign38 * nY38;
      		ℝ²ˣ² nxn38 = tensProduct38(n38,n38);
      		ℝ²ˣ² IcP38 = I38 - nxn38;
			bt1{r38} = matVectProduct38(IcP38, b38{r38});
			Mt1{r38} = IcP38 * (Ar38{r38} * IcP38) + nxn38*trace38(Ar38{r38});
		}

		// X boundary conditions
		if ((Math.fabs(X38{r38}.x-X_MIN38) < epsilon38) || ( (Math.fabs(X38{r38}.x-X_MAX38) < epsilon38) )) {
			Mt38{r38} = I38;
			bt38{r38} = {0.0, 0.0};
		}
	}
}


ComputeU38: ∀r38∈nodes38(), ur38{r38} = matVectProduct38(inverse38(Mt38{r38}), bt38{r38});
ComputeV38: ∀j38∈cells38(), V38{j38} = 0.5 * ∑{r38∈nodesOfCell38(j38)}(dot(C38{j38,r38},X38{r38}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn38: ∀n38∈ℕ, ∀r038∈nodes38(), X38{r038}^{n38=0}=coord38{r038}; , ∀r38∈nodes38(), X38{r38}^{n38+1}=X38{r38}^{n38}+δt38^{n38}*ur38{r38};
ComputeUn38: ∀n38∈ℕ, ∀j038∈cells38(), uj38{j038}^{n38=0}={0.0,0.0}; , ∀j38∈cells38(), uj38{j38}^{n38+1}=uj38{j38}^{n38}-(δt38^{n38}/m38{j38})*∑{r38∈nodesOfCell38(j38)}(F38{j38,r38});
ComputeEn38: ∀n38∈ℕ, ∀j038∈cells38(), E38{j038}^{n38=0}=p_ic38{j038}/((γ38-1.0)*ρ_ic38{j038}); , ∀j38∈cells38(), E38{j38}^{n38+1}=E38{j38}^{n38} - (δt38^{n38} / m38{j38}) * ∑{r38∈nodesOfCell38(j38)}(dot(F38{j38,r38},ur38{r38}));
ComputeDt38: ∀n38∈ℕ, δt38^{n38=0}=option_δt_ini38;, δt38^{n38+1}=option_δt_cfl38*reduceMin{j38∈cells38()}(δtj38{j38});
ComputeTn38: ∀n38∈ℕ, t38^{n38=0}=0.0; , t38^{n38+1}=t38^{n38}+δt38^{n38+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter39: ∀j39∈cells39(), center39{j39} = (1.0/4.0) * ∑{r39∈nodesOfCell39(j39)}(coord39{r39});
IniIc39: ∀j39∈cells39(), if (center39{j39}.x < option_x_interface39) {
  ρ_ic39{j39}=option_ρ_ini_zg39;
  p_ic39{j39}=option_p_ini_zg39;
} else {
  ρ_ic39{j39}=option_ρ_ini_zd39;
  p_ic39{j39}=option_p_ini_zd39;
}

ComputeCjrIc39: ∀j39∈cells39(), ∀r39∈nodesOfCell39(j39), 
	C_ic39{j39,r39} = 0.5 * perp39(coord39{►(r39)} - coord39{◄(r39)});
IniVIc39: ∀j39∈cells39(), V_ic39{j39} = 0.5 * ∑{r39∈nodesOfCell39(j39)}(dot(C_ic39{j39,r39}, coord39{r39}));
IniM39: ∀j39∈cells39(), m39{j39} = ρ_ic39{j39} * V_ic39{j39}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr39: ∀j39∈cells39(), ∀r39∈nodesOfCell39(j39), C39{j39,r39} = 0.5 * perp39(X39{►(r39)} - X39{◄(r39)});
ComputeLjr39: ∀j39∈cells39(), ∀r39∈nodesOfCell39(j39), l39{j39,r39} = norm(C39{j39,r39});
Computeδtj39: ∀j39∈cells39(), δtj39{j39} = 2.0 * V39{j39} / (c39{j39} * ∑{r39∈nodesOfCell39(j39)}(l39{j39,r39}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity39: ∀j39∈cells39(), ρ39{j39} = m39{j39} / V39{j39};
ComputeEOSp39: ∀j39∈cells39(), p39{j39} = (γ39-1.0) * ρ39{j39} * e39{j39};
ComputeInternalEngergy39: ∀j39∈cells39(), e39{j39} = E39{j39} - 0.5 * dot(uj39{j39}, uj39{j39});
ComputeEOSc39: ∀j39∈cells39(), c39{j39} = √(γ39*p39{j39}/ρ39{j39}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr39: ∀j39∈cells39(), ∀r39∈nodesOfCell39(j39), Ajr39{j39,r39} = ((ρ39{j39}*c39{j39})/l39{j39,r39}) * tensProduct39(C39{j39,r39}, C39{j39,r39});
ComputeFjr39: ∀j39∈cells39(), ∀r39∈nodesOfCell39(j39), F39{j39,r39} = p39{j39}*C39{j39,r39} + matVectProduct39(Ajr39{j39,r39}, (uj39{j39}-ur39{r39}));
ComputeAr39: ∀r39∈nodes39(), Ar39{r39} = ∑{j39∈cellsOfNode39(r39)}(Ajr39{j39,r39});
ComputeBr39: ∀r39∈nodes39(), b39{r39} = ∑{j39∈cellsOfNode39(r39)}(p39{j39}*C39{j39,r39} + matVectProduct39(Ajr39{j39,r39}, uj39{j39}));
ComputeMt39: ∀r39∈innerNodes39(), Mt39{r39} = Ar39{r39};
ComputeBt39: ∀r39∈innerNodes39(), bt39{r39} = b39{r39};

OuterFacesComputations39: ∀k39∈outerFaces39(), {
	const ℝ epsilon39 = 1.0e-10;
	ℝ²ˣ² I39 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN39 = 0.0;
	ℝ X_MAX39 = X_EDGE_ELEMS39 * LENGTH39;
	ℝ Y_MIN39 = 0.0; 
	ℝ Y_MAX39 = Y_EDGE_ELEMS39 * LENGTH39;
	ℝ² nY39 = {0.0,1.0};
	
	∀r39∈nodesOfFace39(k39), {
		// Y boundary conditions (must be done before X)
		if ((X39{r39}.y-Y_MIN39 < epsilon39) || (X39{r39}.y-Y_MAX39 < epsilon39)) {
			ℝ sign39 = 0.0;
			if (X39{r39}.y-Y_MIN39 < epsilon39) sign39 = -1.0;
			else sign39 = 1.0;
			ℝ² n39 = sign39 * nY39;
      		ℝ²ˣ² nxn39 = tensProduct39(n39,n39);
      		ℝ²ˣ² IcP39 = I39 - nxn39;
			bt1{r39} = matVectProduct39(IcP39, b39{r39});
			Mt1{r39} = IcP39 * (Ar39{r39} * IcP39) + nxn39*trace39(Ar39{r39});
		}

		// X boundary conditions
		if ((Math.fabs(X39{r39}.x-X_MIN39) < epsilon39) || ( (Math.fabs(X39{r39}.x-X_MAX39) < epsilon39) )) {
			Mt39{r39} = I39;
			bt39{r39} = {0.0, 0.0};
		}
	}
}


ComputeU39: ∀r39∈nodes39(), ur39{r39} = matVectProduct39(inverse39(Mt39{r39}), bt39{r39});
ComputeV39: ∀j39∈cells39(), V39{j39} = 0.5 * ∑{r39∈nodesOfCell39(j39)}(dot(C39{j39,r39},X39{r39}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn39: ∀n39∈ℕ, ∀r039∈nodes39(), X39{r039}^{n39=0}=coord39{r039}; , ∀r39∈nodes39(), X39{r39}^{n39+1}=X39{r39}^{n39}+δt39^{n39}*ur39{r39};
ComputeUn39: ∀n39∈ℕ, ∀j039∈cells39(), uj39{j039}^{n39=0}={0.0,0.0}; , ∀j39∈cells39(), uj39{j39}^{n39+1}=uj39{j39}^{n39}-(δt39^{n39}/m39{j39})*∑{r39∈nodesOfCell39(j39)}(F39{j39,r39});
ComputeEn39: ∀n39∈ℕ, ∀j039∈cells39(), E39{j039}^{n39=0}=p_ic39{j039}/((γ39-1.0)*ρ_ic39{j039}); , ∀j39∈cells39(), E39{j39}^{n39+1}=E39{j39}^{n39} - (δt39^{n39} / m39{j39}) * ∑{r39∈nodesOfCell39(j39)}(dot(F39{j39,r39},ur39{r39}));
ComputeDt39: ∀n39∈ℕ, δt39^{n39=0}=option_δt_ini39;, δt39^{n39+1}=option_δt_cfl39*reduceMin{j39∈cells39()}(δtj39{j39});
ComputeTn39: ∀n39∈ℕ, t39^{n39=0}=0.0; , t39^{n39+1}=t39^{n39}+δt39^{n39+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter40: ∀j40∈cells40(), center40{j40} = (1.0/4.0) * ∑{r40∈nodesOfCell40(j40)}(coord40{r40});
IniIc40: ∀j40∈cells40(), if (center40{j40}.x < option_x_interface40) {
  ρ_ic40{j40}=option_ρ_ini_zg40;
  p_ic40{j40}=option_p_ini_zg40;
} else {
  ρ_ic40{j40}=option_ρ_ini_zd40;
  p_ic40{j40}=option_p_ini_zd40;
}

ComputeCjrIc40: ∀j40∈cells40(), ∀r40∈nodesOfCell40(j40), 
	C_ic40{j40,r40} = 0.5 * perp40(coord40{►(r40)} - coord40{◄(r40)});
IniVIc40: ∀j40∈cells40(), V_ic40{j40} = 0.5 * ∑{r40∈nodesOfCell40(j40)}(dot(C_ic40{j40,r40}, coord40{r40}));
IniM40: ∀j40∈cells40(), m40{j40} = ρ_ic40{j40} * V_ic40{j40}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr40: ∀j40∈cells40(), ∀r40∈nodesOfCell40(j40), C40{j40,r40} = 0.5 * perp40(X40{►(r40)} - X40{◄(r40)});
ComputeLjr40: ∀j40∈cells40(), ∀r40∈nodesOfCell40(j40), l40{j40,r40} = norm(C40{j40,r40});
Computeδtj40: ∀j40∈cells40(), δtj40{j40} = 2.0 * V40{j40} / (c40{j40} * ∑{r40∈nodesOfCell40(j40)}(l40{j40,r40}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity40: ∀j40∈cells40(), ρ40{j40} = m40{j40} / V40{j40};
ComputeEOSp40: ∀j40∈cells40(), p40{j40} = (γ40-1.0) * ρ40{j40} * e40{j40};
ComputeInternalEngergy40: ∀j40∈cells40(), e40{j40} = E40{j40} - 0.5 * dot(uj40{j40}, uj40{j40});
ComputeEOSc40: ∀j40∈cells40(), c40{j40} = √(γ40*p40{j40}/ρ40{j40}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr40: ∀j40∈cells40(), ∀r40∈nodesOfCell40(j40), Ajr40{j40,r40} = ((ρ40{j40}*c40{j40})/l40{j40,r40}) * tensProduct40(C40{j40,r40}, C40{j40,r40});
ComputeFjr40: ∀j40∈cells40(), ∀r40∈nodesOfCell40(j40), F40{j40,r40} = p40{j40}*C40{j40,r40} + matVectProduct40(Ajr40{j40,r40}, (uj40{j40}-ur40{r40}));
ComputeAr40: ∀r40∈nodes40(), Ar40{r40} = ∑{j40∈cellsOfNode40(r40)}(Ajr40{j40,r40});
ComputeBr40: ∀r40∈nodes40(), b40{r40} = ∑{j40∈cellsOfNode40(r40)}(p40{j40}*C40{j40,r40} + matVectProduct40(Ajr40{j40,r40}, uj40{j40}));
ComputeMt40: ∀r40∈innerNodes40(), Mt40{r40} = Ar40{r40};
ComputeBt40: ∀r40∈innerNodes40(), bt40{r40} = b40{r40};

OuterFacesComputations40: ∀k40∈outerFaces40(), {
	const ℝ epsilon40 = 1.0e-10;
	ℝ²ˣ² I40 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN40 = 0.0;
	ℝ X_MAX40 = X_EDGE_ELEMS40 * LENGTH40;
	ℝ Y_MIN40 = 0.0; 
	ℝ Y_MAX40 = Y_EDGE_ELEMS40 * LENGTH40;
	ℝ² nY40 = {0.0,1.0};
	
	∀r40∈nodesOfFace40(k40), {
		// Y boundary conditions (must be done before X)
		if ((X40{r40}.y-Y_MIN40 < epsilon40) || (X40{r40}.y-Y_MAX40 < epsilon40)) {
			ℝ sign40 = 0.0;
			if (X40{r40}.y-Y_MIN40 < epsilon40) sign40 = -1.0;
			else sign40 = 1.0;
			ℝ² n40 = sign40 * nY40;
      		ℝ²ˣ² nxn40 = tensProduct40(n40,n40);
      		ℝ²ˣ² IcP40 = I40 - nxn40;
			bt1{r40} = matVectProduct40(IcP40, b40{r40});
			Mt1{r40} = IcP40 * (Ar40{r40} * IcP40) + nxn40*trace40(Ar40{r40});
		}

		// X boundary conditions
		if ((Math.fabs(X40{r40}.x-X_MIN40) < epsilon40) || ( (Math.fabs(X40{r40}.x-X_MAX40) < epsilon40) )) {
			Mt40{r40} = I40;
			bt40{r40} = {0.0, 0.0};
		}
	}
}


ComputeU40: ∀r40∈nodes40(), ur40{r40} = matVectProduct40(inverse40(Mt40{r40}), bt40{r40});
ComputeV40: ∀j40∈cells40(), V40{j40} = 0.5 * ∑{r40∈nodesOfCell40(j40)}(dot(C40{j40,r40},X40{r40}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn40: ∀n40∈ℕ, ∀r040∈nodes40(), X40{r040}^{n40=0}=coord40{r040}; , ∀r40∈nodes40(), X40{r40}^{n40+1}=X40{r40}^{n40}+δt40^{n40}*ur40{r40};
ComputeUn40: ∀n40∈ℕ, ∀j040∈cells40(), uj40{j040}^{n40=0}={0.0,0.0}; , ∀j40∈cells40(), uj40{j40}^{n40+1}=uj40{j40}^{n40}-(δt40^{n40}/m40{j40})*∑{r40∈nodesOfCell40(j40)}(F40{j40,r40});
ComputeEn40: ∀n40∈ℕ, ∀j040∈cells40(), E40{j040}^{n40=0}=p_ic40{j040}/((γ40-1.0)*ρ_ic40{j040}); , ∀j40∈cells40(), E40{j40}^{n40+1}=E40{j40}^{n40} - (δt40^{n40} / m40{j40}) * ∑{r40∈nodesOfCell40(j40)}(dot(F40{j40,r40},ur40{r40}));
ComputeDt40: ∀n40∈ℕ, δt40^{n40=0}=option_δt_ini40;, δt40^{n40+1}=option_δt_cfl40*reduceMin{j40∈cells40()}(δtj40{j40});
ComputeTn40: ∀n40∈ℕ, t40^{n40=0}=0.0; , t40^{n40+1}=t40^{n40}+δt40^{n40+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter41: ∀j41∈cells41(), center41{j41} = (1.0/4.0) * ∑{r41∈nodesOfCell41(j41)}(coord41{r41});
IniIc41: ∀j41∈cells41(), if (center41{j41}.x < option_x_interface41) {
  ρ_ic41{j41}=option_ρ_ini_zg41;
  p_ic41{j41}=option_p_ini_zg41;
} else {
  ρ_ic41{j41}=option_ρ_ini_zd41;
  p_ic41{j41}=option_p_ini_zd41;
}

ComputeCjrIc41: ∀j41∈cells41(), ∀r41∈nodesOfCell41(j41), 
	C_ic41{j41,r41} = 0.5 * perp41(coord41{►(r41)} - coord41{◄(r41)});
IniVIc41: ∀j41∈cells41(), V_ic41{j41} = 0.5 * ∑{r41∈nodesOfCell41(j41)}(dot(C_ic41{j41,r41}, coord41{r41}));
IniM41: ∀j41∈cells41(), m41{j41} = ρ_ic41{j41} * V_ic41{j41}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr41: ∀j41∈cells41(), ∀r41∈nodesOfCell41(j41), C41{j41,r41} = 0.5 * perp41(X41{►(r41)} - X41{◄(r41)});
ComputeLjr41: ∀j41∈cells41(), ∀r41∈nodesOfCell41(j41), l41{j41,r41} = norm(C41{j41,r41});
Computeδtj41: ∀j41∈cells41(), δtj41{j41} = 2.0 * V41{j41} / (c41{j41} * ∑{r41∈nodesOfCell41(j41)}(l41{j41,r41}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity41: ∀j41∈cells41(), ρ41{j41} = m41{j41} / V41{j41};
ComputeEOSp41: ∀j41∈cells41(), p41{j41} = (γ41-1.0) * ρ41{j41} * e41{j41};
ComputeInternalEngergy41: ∀j41∈cells41(), e41{j41} = E41{j41} - 0.5 * dot(uj41{j41}, uj41{j41});
ComputeEOSc41: ∀j41∈cells41(), c41{j41} = √(γ41*p41{j41}/ρ41{j41}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr41: ∀j41∈cells41(), ∀r41∈nodesOfCell41(j41), Ajr41{j41,r41} = ((ρ41{j41}*c41{j41})/l41{j41,r41}) * tensProduct41(C41{j41,r41}, C41{j41,r41});
ComputeFjr41: ∀j41∈cells41(), ∀r41∈nodesOfCell41(j41), F41{j41,r41} = p41{j41}*C41{j41,r41} + matVectProduct41(Ajr41{j41,r41}, (uj41{j41}-ur41{r41}));
ComputeAr41: ∀r41∈nodes41(), Ar41{r41} = ∑{j41∈cellsOfNode41(r41)}(Ajr41{j41,r41});
ComputeBr41: ∀r41∈nodes41(), b41{r41} = ∑{j41∈cellsOfNode41(r41)}(p41{j41}*C41{j41,r41} + matVectProduct41(Ajr41{j41,r41}, uj41{j41}));
ComputeMt41: ∀r41∈innerNodes41(), Mt41{r41} = Ar41{r41};
ComputeBt41: ∀r41∈innerNodes41(), bt41{r41} = b41{r41};

OuterFacesComputations41: ∀k41∈outerFaces41(), {
	const ℝ epsilon41 = 1.0e-10;
	ℝ²ˣ² I41 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN41 = 0.0;
	ℝ X_MAX41 = X_EDGE_ELEMS41 * LENGTH41;
	ℝ Y_MIN41 = 0.0; 
	ℝ Y_MAX41 = Y_EDGE_ELEMS41 * LENGTH41;
	ℝ² nY41 = {0.0,1.0};
	
	∀r41∈nodesOfFace41(k41), {
		// Y boundary conditions (must be done before X)
		if ((X41{r41}.y-Y_MIN41 < epsilon41) || (X41{r41}.y-Y_MAX41 < epsilon41)) {
			ℝ sign41 = 0.0;
			if (X41{r41}.y-Y_MIN41 < epsilon41) sign41 = -1.0;
			else sign41 = 1.0;
			ℝ² n41 = sign41 * nY41;
      		ℝ²ˣ² nxn41 = tensProduct41(n41,n41);
      		ℝ²ˣ² IcP41 = I41 - nxn41;
			bt1{r41} = matVectProduct41(IcP41, b41{r41});
			Mt1{r41} = IcP41 * (Ar41{r41} * IcP41) + nxn41*trace41(Ar41{r41});
		}

		// X boundary conditions
		if ((Math.fabs(X41{r41}.x-X_MIN41) < epsilon41) || ( (Math.fabs(X41{r41}.x-X_MAX41) < epsilon41) )) {
			Mt41{r41} = I41;
			bt41{r41} = {0.0, 0.0};
		}
	}
}


ComputeU41: ∀r41∈nodes41(), ur41{r41} = matVectProduct41(inverse41(Mt41{r41}), bt41{r41});
ComputeV41: ∀j41∈cells41(), V41{j41} = 0.5 * ∑{r41∈nodesOfCell41(j41)}(dot(C41{j41,r41},X41{r41}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn41: ∀n41∈ℕ, ∀r041∈nodes41(), X41{r041}^{n41=0}=coord41{r041}; , ∀r41∈nodes41(), X41{r41}^{n41+1}=X41{r41}^{n41}+δt41^{n41}*ur41{r41};
ComputeUn41: ∀n41∈ℕ, ∀j041∈cells41(), uj41{j041}^{n41=0}={0.0,0.0}; , ∀j41∈cells41(), uj41{j41}^{n41+1}=uj41{j41}^{n41}-(δt41^{n41}/m41{j41})*∑{r41∈nodesOfCell41(j41)}(F41{j41,r41});
ComputeEn41: ∀n41∈ℕ, ∀j041∈cells41(), E41{j041}^{n41=0}=p_ic41{j041}/((γ41-1.0)*ρ_ic41{j041}); , ∀j41∈cells41(), E41{j41}^{n41+1}=E41{j41}^{n41} - (δt41^{n41} / m41{j41}) * ∑{r41∈nodesOfCell41(j41)}(dot(F41{j41,r41},ur41{r41}));
ComputeDt41: ∀n41∈ℕ, δt41^{n41=0}=option_δt_ini41;, δt41^{n41+1}=option_δt_cfl41*reduceMin{j41∈cells41()}(δtj41{j41});
ComputeTn41: ∀n41∈ℕ, t41^{n41=0}=0.0; , t41^{n41+1}=t41^{n41}+δt41^{n41+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter42: ∀j42∈cells42(), center42{j42} = (1.0/4.0) * ∑{r42∈nodesOfCell42(j42)}(coord42{r42});
IniIc42: ∀j42∈cells42(), if (center42{j42}.x < option_x_interface42) {
  ρ_ic42{j42}=option_ρ_ini_zg42;
  p_ic42{j42}=option_p_ini_zg42;
} else {
  ρ_ic42{j42}=option_ρ_ini_zd42;
  p_ic42{j42}=option_p_ini_zd42;
}

ComputeCjrIc42: ∀j42∈cells42(), ∀r42∈nodesOfCell42(j42), 
	C_ic42{j42,r42} = 0.5 * perp42(coord42{►(r42)} - coord42{◄(r42)});
IniVIc42: ∀j42∈cells42(), V_ic42{j42} = 0.5 * ∑{r42∈nodesOfCell42(j42)}(dot(C_ic42{j42,r42}, coord42{r42}));
IniM42: ∀j42∈cells42(), m42{j42} = ρ_ic42{j42} * V_ic42{j42}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr42: ∀j42∈cells42(), ∀r42∈nodesOfCell42(j42), C42{j42,r42} = 0.5 * perp42(X42{►(r42)} - X42{◄(r42)});
ComputeLjr42: ∀j42∈cells42(), ∀r42∈nodesOfCell42(j42), l42{j42,r42} = norm(C42{j42,r42});
Computeδtj42: ∀j42∈cells42(), δtj42{j42} = 2.0 * V42{j42} / (c42{j42} * ∑{r42∈nodesOfCell42(j42)}(l42{j42,r42}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity42: ∀j42∈cells42(), ρ42{j42} = m42{j42} / V42{j42};
ComputeEOSp42: ∀j42∈cells42(), p42{j42} = (γ42-1.0) * ρ42{j42} * e42{j42};
ComputeInternalEngergy42: ∀j42∈cells42(), e42{j42} = E42{j42} - 0.5 * dot(uj42{j42}, uj42{j42});
ComputeEOSc42: ∀j42∈cells42(), c42{j42} = √(γ42*p42{j42}/ρ42{j42}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr42: ∀j42∈cells42(), ∀r42∈nodesOfCell42(j42), Ajr42{j42,r42} = ((ρ42{j42}*c42{j42})/l42{j42,r42}) * tensProduct42(C42{j42,r42}, C42{j42,r42});
ComputeFjr42: ∀j42∈cells42(), ∀r42∈nodesOfCell42(j42), F42{j42,r42} = p42{j42}*C42{j42,r42} + matVectProduct42(Ajr42{j42,r42}, (uj42{j42}-ur42{r42}));
ComputeAr42: ∀r42∈nodes42(), Ar42{r42} = ∑{j42∈cellsOfNode42(r42)}(Ajr42{j42,r42});
ComputeBr42: ∀r42∈nodes42(), b42{r42} = ∑{j42∈cellsOfNode42(r42)}(p42{j42}*C42{j42,r42} + matVectProduct42(Ajr42{j42,r42}, uj42{j42}));
ComputeMt42: ∀r42∈innerNodes42(), Mt42{r42} = Ar42{r42};
ComputeBt42: ∀r42∈innerNodes42(), bt42{r42} = b42{r42};

OuterFacesComputations42: ∀k42∈outerFaces42(), {
	const ℝ epsilon42 = 1.0e-10;
	ℝ²ˣ² I42 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN42 = 0.0;
	ℝ X_MAX42 = X_EDGE_ELEMS42 * LENGTH42;
	ℝ Y_MIN42 = 0.0; 
	ℝ Y_MAX42 = Y_EDGE_ELEMS42 * LENGTH42;
	ℝ² nY42 = {0.0,1.0};
	
	∀r42∈nodesOfFace42(k42), {
		// Y boundary conditions (must be done before X)
		if ((X42{r42}.y-Y_MIN42 < epsilon42) || (X42{r42}.y-Y_MAX42 < epsilon42)) {
			ℝ sign42 = 0.0;
			if (X42{r42}.y-Y_MIN42 < epsilon42) sign42 = -1.0;
			else sign42 = 1.0;
			ℝ² n42 = sign42 * nY42;
      		ℝ²ˣ² nxn42 = tensProduct42(n42,n42);
      		ℝ²ˣ² IcP42 = I42 - nxn42;
			bt1{r42} = matVectProduct42(IcP42, b42{r42});
			Mt1{r42} = IcP42 * (Ar42{r42} * IcP42) + nxn42*trace42(Ar42{r42});
		}

		// X boundary conditions
		if ((Math.fabs(X42{r42}.x-X_MIN42) < epsilon42) || ( (Math.fabs(X42{r42}.x-X_MAX42) < epsilon42) )) {
			Mt42{r42} = I42;
			bt42{r42} = {0.0, 0.0};
		}
	}
}


ComputeU42: ∀r42∈nodes42(), ur42{r42} = matVectProduct42(inverse42(Mt42{r42}), bt42{r42});
ComputeV42: ∀j42∈cells42(), V42{j42} = 0.5 * ∑{r42∈nodesOfCell42(j42)}(dot(C42{j42,r42},X42{r42}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn42: ∀n42∈ℕ, ∀r042∈nodes42(), X42{r042}^{n42=0}=coord42{r042}; , ∀r42∈nodes42(), X42{r42}^{n42+1}=X42{r42}^{n42}+δt42^{n42}*ur42{r42};
ComputeUn42: ∀n42∈ℕ, ∀j042∈cells42(), uj42{j042}^{n42=0}={0.0,0.0}; , ∀j42∈cells42(), uj42{j42}^{n42+1}=uj42{j42}^{n42}-(δt42^{n42}/m42{j42})*∑{r42∈nodesOfCell42(j42)}(F42{j42,r42});
ComputeEn42: ∀n42∈ℕ, ∀j042∈cells42(), E42{j042}^{n42=0}=p_ic42{j042}/((γ42-1.0)*ρ_ic42{j042}); , ∀j42∈cells42(), E42{j42}^{n42+1}=E42{j42}^{n42} - (δt42^{n42} / m42{j42}) * ∑{r42∈nodesOfCell42(j42)}(dot(F42{j42,r42},ur42{r42}));
ComputeDt42: ∀n42∈ℕ, δt42^{n42=0}=option_δt_ini42;, δt42^{n42+1}=option_δt_cfl42*reduceMin{j42∈cells42()}(δtj42{j42});
ComputeTn42: ∀n42∈ℕ, t42^{n42=0}=0.0; , t42^{n42+1}=t42^{n42}+δt42^{n42+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter43: ∀j43∈cells43(), center43{j43} = (1.0/4.0) * ∑{r43∈nodesOfCell43(j43)}(coord43{r43});
IniIc43: ∀j43∈cells43(), if (center43{j43}.x < option_x_interface43) {
  ρ_ic43{j43}=option_ρ_ini_zg43;
  p_ic43{j43}=option_p_ini_zg43;
} else {
  ρ_ic43{j43}=option_ρ_ini_zd43;
  p_ic43{j43}=option_p_ini_zd43;
}

ComputeCjrIc43: ∀j43∈cells43(), ∀r43∈nodesOfCell43(j43), 
	C_ic43{j43,r43} = 0.5 * perp43(coord43{►(r43)} - coord43{◄(r43)});
IniVIc43: ∀j43∈cells43(), V_ic43{j43} = 0.5 * ∑{r43∈nodesOfCell43(j43)}(dot(C_ic43{j43,r43}, coord43{r43}));
IniM43: ∀j43∈cells43(), m43{j43} = ρ_ic43{j43} * V_ic43{j43}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr43: ∀j43∈cells43(), ∀r43∈nodesOfCell43(j43), C43{j43,r43} = 0.5 * perp43(X43{►(r43)} - X43{◄(r43)});
ComputeLjr43: ∀j43∈cells43(), ∀r43∈nodesOfCell43(j43), l43{j43,r43} = norm(C43{j43,r43});
Computeδtj43: ∀j43∈cells43(), δtj43{j43} = 2.0 * V43{j43} / (c43{j43} * ∑{r43∈nodesOfCell43(j43)}(l43{j43,r43}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity43: ∀j43∈cells43(), ρ43{j43} = m43{j43} / V43{j43};
ComputeEOSp43: ∀j43∈cells43(), p43{j43} = (γ43-1.0) * ρ43{j43} * e43{j43};
ComputeInternalEngergy43: ∀j43∈cells43(), e43{j43} = E43{j43} - 0.5 * dot(uj43{j43}, uj43{j43});
ComputeEOSc43: ∀j43∈cells43(), c43{j43} = √(γ43*p43{j43}/ρ43{j43}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr43: ∀j43∈cells43(), ∀r43∈nodesOfCell43(j43), Ajr43{j43,r43} = ((ρ43{j43}*c43{j43})/l43{j43,r43}) * tensProduct43(C43{j43,r43}, C43{j43,r43});
ComputeFjr43: ∀j43∈cells43(), ∀r43∈nodesOfCell43(j43), F43{j43,r43} = p43{j43}*C43{j43,r43} + matVectProduct43(Ajr43{j43,r43}, (uj43{j43}-ur43{r43}));
ComputeAr43: ∀r43∈nodes43(), Ar43{r43} = ∑{j43∈cellsOfNode43(r43)}(Ajr43{j43,r43});
ComputeBr43: ∀r43∈nodes43(), b43{r43} = ∑{j43∈cellsOfNode43(r43)}(p43{j43}*C43{j43,r43} + matVectProduct43(Ajr43{j43,r43}, uj43{j43}));
ComputeMt43: ∀r43∈innerNodes43(), Mt43{r43} = Ar43{r43};
ComputeBt43: ∀r43∈innerNodes43(), bt43{r43} = b43{r43};

OuterFacesComputations43: ∀k43∈outerFaces43(), {
	const ℝ epsilon43 = 1.0e-10;
	ℝ²ˣ² I43 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN43 = 0.0;
	ℝ X_MAX43 = X_EDGE_ELEMS43 * LENGTH43;
	ℝ Y_MIN43 = 0.0; 
	ℝ Y_MAX43 = Y_EDGE_ELEMS43 * LENGTH43;
	ℝ² nY43 = {0.0,1.0};
	
	∀r43∈nodesOfFace43(k43), {
		// Y boundary conditions (must be done before X)
		if ((X43{r43}.y-Y_MIN43 < epsilon43) || (X43{r43}.y-Y_MAX43 < epsilon43)) {
			ℝ sign43 = 0.0;
			if (X43{r43}.y-Y_MIN43 < epsilon43) sign43 = -1.0;
			else sign43 = 1.0;
			ℝ² n43 = sign43 * nY43;
      		ℝ²ˣ² nxn43 = tensProduct43(n43,n43);
      		ℝ²ˣ² IcP43 = I43 - nxn43;
			bt1{r43} = matVectProduct43(IcP43, b43{r43});
			Mt1{r43} = IcP43 * (Ar43{r43} * IcP43) + nxn43*trace43(Ar43{r43});
		}

		// X boundary conditions
		if ((Math.fabs(X43{r43}.x-X_MIN43) < epsilon43) || ( (Math.fabs(X43{r43}.x-X_MAX43) < epsilon43) )) {
			Mt43{r43} = I43;
			bt43{r43} = {0.0, 0.0};
		}
	}
}


ComputeU43: ∀r43∈nodes43(), ur43{r43} = matVectProduct43(inverse43(Mt43{r43}), bt43{r43});
ComputeV43: ∀j43∈cells43(), V43{j43} = 0.5 * ∑{r43∈nodesOfCell43(j43)}(dot(C43{j43,r43},X43{r43}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn43: ∀n43∈ℕ, ∀r043∈nodes43(), X43{r043}^{n43=0}=coord43{r043}; , ∀r43∈nodes43(), X43{r43}^{n43+1}=X43{r43}^{n43}+δt43^{n43}*ur43{r43};
ComputeUn43: ∀n43∈ℕ, ∀j043∈cells43(), uj43{j043}^{n43=0}={0.0,0.0}; , ∀j43∈cells43(), uj43{j43}^{n43+1}=uj43{j43}^{n43}-(δt43^{n43}/m43{j43})*∑{r43∈nodesOfCell43(j43)}(F43{j43,r43});
ComputeEn43: ∀n43∈ℕ, ∀j043∈cells43(), E43{j043}^{n43=0}=p_ic43{j043}/((γ43-1.0)*ρ_ic43{j043}); , ∀j43∈cells43(), E43{j43}^{n43+1}=E43{j43}^{n43} - (δt43^{n43} / m43{j43}) * ∑{r43∈nodesOfCell43(j43)}(dot(F43{j43,r43},ur43{r43}));
ComputeDt43: ∀n43∈ℕ, δt43^{n43=0}=option_δt_ini43;, δt43^{n43+1}=option_δt_cfl43*reduceMin{j43∈cells43()}(δtj43{j43});
ComputeTn43: ∀n43∈ℕ, t43^{n43=0}=0.0; , t43^{n43+1}=t43^{n43}+δt43^{n43+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter44: ∀j44∈cells44(), center44{j44} = (1.0/4.0) * ∑{r44∈nodesOfCell44(j44)}(coord44{r44});
IniIc44: ∀j44∈cells44(), if (center44{j44}.x < option_x_interface44) {
  ρ_ic44{j44}=option_ρ_ini_zg44;
  p_ic44{j44}=option_p_ini_zg44;
} else {
  ρ_ic44{j44}=option_ρ_ini_zd44;
  p_ic44{j44}=option_p_ini_zd44;
}

ComputeCjrIc44: ∀j44∈cells44(), ∀r44∈nodesOfCell44(j44), 
	C_ic44{j44,r44} = 0.5 * perp44(coord44{►(r44)} - coord44{◄(r44)});
IniVIc44: ∀j44∈cells44(), V_ic44{j44} = 0.5 * ∑{r44∈nodesOfCell44(j44)}(dot(C_ic44{j44,r44}, coord44{r44}));
IniM44: ∀j44∈cells44(), m44{j44} = ρ_ic44{j44} * V_ic44{j44}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr44: ∀j44∈cells44(), ∀r44∈nodesOfCell44(j44), C44{j44,r44} = 0.5 * perp44(X44{►(r44)} - X44{◄(r44)});
ComputeLjr44: ∀j44∈cells44(), ∀r44∈nodesOfCell44(j44), l44{j44,r44} = norm(C44{j44,r44});
Computeδtj44: ∀j44∈cells44(), δtj44{j44} = 2.0 * V44{j44} / (c44{j44} * ∑{r44∈nodesOfCell44(j44)}(l44{j44,r44}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity44: ∀j44∈cells44(), ρ44{j44} = m44{j44} / V44{j44};
ComputeEOSp44: ∀j44∈cells44(), p44{j44} = (γ44-1.0) * ρ44{j44} * e44{j44};
ComputeInternalEngergy44: ∀j44∈cells44(), e44{j44} = E44{j44} - 0.5 * dot(uj44{j44}, uj44{j44});
ComputeEOSc44: ∀j44∈cells44(), c44{j44} = √(γ44*p44{j44}/ρ44{j44}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr44: ∀j44∈cells44(), ∀r44∈nodesOfCell44(j44), Ajr44{j44,r44} = ((ρ44{j44}*c44{j44})/l44{j44,r44}) * tensProduct44(C44{j44,r44}, C44{j44,r44});
ComputeFjr44: ∀j44∈cells44(), ∀r44∈nodesOfCell44(j44), F44{j44,r44} = p44{j44}*C44{j44,r44} + matVectProduct44(Ajr44{j44,r44}, (uj44{j44}-ur44{r44}));
ComputeAr44: ∀r44∈nodes44(), Ar44{r44} = ∑{j44∈cellsOfNode44(r44)}(Ajr44{j44,r44});
ComputeBr44: ∀r44∈nodes44(), b44{r44} = ∑{j44∈cellsOfNode44(r44)}(p44{j44}*C44{j44,r44} + matVectProduct44(Ajr44{j44,r44}, uj44{j44}));
ComputeMt44: ∀r44∈innerNodes44(), Mt44{r44} = Ar44{r44};
ComputeBt44: ∀r44∈innerNodes44(), bt44{r44} = b44{r44};

OuterFacesComputations44: ∀k44∈outerFaces44(), {
	const ℝ epsilon44 = 1.0e-10;
	ℝ²ˣ² I44 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN44 = 0.0;
	ℝ X_MAX44 = X_EDGE_ELEMS44 * LENGTH44;
	ℝ Y_MIN44 = 0.0; 
	ℝ Y_MAX44 = Y_EDGE_ELEMS44 * LENGTH44;
	ℝ² nY44 = {0.0,1.0};
	
	∀r44∈nodesOfFace44(k44), {
		// Y boundary conditions (must be done before X)
		if ((X44{r44}.y-Y_MIN44 < epsilon44) || (X44{r44}.y-Y_MAX44 < epsilon44)) {
			ℝ sign44 = 0.0;
			if (X44{r44}.y-Y_MIN44 < epsilon44) sign44 = -1.0;
			else sign44 = 1.0;
			ℝ² n44 = sign44 * nY44;
      		ℝ²ˣ² nxn44 = tensProduct44(n44,n44);
      		ℝ²ˣ² IcP44 = I44 - nxn44;
			bt1{r44} = matVectProduct44(IcP44, b44{r44});
			Mt1{r44} = IcP44 * (Ar44{r44} * IcP44) + nxn44*trace44(Ar44{r44});
		}

		// X boundary conditions
		if ((Math.fabs(X44{r44}.x-X_MIN44) < epsilon44) || ( (Math.fabs(X44{r44}.x-X_MAX44) < epsilon44) )) {
			Mt44{r44} = I44;
			bt44{r44} = {0.0, 0.0};
		}
	}
}


ComputeU44: ∀r44∈nodes44(), ur44{r44} = matVectProduct44(inverse44(Mt44{r44}), bt44{r44});
ComputeV44: ∀j44∈cells44(), V44{j44} = 0.5 * ∑{r44∈nodesOfCell44(j44)}(dot(C44{j44,r44},X44{r44}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn44: ∀n44∈ℕ, ∀r044∈nodes44(), X44{r044}^{n44=0}=coord44{r044}; , ∀r44∈nodes44(), X44{r44}^{n44+1}=X44{r44}^{n44}+δt44^{n44}*ur44{r44};
ComputeUn44: ∀n44∈ℕ, ∀j044∈cells44(), uj44{j044}^{n44=0}={0.0,0.0}; , ∀j44∈cells44(), uj44{j44}^{n44+1}=uj44{j44}^{n44}-(δt44^{n44}/m44{j44})*∑{r44∈nodesOfCell44(j44)}(F44{j44,r44});
ComputeEn44: ∀n44∈ℕ, ∀j044∈cells44(), E44{j044}^{n44=0}=p_ic44{j044}/((γ44-1.0)*ρ_ic44{j044}); , ∀j44∈cells44(), E44{j44}^{n44+1}=E44{j44}^{n44} - (δt44^{n44} / m44{j44}) * ∑{r44∈nodesOfCell44(j44)}(dot(F44{j44,r44},ur44{r44}));
ComputeDt44: ∀n44∈ℕ, δt44^{n44=0}=option_δt_ini44;, δt44^{n44+1}=option_δt_cfl44*reduceMin{j44∈cells44()}(δtj44{j44});
ComputeTn44: ∀n44∈ℕ, t44^{n44=0}=0.0; , t44^{n44+1}=t44^{n44}+δt44^{n44+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter45: ∀j45∈cells45(), center45{j45} = (1.0/4.0) * ∑{r45∈nodesOfCell45(j45)}(coord45{r45});
IniIc45: ∀j45∈cells45(), if (center45{j45}.x < option_x_interface45) {
  ρ_ic45{j45}=option_ρ_ini_zg45;
  p_ic45{j45}=option_p_ini_zg45;
} else {
  ρ_ic45{j45}=option_ρ_ini_zd45;
  p_ic45{j45}=option_p_ini_zd45;
}

ComputeCjrIc45: ∀j45∈cells45(), ∀r45∈nodesOfCell45(j45), 
	C_ic45{j45,r45} = 0.5 * perp45(coord45{►(r45)} - coord45{◄(r45)});
IniVIc45: ∀j45∈cells45(), V_ic45{j45} = 0.5 * ∑{r45∈nodesOfCell45(j45)}(dot(C_ic45{j45,r45}, coord45{r45}));
IniM45: ∀j45∈cells45(), m45{j45} = ρ_ic45{j45} * V_ic45{j45}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr45: ∀j45∈cells45(), ∀r45∈nodesOfCell45(j45), C45{j45,r45} = 0.5 * perp45(X45{►(r45)} - X45{◄(r45)});
ComputeLjr45: ∀j45∈cells45(), ∀r45∈nodesOfCell45(j45), l45{j45,r45} = norm(C45{j45,r45});
Computeδtj45: ∀j45∈cells45(), δtj45{j45} = 2.0 * V45{j45} / (c45{j45} * ∑{r45∈nodesOfCell45(j45)}(l45{j45,r45}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity45: ∀j45∈cells45(), ρ45{j45} = m45{j45} / V45{j45};
ComputeEOSp45: ∀j45∈cells45(), p45{j45} = (γ45-1.0) * ρ45{j45} * e45{j45};
ComputeInternalEngergy45: ∀j45∈cells45(), e45{j45} = E45{j45} - 0.5 * dot(uj45{j45}, uj45{j45});
ComputeEOSc45: ∀j45∈cells45(), c45{j45} = √(γ45*p45{j45}/ρ45{j45}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr45: ∀j45∈cells45(), ∀r45∈nodesOfCell45(j45), Ajr45{j45,r45} = ((ρ45{j45}*c45{j45})/l45{j45,r45}) * tensProduct45(C45{j45,r45}, C45{j45,r45});
ComputeFjr45: ∀j45∈cells45(), ∀r45∈nodesOfCell45(j45), F45{j45,r45} = p45{j45}*C45{j45,r45} + matVectProduct45(Ajr45{j45,r45}, (uj45{j45}-ur45{r45}));
ComputeAr45: ∀r45∈nodes45(), Ar45{r45} = ∑{j45∈cellsOfNode45(r45)}(Ajr45{j45,r45});
ComputeBr45: ∀r45∈nodes45(), b45{r45} = ∑{j45∈cellsOfNode45(r45)}(p45{j45}*C45{j45,r45} + matVectProduct45(Ajr45{j45,r45}, uj45{j45}));
ComputeMt45: ∀r45∈innerNodes45(), Mt45{r45} = Ar45{r45};
ComputeBt45: ∀r45∈innerNodes45(), bt45{r45} = b45{r45};

OuterFacesComputations45: ∀k45∈outerFaces45(), {
	const ℝ epsilon45 = 1.0e-10;
	ℝ²ˣ² I45 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN45 = 0.0;
	ℝ X_MAX45 = X_EDGE_ELEMS45 * LENGTH45;
	ℝ Y_MIN45 = 0.0; 
	ℝ Y_MAX45 = Y_EDGE_ELEMS45 * LENGTH45;
	ℝ² nY45 = {0.0,1.0};
	
	∀r45∈nodesOfFace45(k45), {
		// Y boundary conditions (must be done before X)
		if ((X45{r45}.y-Y_MIN45 < epsilon45) || (X45{r45}.y-Y_MAX45 < epsilon45)) {
			ℝ sign45 = 0.0;
			if (X45{r45}.y-Y_MIN45 < epsilon45) sign45 = -1.0;
			else sign45 = 1.0;
			ℝ² n45 = sign45 * nY45;
      		ℝ²ˣ² nxn45 = tensProduct45(n45,n45);
      		ℝ²ˣ² IcP45 = I45 - nxn45;
			bt1{r45} = matVectProduct45(IcP45, b45{r45});
			Mt1{r45} = IcP45 * (Ar45{r45} * IcP45) + nxn45*trace45(Ar45{r45});
		}

		// X boundary conditions
		if ((Math.fabs(X45{r45}.x-X_MIN45) < epsilon45) || ( (Math.fabs(X45{r45}.x-X_MAX45) < epsilon45) )) {
			Mt45{r45} = I45;
			bt45{r45} = {0.0, 0.0};
		}
	}
}


ComputeU45: ∀r45∈nodes45(), ur45{r45} = matVectProduct45(inverse45(Mt45{r45}), bt45{r45});
ComputeV45: ∀j45∈cells45(), V45{j45} = 0.5 * ∑{r45∈nodesOfCell45(j45)}(dot(C45{j45,r45},X45{r45}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn45: ∀n45∈ℕ, ∀r045∈nodes45(), X45{r045}^{n45=0}=coord45{r045}; , ∀r45∈nodes45(), X45{r45}^{n45+1}=X45{r45}^{n45}+δt45^{n45}*ur45{r45};
ComputeUn45: ∀n45∈ℕ, ∀j045∈cells45(), uj45{j045}^{n45=0}={0.0,0.0}; , ∀j45∈cells45(), uj45{j45}^{n45+1}=uj45{j45}^{n45}-(δt45^{n45}/m45{j45})*∑{r45∈nodesOfCell45(j45)}(F45{j45,r45});
ComputeEn45: ∀n45∈ℕ, ∀j045∈cells45(), E45{j045}^{n45=0}=p_ic45{j045}/((γ45-1.0)*ρ_ic45{j045}); , ∀j45∈cells45(), E45{j45}^{n45+1}=E45{j45}^{n45} - (δt45^{n45} / m45{j45}) * ∑{r45∈nodesOfCell45(j45)}(dot(F45{j45,r45},ur45{r45}));
ComputeDt45: ∀n45∈ℕ, δt45^{n45=0}=option_δt_ini45;, δt45^{n45+1}=option_δt_cfl45*reduceMin{j45∈cells45()}(δtj45{j45});
ComputeTn45: ∀n45∈ℕ, t45^{n45=0}=0.0; , t45^{n45+1}=t45^{n45}+δt45^{n45+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter46: ∀j46∈cells46(), center46{j46} = (1.0/4.0) * ∑{r46∈nodesOfCell46(j46)}(coord46{r46});
IniIc46: ∀j46∈cells46(), if (center46{j46}.x < option_x_interface46) {
  ρ_ic46{j46}=option_ρ_ini_zg46;
  p_ic46{j46}=option_p_ini_zg46;
} else {
  ρ_ic46{j46}=option_ρ_ini_zd46;
  p_ic46{j46}=option_p_ini_zd46;
}

ComputeCjrIc46: ∀j46∈cells46(), ∀r46∈nodesOfCell46(j46), 
	C_ic46{j46,r46} = 0.5 * perp46(coord46{►(r46)} - coord46{◄(r46)});
IniVIc46: ∀j46∈cells46(), V_ic46{j46} = 0.5 * ∑{r46∈nodesOfCell46(j46)}(dot(C_ic46{j46,r46}, coord46{r46}));
IniM46: ∀j46∈cells46(), m46{j46} = ρ_ic46{j46} * V_ic46{j46}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr46: ∀j46∈cells46(), ∀r46∈nodesOfCell46(j46), C46{j46,r46} = 0.5 * perp46(X46{►(r46)} - X46{◄(r46)});
ComputeLjr46: ∀j46∈cells46(), ∀r46∈nodesOfCell46(j46), l46{j46,r46} = norm(C46{j46,r46});
Computeδtj46: ∀j46∈cells46(), δtj46{j46} = 2.0 * V46{j46} / (c46{j46} * ∑{r46∈nodesOfCell46(j46)}(l46{j46,r46}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity46: ∀j46∈cells46(), ρ46{j46} = m46{j46} / V46{j46};
ComputeEOSp46: ∀j46∈cells46(), p46{j46} = (γ46-1.0) * ρ46{j46} * e46{j46};
ComputeInternalEngergy46: ∀j46∈cells46(), e46{j46} = E46{j46} - 0.5 * dot(uj46{j46}, uj46{j46});
ComputeEOSc46: ∀j46∈cells46(), c46{j46} = √(γ46*p46{j46}/ρ46{j46}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr46: ∀j46∈cells46(), ∀r46∈nodesOfCell46(j46), Ajr46{j46,r46} = ((ρ46{j46}*c46{j46})/l46{j46,r46}) * tensProduct46(C46{j46,r46}, C46{j46,r46});
ComputeFjr46: ∀j46∈cells46(), ∀r46∈nodesOfCell46(j46), F46{j46,r46} = p46{j46}*C46{j46,r46} + matVectProduct46(Ajr46{j46,r46}, (uj46{j46}-ur46{r46}));
ComputeAr46: ∀r46∈nodes46(), Ar46{r46} = ∑{j46∈cellsOfNode46(r46)}(Ajr46{j46,r46});
ComputeBr46: ∀r46∈nodes46(), b46{r46} = ∑{j46∈cellsOfNode46(r46)}(p46{j46}*C46{j46,r46} + matVectProduct46(Ajr46{j46,r46}, uj46{j46}));
ComputeMt46: ∀r46∈innerNodes46(), Mt46{r46} = Ar46{r46};
ComputeBt46: ∀r46∈innerNodes46(), bt46{r46} = b46{r46};

OuterFacesComputations46: ∀k46∈outerFaces46(), {
	const ℝ epsilon46 = 1.0e-10;
	ℝ²ˣ² I46 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN46 = 0.0;
	ℝ X_MAX46 = X_EDGE_ELEMS46 * LENGTH46;
	ℝ Y_MIN46 = 0.0; 
	ℝ Y_MAX46 = Y_EDGE_ELEMS46 * LENGTH46;
	ℝ² nY46 = {0.0,1.0};
	
	∀r46∈nodesOfFace46(k46), {
		// Y boundary conditions (must be done before X)
		if ((X46{r46}.y-Y_MIN46 < epsilon46) || (X46{r46}.y-Y_MAX46 < epsilon46)) {
			ℝ sign46 = 0.0;
			if (X46{r46}.y-Y_MIN46 < epsilon46) sign46 = -1.0;
			else sign46 = 1.0;
			ℝ² n46 = sign46 * nY46;
      		ℝ²ˣ² nxn46 = tensProduct46(n46,n46);
      		ℝ²ˣ² IcP46 = I46 - nxn46;
			bt1{r46} = matVectProduct46(IcP46, b46{r46});
			Mt1{r46} = IcP46 * (Ar46{r46} * IcP46) + nxn46*trace46(Ar46{r46});
		}

		// X boundary conditions
		if ((Math.fabs(X46{r46}.x-X_MIN46) < epsilon46) || ( (Math.fabs(X46{r46}.x-X_MAX46) < epsilon46) )) {
			Mt46{r46} = I46;
			bt46{r46} = {0.0, 0.0};
		}
	}
}


ComputeU46: ∀r46∈nodes46(), ur46{r46} = matVectProduct46(inverse46(Mt46{r46}), bt46{r46});
ComputeV46: ∀j46∈cells46(), V46{j46} = 0.5 * ∑{r46∈nodesOfCell46(j46)}(dot(C46{j46,r46},X46{r46}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn46: ∀n46∈ℕ, ∀r046∈nodes46(), X46{r046}^{n46=0}=coord46{r046}; , ∀r46∈nodes46(), X46{r46}^{n46+1}=X46{r46}^{n46}+δt46^{n46}*ur46{r46};
ComputeUn46: ∀n46∈ℕ, ∀j046∈cells46(), uj46{j046}^{n46=0}={0.0,0.0}; , ∀j46∈cells46(), uj46{j46}^{n46+1}=uj46{j46}^{n46}-(δt46^{n46}/m46{j46})*∑{r46∈nodesOfCell46(j46)}(F46{j46,r46});
ComputeEn46: ∀n46∈ℕ, ∀j046∈cells46(), E46{j046}^{n46=0}=p_ic46{j046}/((γ46-1.0)*ρ_ic46{j046}); , ∀j46∈cells46(), E46{j46}^{n46+1}=E46{j46}^{n46} - (δt46^{n46} / m46{j46}) * ∑{r46∈nodesOfCell46(j46)}(dot(F46{j46,r46},ur46{r46}));
ComputeDt46: ∀n46∈ℕ, δt46^{n46=0}=option_δt_ini46;, δt46^{n46+1}=option_δt_cfl46*reduceMin{j46∈cells46()}(δtj46{j46});
ComputeTn46: ∀n46∈ℕ, t46^{n46=0}=0.0; , t46^{n46+1}=t46^{n46}+δt46^{n46+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter47: ∀j47∈cells47(), center47{j47} = (1.0/4.0) * ∑{r47∈nodesOfCell47(j47)}(coord47{r47});
IniIc47: ∀j47∈cells47(), if (center47{j47}.x < option_x_interface47) {
  ρ_ic47{j47}=option_ρ_ini_zg47;
  p_ic47{j47}=option_p_ini_zg47;
} else {
  ρ_ic47{j47}=option_ρ_ini_zd47;
  p_ic47{j47}=option_p_ini_zd47;
}

ComputeCjrIc47: ∀j47∈cells47(), ∀r47∈nodesOfCell47(j47), 
	C_ic47{j47,r47} = 0.5 * perp47(coord47{►(r47)} - coord47{◄(r47)});
IniVIc47: ∀j47∈cells47(), V_ic47{j47} = 0.5 * ∑{r47∈nodesOfCell47(j47)}(dot(C_ic47{j47,r47}, coord47{r47}));
IniM47: ∀j47∈cells47(), m47{j47} = ρ_ic47{j47} * V_ic47{j47}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr47: ∀j47∈cells47(), ∀r47∈nodesOfCell47(j47), C47{j47,r47} = 0.5 * perp47(X47{►(r47)} - X47{◄(r47)});
ComputeLjr47: ∀j47∈cells47(), ∀r47∈nodesOfCell47(j47), l47{j47,r47} = norm(C47{j47,r47});
Computeδtj47: ∀j47∈cells47(), δtj47{j47} = 2.0 * V47{j47} / (c47{j47} * ∑{r47∈nodesOfCell47(j47)}(l47{j47,r47}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity47: ∀j47∈cells47(), ρ47{j47} = m47{j47} / V47{j47};
ComputeEOSp47: ∀j47∈cells47(), p47{j47} = (γ47-1.0) * ρ47{j47} * e47{j47};
ComputeInternalEngergy47: ∀j47∈cells47(), e47{j47} = E47{j47} - 0.5 * dot(uj47{j47}, uj47{j47});
ComputeEOSc47: ∀j47∈cells47(), c47{j47} = √(γ47*p47{j47}/ρ47{j47}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr47: ∀j47∈cells47(), ∀r47∈nodesOfCell47(j47), Ajr47{j47,r47} = ((ρ47{j47}*c47{j47})/l47{j47,r47}) * tensProduct47(C47{j47,r47}, C47{j47,r47});
ComputeFjr47: ∀j47∈cells47(), ∀r47∈nodesOfCell47(j47), F47{j47,r47} = p47{j47}*C47{j47,r47} + matVectProduct47(Ajr47{j47,r47}, (uj47{j47}-ur47{r47}));
ComputeAr47: ∀r47∈nodes47(), Ar47{r47} = ∑{j47∈cellsOfNode47(r47)}(Ajr47{j47,r47});
ComputeBr47: ∀r47∈nodes47(), b47{r47} = ∑{j47∈cellsOfNode47(r47)}(p47{j47}*C47{j47,r47} + matVectProduct47(Ajr47{j47,r47}, uj47{j47}));
ComputeMt47: ∀r47∈innerNodes47(), Mt47{r47} = Ar47{r47};
ComputeBt47: ∀r47∈innerNodes47(), bt47{r47} = b47{r47};

OuterFacesComputations47: ∀k47∈outerFaces47(), {
	const ℝ epsilon47 = 1.0e-10;
	ℝ²ˣ² I47 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN47 = 0.0;
	ℝ X_MAX47 = X_EDGE_ELEMS47 * LENGTH47;
	ℝ Y_MIN47 = 0.0; 
	ℝ Y_MAX47 = Y_EDGE_ELEMS47 * LENGTH47;
	ℝ² nY47 = {0.0,1.0};
	
	∀r47∈nodesOfFace47(k47), {
		// Y boundary conditions (must be done before X)
		if ((X47{r47}.y-Y_MIN47 < epsilon47) || (X47{r47}.y-Y_MAX47 < epsilon47)) {
			ℝ sign47 = 0.0;
			if (X47{r47}.y-Y_MIN47 < epsilon47) sign47 = -1.0;
			else sign47 = 1.0;
			ℝ² n47 = sign47 * nY47;
      		ℝ²ˣ² nxn47 = tensProduct47(n47,n47);
      		ℝ²ˣ² IcP47 = I47 - nxn47;
			bt1{r47} = matVectProduct47(IcP47, b47{r47});
			Mt1{r47} = IcP47 * (Ar47{r47} * IcP47) + nxn47*trace47(Ar47{r47});
		}

		// X boundary conditions
		if ((Math.fabs(X47{r47}.x-X_MIN47) < epsilon47) || ( (Math.fabs(X47{r47}.x-X_MAX47) < epsilon47) )) {
			Mt47{r47} = I47;
			bt47{r47} = {0.0, 0.0};
		}
	}
}


ComputeU47: ∀r47∈nodes47(), ur47{r47} = matVectProduct47(inverse47(Mt47{r47}), bt47{r47});
ComputeV47: ∀j47∈cells47(), V47{j47} = 0.5 * ∑{r47∈nodesOfCell47(j47)}(dot(C47{j47,r47},X47{r47}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn47: ∀n47∈ℕ, ∀r047∈nodes47(), X47{r047}^{n47=0}=coord47{r047}; , ∀r47∈nodes47(), X47{r47}^{n47+1}=X47{r47}^{n47}+δt47^{n47}*ur47{r47};
ComputeUn47: ∀n47∈ℕ, ∀j047∈cells47(), uj47{j047}^{n47=0}={0.0,0.0}; , ∀j47∈cells47(), uj47{j47}^{n47+1}=uj47{j47}^{n47}-(δt47^{n47}/m47{j47})*∑{r47∈nodesOfCell47(j47)}(F47{j47,r47});
ComputeEn47: ∀n47∈ℕ, ∀j047∈cells47(), E47{j047}^{n47=0}=p_ic47{j047}/((γ47-1.0)*ρ_ic47{j047}); , ∀j47∈cells47(), E47{j47}^{n47+1}=E47{j47}^{n47} - (δt47^{n47} / m47{j47}) * ∑{r47∈nodesOfCell47(j47)}(dot(F47{j47,r47},ur47{r47}));
ComputeDt47: ∀n47∈ℕ, δt47^{n47=0}=option_δt_ini47;, δt47^{n47+1}=option_δt_cfl47*reduceMin{j47∈cells47()}(δtj47{j47});
ComputeTn47: ∀n47∈ℕ, t47^{n47=0}=0.0; , t47^{n47+1}=t47^{n47}+δt47^{n47+1};

