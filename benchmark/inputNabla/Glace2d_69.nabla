module Glace2d;

with Math.*;

connectivities {
	nodes1: (∅) → {node};
	cells1: (∅) → {cell};
	outerFaces1: (∅) → {face};
	innerNodes1: (∅) → {node};
	nodesOfCell1: (cell) → {node};
	cellsOfNode1: (node) → {cell};
	nodesOfFace1: (face) → {node};
}

functions {
	trace1: (ℝ²ˣ²) → ℝ;
	perp1: (ℝ²) → ℝ²;
	tensProduct1: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct1: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse1: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes2: (∅) → {node};
	cells2: (∅) → {cell};
	outerFaces2: (∅) → {face};
	innerNodes2: (∅) → {node};
	nodesOfCell2: (cell) → {node};
	cellsOfNode2: (node) → {cell};
	nodesOfFace2: (face) → {node};
}

functions {
	trace2: (ℝ²ˣ²) → ℝ;
	perp2: (ℝ²) → ℝ²;
	tensProduct2: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct2: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse2: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes3: (∅) → {node};
	cells3: (∅) → {cell};
	outerFaces3: (∅) → {face};
	innerNodes3: (∅) → {node};
	nodesOfCell3: (cell) → {node};
	cellsOfNode3: (node) → {cell};
	nodesOfFace3: (face) → {node};
}

functions {
	trace3: (ℝ²ˣ²) → ℝ;
	perp3: (ℝ²) → ℝ²;
	tensProduct3: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct3: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse3: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes4: (∅) → {node};
	cells4: (∅) → {cell};
	outerFaces4: (∅) → {face};
	innerNodes4: (∅) → {node};
	nodesOfCell4: (cell) → {node};
	cellsOfNode4: (node) → {cell};
	nodesOfFace4: (face) → {node};
}

functions {
	trace4: (ℝ²ˣ²) → ℝ;
	perp4: (ℝ²) → ℝ²;
	tensProduct4: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct4: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse4: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes5: (∅) → {node};
	cells5: (∅) → {cell};
	outerFaces5: (∅) → {face};
	innerNodes5: (∅) → {node};
	nodesOfCell5: (cell) → {node};
	cellsOfNode5: (node) → {cell};
	nodesOfFace5: (face) → {node};
}

functions {
	trace5: (ℝ²ˣ²) → ℝ;
	perp5: (ℝ²) → ℝ²;
	tensProduct5: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct5: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse5: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes6: (∅) → {node};
	cells6: (∅) → {cell};
	outerFaces6: (∅) → {face};
	innerNodes6: (∅) → {node};
	nodesOfCell6: (cell) → {node};
	cellsOfNode6: (node) → {cell};
	nodesOfFace6: (face) → {node};
}

functions {
	trace6: (ℝ²ˣ²) → ℝ;
	perp6: (ℝ²) → ℝ²;
	tensProduct6: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct6: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse6: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes7: (∅) → {node};
	cells7: (∅) → {cell};
	outerFaces7: (∅) → {face};
	innerNodes7: (∅) → {node};
	nodesOfCell7: (cell) → {node};
	cellsOfNode7: (node) → {cell};
	nodesOfFace7: (face) → {node};
}

functions {
	trace7: (ℝ²ˣ²) → ℝ;
	perp7: (ℝ²) → ℝ²;
	tensProduct7: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct7: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse7: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes8: (∅) → {node};
	cells8: (∅) → {cell};
	outerFaces8: (∅) → {face};
	innerNodes8: (∅) → {node};
	nodesOfCell8: (cell) → {node};
	cellsOfNode8: (node) → {cell};
	nodesOfFace8: (face) → {node};
}

functions {
	trace8: (ℝ²ˣ²) → ℝ;
	perp8: (ℝ²) → ℝ²;
	tensProduct8: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct8: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse8: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes9: (∅) → {node};
	cells9: (∅) → {cell};
	outerFaces9: (∅) → {face};
	innerNodes9: (∅) → {node};
	nodesOfCell9: (cell) → {node};
	cellsOfNode9: (node) → {cell};
	nodesOfFace9: (face) → {node};
}

functions {
	trace9: (ℝ²ˣ²) → ℝ;
	perp9: (ℝ²) → ℝ²;
	tensProduct9: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct9: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse9: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes10: (∅) → {node};
	cells10: (∅) → {cell};
	outerFaces10: (∅) → {face};
	innerNodes10: (∅) → {node};
	nodesOfCell10: (cell) → {node};
	cellsOfNode10: (node) → {cell};
	nodesOfFace10: (face) → {node};
}

functions {
	trace10: (ℝ²ˣ²) → ℝ;
	perp10: (ℝ²) → ℝ²;
	tensProduct10: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct10: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse10: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes11: (∅) → {node};
	cells11: (∅) → {cell};
	outerFaces11: (∅) → {face};
	innerNodes11: (∅) → {node};
	nodesOfCell11: (cell) → {node};
	cellsOfNode11: (node) → {cell};
	nodesOfFace11: (face) → {node};
}

functions {
	trace11: (ℝ²ˣ²) → ℝ;
	perp11: (ℝ²) → ℝ²;
	tensProduct11: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct11: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse11: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes12: (∅) → {node};
	cells12: (∅) → {cell};
	outerFaces12: (∅) → {face};
	innerNodes12: (∅) → {node};
	nodesOfCell12: (cell) → {node};
	cellsOfNode12: (node) → {cell};
	nodesOfFace12: (face) → {node};
}

functions {
	trace12: (ℝ²ˣ²) → ℝ;
	perp12: (ℝ²) → ℝ²;
	tensProduct12: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct12: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse12: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes13: (∅) → {node};
	cells13: (∅) → {cell};
	outerFaces13: (∅) → {face};
	innerNodes13: (∅) → {node};
	nodesOfCell13: (cell) → {node};
	cellsOfNode13: (node) → {cell};
	nodesOfFace13: (face) → {node};
}

functions {
	trace13: (ℝ²ˣ²) → ℝ;
	perp13: (ℝ²) → ℝ²;
	tensProduct13: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct13: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse13: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes14: (∅) → {node};
	cells14: (∅) → {cell};
	outerFaces14: (∅) → {face};
	innerNodes14: (∅) → {node};
	nodesOfCell14: (cell) → {node};
	cellsOfNode14: (node) → {cell};
	nodesOfFace14: (face) → {node};
}

functions {
	trace14: (ℝ²ˣ²) → ℝ;
	perp14: (ℝ²) → ℝ²;
	tensProduct14: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct14: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse14: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes15: (∅) → {node};
	cells15: (∅) → {cell};
	outerFaces15: (∅) → {face};
	innerNodes15: (∅) → {node};
	nodesOfCell15: (cell) → {node};
	cellsOfNode15: (node) → {cell};
	nodesOfFace15: (face) → {node};
}

functions {
	trace15: (ℝ²ˣ²) → ℝ;
	perp15: (ℝ²) → ℝ²;
	tensProduct15: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct15: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse15: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes16: (∅) → {node};
	cells16: (∅) → {cell};
	outerFaces16: (∅) → {face};
	innerNodes16: (∅) → {node};
	nodesOfCell16: (cell) → {node};
	cellsOfNode16: (node) → {cell};
	nodesOfFace16: (face) → {node};
}

functions {
	trace16: (ℝ²ˣ²) → ℝ;
	perp16: (ℝ²) → ℝ²;
	tensProduct16: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct16: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse16: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes17: (∅) → {node};
	cells17: (∅) → {cell};
	outerFaces17: (∅) → {face};
	innerNodes17: (∅) → {node};
	nodesOfCell17: (cell) → {node};
	cellsOfNode17: (node) → {cell};
	nodesOfFace17: (face) → {node};
}

functions {
	trace17: (ℝ²ˣ²) → ℝ;
	perp17: (ℝ²) → ℝ²;
	tensProduct17: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct17: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse17: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes18: (∅) → {node};
	cells18: (∅) → {cell};
	outerFaces18: (∅) → {face};
	innerNodes18: (∅) → {node};
	nodesOfCell18: (cell) → {node};
	cellsOfNode18: (node) → {cell};
	nodesOfFace18: (face) → {node};
}

functions {
	trace18: (ℝ²ˣ²) → ℝ;
	perp18: (ℝ²) → ℝ²;
	tensProduct18: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct18: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse18: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes19: (∅) → {node};
	cells19: (∅) → {cell};
	outerFaces19: (∅) → {face};
	innerNodes19: (∅) → {node};
	nodesOfCell19: (cell) → {node};
	cellsOfNode19: (node) → {cell};
	nodesOfFace19: (face) → {node};
}

functions {
	trace19: (ℝ²ˣ²) → ℝ;
	perp19: (ℝ²) → ℝ²;
	tensProduct19: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct19: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse19: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes20: (∅) → {node};
	cells20: (∅) → {cell};
	outerFaces20: (∅) → {face};
	innerNodes20: (∅) → {node};
	nodesOfCell20: (cell) → {node};
	cellsOfNode20: (node) → {cell};
	nodesOfFace20: (face) → {node};
}

functions {
	trace20: (ℝ²ˣ²) → ℝ;
	perp20: (ℝ²) → ℝ²;
	tensProduct20: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct20: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse20: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes21: (∅) → {node};
	cells21: (∅) → {cell};
	outerFaces21: (∅) → {face};
	innerNodes21: (∅) → {node};
	nodesOfCell21: (cell) → {node};
	cellsOfNode21: (node) → {cell};
	nodesOfFace21: (face) → {node};
}

functions {
	trace21: (ℝ²ˣ²) → ℝ;
	perp21: (ℝ²) → ℝ²;
	tensProduct21: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct21: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse21: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes22: (∅) → {node};
	cells22: (∅) → {cell};
	outerFaces22: (∅) → {face};
	innerNodes22: (∅) → {node};
	nodesOfCell22: (cell) → {node};
	cellsOfNode22: (node) → {cell};
	nodesOfFace22: (face) → {node};
}

functions {
	trace22: (ℝ²ˣ²) → ℝ;
	perp22: (ℝ²) → ℝ²;
	tensProduct22: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct22: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse22: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes23: (∅) → {node};
	cells23: (∅) → {cell};
	outerFaces23: (∅) → {face};
	innerNodes23: (∅) → {node};
	nodesOfCell23: (cell) → {node};
	cellsOfNode23: (node) → {cell};
	nodesOfFace23: (face) → {node};
}

functions {
	trace23: (ℝ²ˣ²) → ℝ;
	perp23: (ℝ²) → ℝ²;
	tensProduct23: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct23: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse23: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes24: (∅) → {node};
	cells24: (∅) → {cell};
	outerFaces24: (∅) → {face};
	innerNodes24: (∅) → {node};
	nodesOfCell24: (cell) → {node};
	cellsOfNode24: (node) → {cell};
	nodesOfFace24: (face) → {node};
}

functions {
	trace24: (ℝ²ˣ²) → ℝ;
	perp24: (ℝ²) → ℝ²;
	tensProduct24: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct24: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse24: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes25: (∅) → {node};
	cells25: (∅) → {cell};
	outerFaces25: (∅) → {face};
	innerNodes25: (∅) → {node};
	nodesOfCell25: (cell) → {node};
	cellsOfNode25: (node) → {cell};
	nodesOfFace25: (face) → {node};
}

functions {
	trace25: (ℝ²ˣ²) → ℝ;
	perp25: (ℝ²) → ℝ²;
	tensProduct25: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct25: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse25: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes26: (∅) → {node};
	cells26: (∅) → {cell};
	outerFaces26: (∅) → {face};
	innerNodes26: (∅) → {node};
	nodesOfCell26: (cell) → {node};
	cellsOfNode26: (node) → {cell};
	nodesOfFace26: (face) → {node};
}

functions {
	trace26: (ℝ²ˣ²) → ℝ;
	perp26: (ℝ²) → ℝ²;
	tensProduct26: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct26: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse26: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes27: (∅) → {node};
	cells27: (∅) → {cell};
	outerFaces27: (∅) → {face};
	innerNodes27: (∅) → {node};
	nodesOfCell27: (cell) → {node};
	cellsOfNode27: (node) → {cell};
	nodesOfFace27: (face) → {node};
}

functions {
	trace27: (ℝ²ˣ²) → ℝ;
	perp27: (ℝ²) → ℝ²;
	tensProduct27: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct27: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse27: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes28: (∅) → {node};
	cells28: (∅) → {cell};
	outerFaces28: (∅) → {face};
	innerNodes28: (∅) → {node};
	nodesOfCell28: (cell) → {node};
	cellsOfNode28: (node) → {cell};
	nodesOfFace28: (face) → {node};
}

functions {
	trace28: (ℝ²ˣ²) → ℝ;
	perp28: (ℝ²) → ℝ²;
	tensProduct28: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct28: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse28: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes29: (∅) → {node};
	cells29: (∅) → {cell};
	outerFaces29: (∅) → {face};
	innerNodes29: (∅) → {node};
	nodesOfCell29: (cell) → {node};
	cellsOfNode29: (node) → {cell};
	nodesOfFace29: (face) → {node};
}

functions {
	trace29: (ℝ²ˣ²) → ℝ;
	perp29: (ℝ²) → ℝ²;
	tensProduct29: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct29: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse29: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes30: (∅) → {node};
	cells30: (∅) → {cell};
	outerFaces30: (∅) → {face};
	innerNodes30: (∅) → {node};
	nodesOfCell30: (cell) → {node};
	cellsOfNode30: (node) → {cell};
	nodesOfFace30: (face) → {node};
}

functions {
	trace30: (ℝ²ˣ²) → ℝ;
	perp30: (ℝ²) → ℝ²;
	tensProduct30: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct30: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse30: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes31: (∅) → {node};
	cells31: (∅) → {cell};
	outerFaces31: (∅) → {face};
	innerNodes31: (∅) → {node};
	nodesOfCell31: (cell) → {node};
	cellsOfNode31: (node) → {cell};
	nodesOfFace31: (face) → {node};
}

functions {
	trace31: (ℝ²ˣ²) → ℝ;
	perp31: (ℝ²) → ℝ²;
	tensProduct31: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct31: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse31: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes32: (∅) → {node};
	cells32: (∅) → {cell};
	outerFaces32: (∅) → {face};
	innerNodes32: (∅) → {node};
	nodesOfCell32: (cell) → {node};
	cellsOfNode32: (node) → {cell};
	nodesOfFace32: (face) → {node};
}

functions {
	trace32: (ℝ²ˣ²) → ℝ;
	perp32: (ℝ²) → ℝ²;
	tensProduct32: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct32: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse32: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes33: (∅) → {node};
	cells33: (∅) → {cell};
	outerFaces33: (∅) → {face};
	innerNodes33: (∅) → {node};
	nodesOfCell33: (cell) → {node};
	cellsOfNode33: (node) → {cell};
	nodesOfFace33: (face) → {node};
}

functions {
	trace33: (ℝ²ˣ²) → ℝ;
	perp33: (ℝ²) → ℝ²;
	tensProduct33: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct33: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse33: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes34: (∅) → {node};
	cells34: (∅) → {cell};
	outerFaces34: (∅) → {face};
	innerNodes34: (∅) → {node};
	nodesOfCell34: (cell) → {node};
	cellsOfNode34: (node) → {cell};
	nodesOfFace34: (face) → {node};
}

functions {
	trace34: (ℝ²ˣ²) → ℝ;
	perp34: (ℝ²) → ℝ²;
	tensProduct34: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct34: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse34: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes35: (∅) → {node};
	cells35: (∅) → {cell};
	outerFaces35: (∅) → {face};
	innerNodes35: (∅) → {node};
	nodesOfCell35: (cell) → {node};
	cellsOfNode35: (node) → {cell};
	nodesOfFace35: (face) → {node};
}

functions {
	trace35: (ℝ²ˣ²) → ℝ;
	perp35: (ℝ²) → ℝ²;
	tensProduct35: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct35: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse35: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes36: (∅) → {node};
	cells36: (∅) → {cell};
	outerFaces36: (∅) → {face};
	innerNodes36: (∅) → {node};
	nodesOfCell36: (cell) → {node};
	cellsOfNode36: (node) → {cell};
	nodesOfFace36: (face) → {node};
}

functions {
	trace36: (ℝ²ˣ²) → ℝ;
	perp36: (ℝ²) → ℝ²;
	tensProduct36: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct36: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse36: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes37: (∅) → {node};
	cells37: (∅) → {cell};
	outerFaces37: (∅) → {face};
	innerNodes37: (∅) → {node};
	nodesOfCell37: (cell) → {node};
	cellsOfNode37: (node) → {cell};
	nodesOfFace37: (face) → {node};
}

functions {
	trace37: (ℝ²ˣ²) → ℝ;
	perp37: (ℝ²) → ℝ²;
	tensProduct37: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct37: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse37: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes38: (∅) → {node};
	cells38: (∅) → {cell};
	outerFaces38: (∅) → {face};
	innerNodes38: (∅) → {node};
	nodesOfCell38: (cell) → {node};
	cellsOfNode38: (node) → {cell};
	nodesOfFace38: (face) → {node};
}

functions {
	trace38: (ℝ²ˣ²) → ℝ;
	perp38: (ℝ²) → ℝ²;
	tensProduct38: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct38: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse38: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes39: (∅) → {node};
	cells39: (∅) → {cell};
	outerFaces39: (∅) → {face};
	innerNodes39: (∅) → {node};
	nodesOfCell39: (cell) → {node};
	cellsOfNode39: (node) → {cell};
	nodesOfFace39: (face) → {node};
}

functions {
	trace39: (ℝ²ˣ²) → ℝ;
	perp39: (ℝ²) → ℝ²;
	tensProduct39: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct39: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse39: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes40: (∅) → {node};
	cells40: (∅) → {cell};
	outerFaces40: (∅) → {face};
	innerNodes40: (∅) → {node};
	nodesOfCell40: (cell) → {node};
	cellsOfNode40: (node) → {cell};
	nodesOfFace40: (face) → {node};
}

functions {
	trace40: (ℝ²ˣ²) → ℝ;
	perp40: (ℝ²) → ℝ²;
	tensProduct40: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct40: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse40: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes41: (∅) → {node};
	cells41: (∅) → {cell};
	outerFaces41: (∅) → {face};
	innerNodes41: (∅) → {node};
	nodesOfCell41: (cell) → {node};
	cellsOfNode41: (node) → {cell};
	nodesOfFace41: (face) → {node};
}

functions {
	trace41: (ℝ²ˣ²) → ℝ;
	perp41: (ℝ²) → ℝ²;
	tensProduct41: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct41: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse41: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes42: (∅) → {node};
	cells42: (∅) → {cell};
	outerFaces42: (∅) → {face};
	innerNodes42: (∅) → {node};
	nodesOfCell42: (cell) → {node};
	cellsOfNode42: (node) → {cell};
	nodesOfFace42: (face) → {node};
}

functions {
	trace42: (ℝ²ˣ²) → ℝ;
	perp42: (ℝ²) → ℝ²;
	tensProduct42: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct42: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse42: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes43: (∅) → {node};
	cells43: (∅) → {cell};
	outerFaces43: (∅) → {face};
	innerNodes43: (∅) → {node};
	nodesOfCell43: (cell) → {node};
	cellsOfNode43: (node) → {cell};
	nodesOfFace43: (face) → {node};
}

functions {
	trace43: (ℝ²ˣ²) → ℝ;
	perp43: (ℝ²) → ℝ²;
	tensProduct43: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct43: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse43: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes44: (∅) → {node};
	cells44: (∅) → {cell};
	outerFaces44: (∅) → {face};
	innerNodes44: (∅) → {node};
	nodesOfCell44: (cell) → {node};
	cellsOfNode44: (node) → {cell};
	nodesOfFace44: (face) → {node};
}

functions {
	trace44: (ℝ²ˣ²) → ℝ;
	perp44: (ℝ²) → ℝ²;
	tensProduct44: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct44: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse44: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes45: (∅) → {node};
	cells45: (∅) → {cell};
	outerFaces45: (∅) → {face};
	innerNodes45: (∅) → {node};
	nodesOfCell45: (cell) → {node};
	cellsOfNode45: (node) → {cell};
	nodesOfFace45: (face) → {node};
}

functions {
	trace45: (ℝ²ˣ²) → ℝ;
	perp45: (ℝ²) → ℝ²;
	tensProduct45: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct45: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse45: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes46: (∅) → {node};
	cells46: (∅) → {cell};
	outerFaces46: (∅) → {face};
	innerNodes46: (∅) → {node};
	nodesOfCell46: (cell) → {node};
	cellsOfNode46: (node) → {cell};
	nodesOfFace46: (face) → {node};
}

functions {
	trace46: (ℝ²ˣ²) → ℝ;
	perp46: (ℝ²) → ℝ²;
	tensProduct46: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct46: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse46: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes47: (∅) → {node};
	cells47: (∅) → {cell};
	outerFaces47: (∅) → {face};
	innerNodes47: (∅) → {node};
	nodesOfCell47: (cell) → {node};
	cellsOfNode47: (node) → {cell};
	nodesOfFace47: (face) → {node};
}

functions {
	trace47: (ℝ²ˣ²) → ℝ;
	perp47: (ℝ²) → ℝ²;
	tensProduct47: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct47: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse47: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes48: (∅) → {node};
	cells48: (∅) → {cell};
	outerFaces48: (∅) → {face};
	innerNodes48: (∅) → {node};
	nodesOfCell48: (cell) → {node};
	cellsOfNode48: (node) → {cell};
	nodesOfFace48: (face) → {node};
}

functions {
	trace48: (ℝ²ˣ²) → ℝ;
	perp48: (ℝ²) → ℝ²;
	tensProduct48: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct48: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse48: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes49: (∅) → {node};
	cells49: (∅) → {cell};
	outerFaces49: (∅) → {face};
	innerNodes49: (∅) → {node};
	nodesOfCell49: (cell) → {node};
	cellsOfNode49: (node) → {cell};
	nodesOfFace49: (face) → {node};
}

functions {
	trace49: (ℝ²ˣ²) → ℝ;
	perp49: (ℝ²) → ℝ²;
	tensProduct49: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct49: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse49: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes50: (∅) → {node};
	cells50: (∅) → {cell};
	outerFaces50: (∅) → {face};
	innerNodes50: (∅) → {node};
	nodesOfCell50: (cell) → {node};
	cellsOfNode50: (node) → {cell};
	nodesOfFace50: (face) → {node};
}

functions {
	trace50: (ℝ²ˣ²) → ℝ;
	perp50: (ℝ²) → ℝ²;
	tensProduct50: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct50: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse50: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes51: (∅) → {node};
	cells51: (∅) → {cell};
	outerFaces51: (∅) → {face};
	innerNodes51: (∅) → {node};
	nodesOfCell51: (cell) → {node};
	cellsOfNode51: (node) → {cell};
	nodesOfFace51: (face) → {node};
}

functions {
	trace51: (ℝ²ˣ²) → ℝ;
	perp51: (ℝ²) → ℝ²;
	tensProduct51: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct51: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse51: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes52: (∅) → {node};
	cells52: (∅) → {cell};
	outerFaces52: (∅) → {face};
	innerNodes52: (∅) → {node};
	nodesOfCell52: (cell) → {node};
	cellsOfNode52: (node) → {cell};
	nodesOfFace52: (face) → {node};
}

functions {
	trace52: (ℝ²ˣ²) → ℝ;
	perp52: (ℝ²) → ℝ²;
	tensProduct52: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct52: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse52: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes53: (∅) → {node};
	cells53: (∅) → {cell};
	outerFaces53: (∅) → {face};
	innerNodes53: (∅) → {node};
	nodesOfCell53: (cell) → {node};
	cellsOfNode53: (node) → {cell};
	nodesOfFace53: (face) → {node};
}

functions {
	trace53: (ℝ²ˣ²) → ℝ;
	perp53: (ℝ²) → ℝ²;
	tensProduct53: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct53: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse53: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes54: (∅) → {node};
	cells54: (∅) → {cell};
	outerFaces54: (∅) → {face};
	innerNodes54: (∅) → {node};
	nodesOfCell54: (cell) → {node};
	cellsOfNode54: (node) → {cell};
	nodesOfFace54: (face) → {node};
}

functions {
	trace54: (ℝ²ˣ²) → ℝ;
	perp54: (ℝ²) → ℝ²;
	tensProduct54: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct54: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse54: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes55: (∅) → {node};
	cells55: (∅) → {cell};
	outerFaces55: (∅) → {face};
	innerNodes55: (∅) → {node};
	nodesOfCell55: (cell) → {node};
	cellsOfNode55: (node) → {cell};
	nodesOfFace55: (face) → {node};
}

functions {
	trace55: (ℝ²ˣ²) → ℝ;
	perp55: (ℝ²) → ℝ²;
	tensProduct55: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct55: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse55: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes56: (∅) → {node};
	cells56: (∅) → {cell};
	outerFaces56: (∅) → {face};
	innerNodes56: (∅) → {node};
	nodesOfCell56: (cell) → {node};
	cellsOfNode56: (node) → {cell};
	nodesOfFace56: (face) → {node};
}

functions {
	trace56: (ℝ²ˣ²) → ℝ;
	perp56: (ℝ²) → ℝ²;
	tensProduct56: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct56: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse56: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes57: (∅) → {node};
	cells57: (∅) → {cell};
	outerFaces57: (∅) → {face};
	innerNodes57: (∅) → {node};
	nodesOfCell57: (cell) → {node};
	cellsOfNode57: (node) → {cell};
	nodesOfFace57: (face) → {node};
}

functions {
	trace57: (ℝ²ˣ²) → ℝ;
	perp57: (ℝ²) → ℝ²;
	tensProduct57: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct57: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse57: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes58: (∅) → {node};
	cells58: (∅) → {cell};
	outerFaces58: (∅) → {face};
	innerNodes58: (∅) → {node};
	nodesOfCell58: (cell) → {node};
	cellsOfNode58: (node) → {cell};
	nodesOfFace58: (face) → {node};
}

functions {
	trace58: (ℝ²ˣ²) → ℝ;
	perp58: (ℝ²) → ℝ²;
	tensProduct58: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct58: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse58: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes59: (∅) → {node};
	cells59: (∅) → {cell};
	outerFaces59: (∅) → {face};
	innerNodes59: (∅) → {node};
	nodesOfCell59: (cell) → {node};
	cellsOfNode59: (node) → {cell};
	nodesOfFace59: (face) → {node};
}

functions {
	trace59: (ℝ²ˣ²) → ℝ;
	perp59: (ℝ²) → ℝ²;
	tensProduct59: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct59: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse59: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes60: (∅) → {node};
	cells60: (∅) → {cell};
	outerFaces60: (∅) → {face};
	innerNodes60: (∅) → {node};
	nodesOfCell60: (cell) → {node};
	cellsOfNode60: (node) → {cell};
	nodesOfFace60: (face) → {node};
}

functions {
	trace60: (ℝ²ˣ²) → ℝ;
	perp60: (ℝ²) → ℝ²;
	tensProduct60: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct60: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse60: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes61: (∅) → {node};
	cells61: (∅) → {cell};
	outerFaces61: (∅) → {face};
	innerNodes61: (∅) → {node};
	nodesOfCell61: (cell) → {node};
	cellsOfNode61: (node) → {cell};
	nodesOfFace61: (face) → {node};
}

functions {
	trace61: (ℝ²ˣ²) → ℝ;
	perp61: (ℝ²) → ℝ²;
	tensProduct61: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct61: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse61: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes62: (∅) → {node};
	cells62: (∅) → {cell};
	outerFaces62: (∅) → {face};
	innerNodes62: (∅) → {node};
	nodesOfCell62: (cell) → {node};
	cellsOfNode62: (node) → {cell};
	nodesOfFace62: (face) → {node};
}

functions {
	trace62: (ℝ²ˣ²) → ℝ;
	perp62: (ℝ²) → ℝ²;
	tensProduct62: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct62: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse62: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes63: (∅) → {node};
	cells63: (∅) → {cell};
	outerFaces63: (∅) → {face};
	innerNodes63: (∅) → {node};
	nodesOfCell63: (cell) → {node};
	cellsOfNode63: (node) → {cell};
	nodesOfFace63: (face) → {node};
}

functions {
	trace63: (ℝ²ˣ²) → ℝ;
	perp63: (ℝ²) → ℝ²;
	tensProduct63: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct63: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse63: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes64: (∅) → {node};
	cells64: (∅) → {cell};
	outerFaces64: (∅) → {face};
	innerNodes64: (∅) → {node};
	nodesOfCell64: (cell) → {node};
	cellsOfNode64: (node) → {cell};
	nodesOfFace64: (face) → {node};
}

functions {
	trace64: (ℝ²ˣ²) → ℝ;
	perp64: (ℝ²) → ℝ²;
	tensProduct64: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct64: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse64: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes65: (∅) → {node};
	cells65: (∅) → {cell};
	outerFaces65: (∅) → {face};
	innerNodes65: (∅) → {node};
	nodesOfCell65: (cell) → {node};
	cellsOfNode65: (node) → {cell};
	nodesOfFace65: (face) → {node};
}

functions {
	trace65: (ℝ²ˣ²) → ℝ;
	perp65: (ℝ²) → ℝ²;
	tensProduct65: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct65: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse65: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes66: (∅) → {node};
	cells66: (∅) → {cell};
	outerFaces66: (∅) → {face};
	innerNodes66: (∅) → {node};
	nodesOfCell66: (cell) → {node};
	cellsOfNode66: (node) → {cell};
	nodesOfFace66: (face) → {node};
}

functions {
	trace66: (ℝ²ˣ²) → ℝ;
	perp66: (ℝ²) → ℝ²;
	tensProduct66: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct66: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse66: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes67: (∅) → {node};
	cells67: (∅) → {cell};
	outerFaces67: (∅) → {face};
	innerNodes67: (∅) → {node};
	nodesOfCell67: (cell) → {node};
	cellsOfNode67: (node) → {cell};
	nodesOfFace67: (face) → {node};
}

functions {
	trace67: (ℝ²ˣ²) → ℝ;
	perp67: (ℝ²) → ℝ²;
	tensProduct67: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct67: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse67: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes68: (∅) → {node};
	cells68: (∅) → {cell};
	outerFaces68: (∅) → {face};
	innerNodes68: (∅) → {node};
	nodesOfCell68: (cell) → {node};
	cellsOfNode68: (node) → {cell};
	nodesOfFace68: (face) → {node};
}

functions {
	trace68: (ℝ²ˣ²) → ℝ;
	perp68: (ℝ²) → ℝ²;
	tensProduct68: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct68: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse68: (ℝ²ˣ²) → ℝ²ˣ²;
}


connectivities {
	nodes69: (∅) → {node};
	cells69: (∅) → {cell};
	outerFaces69: (∅) → {face};
	innerNodes69: (∅) → {node};
	nodesOfCell69: (cell) → {node};
	cellsOfNode69: (node) → {cell};
	nodesOfFace69: (face) → {node};
}

functions {
	trace69: (ℝ²ˣ²) → ℝ;
	perp69: (ℝ²) → ℝ²;
	tensProduct69: (ℝ², ℝ²) → ℝ²ˣ²;
	matVectProduct69: (ℝ²ˣ², ℝ²) → ℝ²;
	inverse69: (ℝ²ˣ²) → ℝ²ˣ²;
}


// Options obligatoires pour générer
const ℝ LENGTH1 = 0.01;
const ℕ X_EDGE_ELEMS1 = 100;
const ℕ Y_EDGE_ELEMS1 = 10;
const ℕ Z_EDGE_ELEMS1 = 1;
const ℝ option_stoptime1 = 0.2;
const ℕ option_max_iterations1 = 20000;

// Autres options
const ℝ γ1 = 1.4;
const ℝ option_x_interface1 = 0.5;
const ℝ option_δt_ini1 = 1.0e-5;
const ℝ option_δt_cfl1 = 0.4;
const ℝ option_ρ_ini_zg1 = 1.0;
const ℝ option_ρ_ini_zd1 = 0.125;
const ℝ option_p_ini_zg1 = 1.0;
const ℝ option_p_ini_zd1 = 0.1;

ℝ t1=0.0;
ℝ δt1=0.0;

ℝ² coord1[nodes1], X1[nodes1], b1[nodes1], bt1[nodes1];
ℝ²ˣ² Ar1[nodes1], Mt1[nodes1];
ℝ² ur1[nodes1];
ℝ p_ic1[cells1], ρ_ic1[cells1], V_ic1[cells1];
ℝ c1[cells1], m1[cells1], p1[cells1], ρ1[cells1], e1[cells1], E1[cells1], V1[cells1];
ℝ δtj1[cells1];
ℝ² uj1[cells1], center1[cells1];
ℝ l1[cells1, nodesOfCell1];
ℝ² C_ic1[cells1, nodesOfCell1], C1[cells1, nodesOfCell1], F1[cells1, nodesOfCell1];
ℝ²ˣ² Ajr1[cells1, nodesOfCell1];


// Options obligatoires pour générer
const ℝ LENGTH2 = 0.01;
const ℕ X_EDGE_ELEMS2 = 100;
const ℕ Y_EDGE_ELEMS2 = 10;
const ℕ Z_EDGE_ELEMS2 = 1;
const ℝ option_stoptime2 = 0.2;
const ℕ option_max_iterations2 = 20000;

// Autres options
const ℝ γ2 = 1.4;
const ℝ option_x_interface2 = 0.5;
const ℝ option_δt_ini2 = 1.0e-5;
const ℝ option_δt_cfl2 = 0.4;
const ℝ option_ρ_ini_zg2 = 1.0;
const ℝ option_ρ_ini_zd2 = 0.125;
const ℝ option_p_ini_zg2 = 1.0;
const ℝ option_p_ini_zd2 = 0.1;

ℝ t2=0.0;
ℝ δt2=0.0;

ℝ² coord2[nodes2], X2[nodes2], b2[nodes2], bt2[nodes2];
ℝ²ˣ² Ar2[nodes2], Mt2[nodes2];
ℝ² ur2[nodes2];
ℝ p_ic2[cells2], ρ_ic2[cells2], V_ic2[cells2];
ℝ c2[cells2], m2[cells2], p2[cells2], ρ2[cells2], e2[cells2], E2[cells2], V2[cells2];
ℝ δtj2[cells2];
ℝ² uj2[cells2], center2[cells2];
ℝ l2[cells2, nodesOfCell2];
ℝ² C_ic2[cells2, nodesOfCell2], C2[cells2, nodesOfCell2], F2[cells2, nodesOfCell2];
ℝ²ˣ² Ajr2[cells2, nodesOfCell2];


// Options obligatoires pour générer
const ℝ LENGTH3 = 0.01;
const ℕ X_EDGE_ELEMS3 = 100;
const ℕ Y_EDGE_ELEMS3 = 10;
const ℕ Z_EDGE_ELEMS3 = 1;
const ℝ option_stoptime3 = 0.2;
const ℕ option_max_iterations3 = 20000;

// Autres options
const ℝ γ3 = 1.4;
const ℝ option_x_interface3 = 0.5;
const ℝ option_δt_ini3 = 1.0e-5;
const ℝ option_δt_cfl3 = 0.4;
const ℝ option_ρ_ini_zg3 = 1.0;
const ℝ option_ρ_ini_zd3 = 0.125;
const ℝ option_p_ini_zg3 = 1.0;
const ℝ option_p_ini_zd3 = 0.1;

ℝ t3=0.0;
ℝ δt3=0.0;

ℝ² coord3[nodes3], X3[nodes3], b3[nodes3], bt3[nodes3];
ℝ²ˣ² Ar3[nodes3], Mt3[nodes3];
ℝ² ur3[nodes3];
ℝ p_ic3[cells3], ρ_ic3[cells3], V_ic3[cells3];
ℝ c3[cells3], m3[cells3], p3[cells3], ρ3[cells3], e3[cells3], E3[cells3], V3[cells3];
ℝ δtj3[cells3];
ℝ² uj3[cells3], center3[cells3];
ℝ l3[cells3, nodesOfCell3];
ℝ² C_ic3[cells3, nodesOfCell3], C3[cells3, nodesOfCell3], F3[cells3, nodesOfCell3];
ℝ²ˣ² Ajr3[cells3, nodesOfCell3];


// Options obligatoires pour générer
const ℝ LENGTH4 = 0.01;
const ℕ X_EDGE_ELEMS4 = 100;
const ℕ Y_EDGE_ELEMS4 = 10;
const ℕ Z_EDGE_ELEMS4 = 1;
const ℝ option_stoptime4 = 0.2;
const ℕ option_max_iterations4 = 20000;

// Autres options
const ℝ γ4 = 1.4;
const ℝ option_x_interface4 = 0.5;
const ℝ option_δt_ini4 = 1.0e-5;
const ℝ option_δt_cfl4 = 0.4;
const ℝ option_ρ_ini_zg4 = 1.0;
const ℝ option_ρ_ini_zd4 = 0.125;
const ℝ option_p_ini_zg4 = 1.0;
const ℝ option_p_ini_zd4 = 0.1;

ℝ t4=0.0;
ℝ δt4=0.0;

ℝ² coord4[nodes4], X4[nodes4], b4[nodes4], bt4[nodes4];
ℝ²ˣ² Ar4[nodes4], Mt4[nodes4];
ℝ² ur4[nodes4];
ℝ p_ic4[cells4], ρ_ic4[cells4], V_ic4[cells4];
ℝ c4[cells4], m4[cells4], p4[cells4], ρ4[cells4], e4[cells4], E4[cells4], V4[cells4];
ℝ δtj4[cells4];
ℝ² uj4[cells4], center4[cells4];
ℝ l4[cells4, nodesOfCell4];
ℝ² C_ic4[cells4, nodesOfCell4], C4[cells4, nodesOfCell4], F4[cells4, nodesOfCell4];
ℝ²ˣ² Ajr4[cells4, nodesOfCell4];


// Options obligatoires pour générer
const ℝ LENGTH5 = 0.01;
const ℕ X_EDGE_ELEMS5 = 100;
const ℕ Y_EDGE_ELEMS5 = 10;
const ℕ Z_EDGE_ELEMS5 = 1;
const ℝ option_stoptime5 = 0.2;
const ℕ option_max_iterations5 = 20000;

// Autres options
const ℝ γ5 = 1.4;
const ℝ option_x_interface5 = 0.5;
const ℝ option_δt_ini5 = 1.0e-5;
const ℝ option_δt_cfl5 = 0.4;
const ℝ option_ρ_ini_zg5 = 1.0;
const ℝ option_ρ_ini_zd5 = 0.125;
const ℝ option_p_ini_zg5 = 1.0;
const ℝ option_p_ini_zd5 = 0.1;

ℝ t5=0.0;
ℝ δt5=0.0;

ℝ² coord5[nodes5], X5[nodes5], b5[nodes5], bt5[nodes5];
ℝ²ˣ² Ar5[nodes5], Mt5[nodes5];
ℝ² ur5[nodes5];
ℝ p_ic5[cells5], ρ_ic5[cells5], V_ic5[cells5];
ℝ c5[cells5], m5[cells5], p5[cells5], ρ5[cells5], e5[cells5], E5[cells5], V5[cells5];
ℝ δtj5[cells5];
ℝ² uj5[cells5], center5[cells5];
ℝ l5[cells5, nodesOfCell5];
ℝ² C_ic5[cells5, nodesOfCell5], C5[cells5, nodesOfCell5], F5[cells5, nodesOfCell5];
ℝ²ˣ² Ajr5[cells5, nodesOfCell5];


// Options obligatoires pour générer
const ℝ LENGTH6 = 0.01;
const ℕ X_EDGE_ELEMS6 = 100;
const ℕ Y_EDGE_ELEMS6 = 10;
const ℕ Z_EDGE_ELEMS6 = 1;
const ℝ option_stoptime6 = 0.2;
const ℕ option_max_iterations6 = 20000;

// Autres options
const ℝ γ6 = 1.4;
const ℝ option_x_interface6 = 0.5;
const ℝ option_δt_ini6 = 1.0e-5;
const ℝ option_δt_cfl6 = 0.4;
const ℝ option_ρ_ini_zg6 = 1.0;
const ℝ option_ρ_ini_zd6 = 0.125;
const ℝ option_p_ini_zg6 = 1.0;
const ℝ option_p_ini_zd6 = 0.1;

ℝ t6=0.0;
ℝ δt6=0.0;

ℝ² coord6[nodes6], X6[nodes6], b6[nodes6], bt6[nodes6];
ℝ²ˣ² Ar6[nodes6], Mt6[nodes6];
ℝ² ur6[nodes6];
ℝ p_ic6[cells6], ρ_ic6[cells6], V_ic6[cells6];
ℝ c6[cells6], m6[cells6], p6[cells6], ρ6[cells6], e6[cells6], E6[cells6], V6[cells6];
ℝ δtj6[cells6];
ℝ² uj6[cells6], center6[cells6];
ℝ l6[cells6, nodesOfCell6];
ℝ² C_ic6[cells6, nodesOfCell6], C6[cells6, nodesOfCell6], F6[cells6, nodesOfCell6];
ℝ²ˣ² Ajr6[cells6, nodesOfCell6];


// Options obligatoires pour générer
const ℝ LENGTH7 = 0.01;
const ℕ X_EDGE_ELEMS7 = 100;
const ℕ Y_EDGE_ELEMS7 = 10;
const ℕ Z_EDGE_ELEMS7 = 1;
const ℝ option_stoptime7 = 0.2;
const ℕ option_max_iterations7 = 20000;

// Autres options
const ℝ γ7 = 1.4;
const ℝ option_x_interface7 = 0.5;
const ℝ option_δt_ini7 = 1.0e-5;
const ℝ option_δt_cfl7 = 0.4;
const ℝ option_ρ_ini_zg7 = 1.0;
const ℝ option_ρ_ini_zd7 = 0.125;
const ℝ option_p_ini_zg7 = 1.0;
const ℝ option_p_ini_zd7 = 0.1;

ℝ t7=0.0;
ℝ δt7=0.0;

ℝ² coord7[nodes7], X7[nodes7], b7[nodes7], bt7[nodes7];
ℝ²ˣ² Ar7[nodes7], Mt7[nodes7];
ℝ² ur7[nodes7];
ℝ p_ic7[cells7], ρ_ic7[cells7], V_ic7[cells7];
ℝ c7[cells7], m7[cells7], p7[cells7], ρ7[cells7], e7[cells7], E7[cells7], V7[cells7];
ℝ δtj7[cells7];
ℝ² uj7[cells7], center7[cells7];
ℝ l7[cells7, nodesOfCell7];
ℝ² C_ic7[cells7, nodesOfCell7], C7[cells7, nodesOfCell7], F7[cells7, nodesOfCell7];
ℝ²ˣ² Ajr7[cells7, nodesOfCell7];


// Options obligatoires pour générer
const ℝ LENGTH8 = 0.01;
const ℕ X_EDGE_ELEMS8 = 100;
const ℕ Y_EDGE_ELEMS8 = 10;
const ℕ Z_EDGE_ELEMS8 = 1;
const ℝ option_stoptime8 = 0.2;
const ℕ option_max_iterations8 = 20000;

// Autres options
const ℝ γ8 = 1.4;
const ℝ option_x_interface8 = 0.5;
const ℝ option_δt_ini8 = 1.0e-5;
const ℝ option_δt_cfl8 = 0.4;
const ℝ option_ρ_ini_zg8 = 1.0;
const ℝ option_ρ_ini_zd8 = 0.125;
const ℝ option_p_ini_zg8 = 1.0;
const ℝ option_p_ini_zd8 = 0.1;

ℝ t8=0.0;
ℝ δt8=0.0;

ℝ² coord8[nodes8], X8[nodes8], b8[nodes8], bt8[nodes8];
ℝ²ˣ² Ar8[nodes8], Mt8[nodes8];
ℝ² ur8[nodes8];
ℝ p_ic8[cells8], ρ_ic8[cells8], V_ic8[cells8];
ℝ c8[cells8], m8[cells8], p8[cells8], ρ8[cells8], e8[cells8], E8[cells8], V8[cells8];
ℝ δtj8[cells8];
ℝ² uj8[cells8], center8[cells8];
ℝ l8[cells8, nodesOfCell8];
ℝ² C_ic8[cells8, nodesOfCell8], C8[cells8, nodesOfCell8], F8[cells8, nodesOfCell8];
ℝ²ˣ² Ajr8[cells8, nodesOfCell8];


// Options obligatoires pour générer
const ℝ LENGTH9 = 0.01;
const ℕ X_EDGE_ELEMS9 = 100;
const ℕ Y_EDGE_ELEMS9 = 10;
const ℕ Z_EDGE_ELEMS9 = 1;
const ℝ option_stoptime9 = 0.2;
const ℕ option_max_iterations9 = 20000;

// Autres options
const ℝ γ9 = 1.4;
const ℝ option_x_interface9 = 0.5;
const ℝ option_δt_ini9 = 1.0e-5;
const ℝ option_δt_cfl9 = 0.4;
const ℝ option_ρ_ini_zg9 = 1.0;
const ℝ option_ρ_ini_zd9 = 0.125;
const ℝ option_p_ini_zg9 = 1.0;
const ℝ option_p_ini_zd9 = 0.1;

ℝ t9=0.0;
ℝ δt9=0.0;

ℝ² coord9[nodes9], X9[nodes9], b9[nodes9], bt9[nodes9];
ℝ²ˣ² Ar9[nodes9], Mt9[nodes9];
ℝ² ur9[nodes9];
ℝ p_ic9[cells9], ρ_ic9[cells9], V_ic9[cells9];
ℝ c9[cells9], m9[cells9], p9[cells9], ρ9[cells9], e9[cells9], E9[cells9], V9[cells9];
ℝ δtj9[cells9];
ℝ² uj9[cells9], center9[cells9];
ℝ l9[cells9, nodesOfCell9];
ℝ² C_ic9[cells9, nodesOfCell9], C9[cells9, nodesOfCell9], F9[cells9, nodesOfCell9];
ℝ²ˣ² Ajr9[cells9, nodesOfCell9];


// Options obligatoires pour générer
const ℝ LENGTH10 = 0.01;
const ℕ X_EDGE_ELEMS10 = 100;
const ℕ Y_EDGE_ELEMS10 = 10;
const ℕ Z_EDGE_ELEMS10 = 1;
const ℝ option_stoptime10 = 0.2;
const ℕ option_max_iterations10 = 20000;

// Autres options
const ℝ γ10 = 1.4;
const ℝ option_x_interface10 = 0.5;
const ℝ option_δt_ini10 = 1.0e-5;
const ℝ option_δt_cfl10 = 0.4;
const ℝ option_ρ_ini_zg10 = 1.0;
const ℝ option_ρ_ini_zd10 = 0.125;
const ℝ option_p_ini_zg10 = 1.0;
const ℝ option_p_ini_zd10 = 0.1;

ℝ t10=0.0;
ℝ δt10=0.0;

ℝ² coord10[nodes10], X10[nodes10], b10[nodes10], bt10[nodes10];
ℝ²ˣ² Ar10[nodes10], Mt10[nodes10];
ℝ² ur10[nodes10];
ℝ p_ic10[cells10], ρ_ic10[cells10], V_ic10[cells10];
ℝ c10[cells10], m10[cells10], p10[cells10], ρ10[cells10], e10[cells10], E10[cells10], V10[cells10];
ℝ δtj10[cells10];
ℝ² uj10[cells10], center10[cells10];
ℝ l10[cells10, nodesOfCell10];
ℝ² C_ic10[cells10, nodesOfCell10], C10[cells10, nodesOfCell10], F10[cells10, nodesOfCell10];
ℝ²ˣ² Ajr10[cells10, nodesOfCell10];


// Options obligatoires pour générer
const ℝ LENGTH11 = 0.01;
const ℕ X_EDGE_ELEMS11 = 100;
const ℕ Y_EDGE_ELEMS11 = 10;
const ℕ Z_EDGE_ELEMS11 = 1;
const ℝ option_stoptime11 = 0.2;
const ℕ option_max_iterations11 = 20000;

// Autres options
const ℝ γ11 = 1.4;
const ℝ option_x_interface11 = 0.5;
const ℝ option_δt_ini11 = 1.0e-5;
const ℝ option_δt_cfl11 = 0.4;
const ℝ option_ρ_ini_zg11 = 1.0;
const ℝ option_ρ_ini_zd11 = 0.125;
const ℝ option_p_ini_zg11 = 1.0;
const ℝ option_p_ini_zd11 = 0.1;

ℝ t11=0.0;
ℝ δt11=0.0;

ℝ² coord11[nodes11], X11[nodes11], b11[nodes11], bt11[nodes11];
ℝ²ˣ² Ar11[nodes11], Mt11[nodes11];
ℝ² ur11[nodes11];
ℝ p_ic11[cells11], ρ_ic11[cells11], V_ic11[cells11];
ℝ c11[cells11], m11[cells11], p11[cells11], ρ11[cells11], e11[cells11], E11[cells11], V11[cells11];
ℝ δtj11[cells11];
ℝ² uj11[cells11], center11[cells11];
ℝ l11[cells11, nodesOfCell11];
ℝ² C_ic11[cells11, nodesOfCell11], C11[cells11, nodesOfCell11], F11[cells11, nodesOfCell11];
ℝ²ˣ² Ajr11[cells11, nodesOfCell11];


// Options obligatoires pour générer
const ℝ LENGTH12 = 0.01;
const ℕ X_EDGE_ELEMS12 = 100;
const ℕ Y_EDGE_ELEMS12 = 10;
const ℕ Z_EDGE_ELEMS12 = 1;
const ℝ option_stoptime12 = 0.2;
const ℕ option_max_iterations12 = 20000;

// Autres options
const ℝ γ12 = 1.4;
const ℝ option_x_interface12 = 0.5;
const ℝ option_δt_ini12 = 1.0e-5;
const ℝ option_δt_cfl12 = 0.4;
const ℝ option_ρ_ini_zg12 = 1.0;
const ℝ option_ρ_ini_zd12 = 0.125;
const ℝ option_p_ini_zg12 = 1.0;
const ℝ option_p_ini_zd12 = 0.1;

ℝ t12=0.0;
ℝ δt12=0.0;

ℝ² coord12[nodes12], X12[nodes12], b12[nodes12], bt12[nodes12];
ℝ²ˣ² Ar12[nodes12], Mt12[nodes12];
ℝ² ur12[nodes12];
ℝ p_ic12[cells12], ρ_ic12[cells12], V_ic12[cells12];
ℝ c12[cells12], m12[cells12], p12[cells12], ρ12[cells12], e12[cells12], E12[cells12], V12[cells12];
ℝ δtj12[cells12];
ℝ² uj12[cells12], center12[cells12];
ℝ l12[cells12, nodesOfCell12];
ℝ² C_ic12[cells12, nodesOfCell12], C12[cells12, nodesOfCell12], F12[cells12, nodesOfCell12];
ℝ²ˣ² Ajr12[cells12, nodesOfCell12];


// Options obligatoires pour générer
const ℝ LENGTH13 = 0.01;
const ℕ X_EDGE_ELEMS13 = 100;
const ℕ Y_EDGE_ELEMS13 = 10;
const ℕ Z_EDGE_ELEMS13 = 1;
const ℝ option_stoptime13 = 0.2;
const ℕ option_max_iterations13 = 20000;

// Autres options
const ℝ γ13 = 1.4;
const ℝ option_x_interface13 = 0.5;
const ℝ option_δt_ini13 = 1.0e-5;
const ℝ option_δt_cfl13 = 0.4;
const ℝ option_ρ_ini_zg13 = 1.0;
const ℝ option_ρ_ini_zd13 = 0.125;
const ℝ option_p_ini_zg13 = 1.0;
const ℝ option_p_ini_zd13 = 0.1;

ℝ t13=0.0;
ℝ δt13=0.0;

ℝ² coord13[nodes13], X13[nodes13], b13[nodes13], bt13[nodes13];
ℝ²ˣ² Ar13[nodes13], Mt13[nodes13];
ℝ² ur13[nodes13];
ℝ p_ic13[cells13], ρ_ic13[cells13], V_ic13[cells13];
ℝ c13[cells13], m13[cells13], p13[cells13], ρ13[cells13], e13[cells13], E13[cells13], V13[cells13];
ℝ δtj13[cells13];
ℝ² uj13[cells13], center13[cells13];
ℝ l13[cells13, nodesOfCell13];
ℝ² C_ic13[cells13, nodesOfCell13], C13[cells13, nodesOfCell13], F13[cells13, nodesOfCell13];
ℝ²ˣ² Ajr13[cells13, nodesOfCell13];


// Options obligatoires pour générer
const ℝ LENGTH14 = 0.01;
const ℕ X_EDGE_ELEMS14 = 100;
const ℕ Y_EDGE_ELEMS14 = 10;
const ℕ Z_EDGE_ELEMS14 = 1;
const ℝ option_stoptime14 = 0.2;
const ℕ option_max_iterations14 = 20000;

// Autres options
const ℝ γ14 = 1.4;
const ℝ option_x_interface14 = 0.5;
const ℝ option_δt_ini14 = 1.0e-5;
const ℝ option_δt_cfl14 = 0.4;
const ℝ option_ρ_ini_zg14 = 1.0;
const ℝ option_ρ_ini_zd14 = 0.125;
const ℝ option_p_ini_zg14 = 1.0;
const ℝ option_p_ini_zd14 = 0.1;

ℝ t14=0.0;
ℝ δt14=0.0;

ℝ² coord14[nodes14], X14[nodes14], b14[nodes14], bt14[nodes14];
ℝ²ˣ² Ar14[nodes14], Mt14[nodes14];
ℝ² ur14[nodes14];
ℝ p_ic14[cells14], ρ_ic14[cells14], V_ic14[cells14];
ℝ c14[cells14], m14[cells14], p14[cells14], ρ14[cells14], e14[cells14], E14[cells14], V14[cells14];
ℝ δtj14[cells14];
ℝ² uj14[cells14], center14[cells14];
ℝ l14[cells14, nodesOfCell14];
ℝ² C_ic14[cells14, nodesOfCell14], C14[cells14, nodesOfCell14], F14[cells14, nodesOfCell14];
ℝ²ˣ² Ajr14[cells14, nodesOfCell14];


// Options obligatoires pour générer
const ℝ LENGTH15 = 0.01;
const ℕ X_EDGE_ELEMS15 = 100;
const ℕ Y_EDGE_ELEMS15 = 10;
const ℕ Z_EDGE_ELEMS15 = 1;
const ℝ option_stoptime15 = 0.2;
const ℕ option_max_iterations15 = 20000;

// Autres options
const ℝ γ15 = 1.4;
const ℝ option_x_interface15 = 0.5;
const ℝ option_δt_ini15 = 1.0e-5;
const ℝ option_δt_cfl15 = 0.4;
const ℝ option_ρ_ini_zg15 = 1.0;
const ℝ option_ρ_ini_zd15 = 0.125;
const ℝ option_p_ini_zg15 = 1.0;
const ℝ option_p_ini_zd15 = 0.1;

ℝ t15=0.0;
ℝ δt15=0.0;

ℝ² coord15[nodes15], X15[nodes15], b15[nodes15], bt15[nodes15];
ℝ²ˣ² Ar15[nodes15], Mt15[nodes15];
ℝ² ur15[nodes15];
ℝ p_ic15[cells15], ρ_ic15[cells15], V_ic15[cells15];
ℝ c15[cells15], m15[cells15], p15[cells15], ρ15[cells15], e15[cells15], E15[cells15], V15[cells15];
ℝ δtj15[cells15];
ℝ² uj15[cells15], center15[cells15];
ℝ l15[cells15, nodesOfCell15];
ℝ² C_ic15[cells15, nodesOfCell15], C15[cells15, nodesOfCell15], F15[cells15, nodesOfCell15];
ℝ²ˣ² Ajr15[cells15, nodesOfCell15];


// Options obligatoires pour générer
const ℝ LENGTH16 = 0.01;
const ℕ X_EDGE_ELEMS16 = 100;
const ℕ Y_EDGE_ELEMS16 = 10;
const ℕ Z_EDGE_ELEMS16 = 1;
const ℝ option_stoptime16 = 0.2;
const ℕ option_max_iterations16 = 20000;

// Autres options
const ℝ γ16 = 1.4;
const ℝ option_x_interface16 = 0.5;
const ℝ option_δt_ini16 = 1.0e-5;
const ℝ option_δt_cfl16 = 0.4;
const ℝ option_ρ_ini_zg16 = 1.0;
const ℝ option_ρ_ini_zd16 = 0.125;
const ℝ option_p_ini_zg16 = 1.0;
const ℝ option_p_ini_zd16 = 0.1;

ℝ t16=0.0;
ℝ δt16=0.0;

ℝ² coord16[nodes16], X16[nodes16], b16[nodes16], bt16[nodes16];
ℝ²ˣ² Ar16[nodes16], Mt16[nodes16];
ℝ² ur16[nodes16];
ℝ p_ic16[cells16], ρ_ic16[cells16], V_ic16[cells16];
ℝ c16[cells16], m16[cells16], p16[cells16], ρ16[cells16], e16[cells16], E16[cells16], V16[cells16];
ℝ δtj16[cells16];
ℝ² uj16[cells16], center16[cells16];
ℝ l16[cells16, nodesOfCell16];
ℝ² C_ic16[cells16, nodesOfCell16], C16[cells16, nodesOfCell16], F16[cells16, nodesOfCell16];
ℝ²ˣ² Ajr16[cells16, nodesOfCell16];


// Options obligatoires pour générer
const ℝ LENGTH17 = 0.01;
const ℕ X_EDGE_ELEMS17 = 100;
const ℕ Y_EDGE_ELEMS17 = 10;
const ℕ Z_EDGE_ELEMS17 = 1;
const ℝ option_stoptime17 = 0.2;
const ℕ option_max_iterations17 = 20000;

// Autres options
const ℝ γ17 = 1.4;
const ℝ option_x_interface17 = 0.5;
const ℝ option_δt_ini17 = 1.0e-5;
const ℝ option_δt_cfl17 = 0.4;
const ℝ option_ρ_ini_zg17 = 1.0;
const ℝ option_ρ_ini_zd17 = 0.125;
const ℝ option_p_ini_zg17 = 1.0;
const ℝ option_p_ini_zd17 = 0.1;

ℝ t17=0.0;
ℝ δt17=0.0;

ℝ² coord17[nodes17], X17[nodes17], b17[nodes17], bt17[nodes17];
ℝ²ˣ² Ar17[nodes17], Mt17[nodes17];
ℝ² ur17[nodes17];
ℝ p_ic17[cells17], ρ_ic17[cells17], V_ic17[cells17];
ℝ c17[cells17], m17[cells17], p17[cells17], ρ17[cells17], e17[cells17], E17[cells17], V17[cells17];
ℝ δtj17[cells17];
ℝ² uj17[cells17], center17[cells17];
ℝ l17[cells17, nodesOfCell17];
ℝ² C_ic17[cells17, nodesOfCell17], C17[cells17, nodesOfCell17], F17[cells17, nodesOfCell17];
ℝ²ˣ² Ajr17[cells17, nodesOfCell17];


// Options obligatoires pour générer
const ℝ LENGTH18 = 0.01;
const ℕ X_EDGE_ELEMS18 = 100;
const ℕ Y_EDGE_ELEMS18 = 10;
const ℕ Z_EDGE_ELEMS18 = 1;
const ℝ option_stoptime18 = 0.2;
const ℕ option_max_iterations18 = 20000;

// Autres options
const ℝ γ18 = 1.4;
const ℝ option_x_interface18 = 0.5;
const ℝ option_δt_ini18 = 1.0e-5;
const ℝ option_δt_cfl18 = 0.4;
const ℝ option_ρ_ini_zg18 = 1.0;
const ℝ option_ρ_ini_zd18 = 0.125;
const ℝ option_p_ini_zg18 = 1.0;
const ℝ option_p_ini_zd18 = 0.1;

ℝ t18=0.0;
ℝ δt18=0.0;

ℝ² coord18[nodes18], X18[nodes18], b18[nodes18], bt18[nodes18];
ℝ²ˣ² Ar18[nodes18], Mt18[nodes18];
ℝ² ur18[nodes18];
ℝ p_ic18[cells18], ρ_ic18[cells18], V_ic18[cells18];
ℝ c18[cells18], m18[cells18], p18[cells18], ρ18[cells18], e18[cells18], E18[cells18], V18[cells18];
ℝ δtj18[cells18];
ℝ² uj18[cells18], center18[cells18];
ℝ l18[cells18, nodesOfCell18];
ℝ² C_ic18[cells18, nodesOfCell18], C18[cells18, nodesOfCell18], F18[cells18, nodesOfCell18];
ℝ²ˣ² Ajr18[cells18, nodesOfCell18];


// Options obligatoires pour générer
const ℝ LENGTH19 = 0.01;
const ℕ X_EDGE_ELEMS19 = 100;
const ℕ Y_EDGE_ELEMS19 = 10;
const ℕ Z_EDGE_ELEMS19 = 1;
const ℝ option_stoptime19 = 0.2;
const ℕ option_max_iterations19 = 20000;

// Autres options
const ℝ γ19 = 1.4;
const ℝ option_x_interface19 = 0.5;
const ℝ option_δt_ini19 = 1.0e-5;
const ℝ option_δt_cfl19 = 0.4;
const ℝ option_ρ_ini_zg19 = 1.0;
const ℝ option_ρ_ini_zd19 = 0.125;
const ℝ option_p_ini_zg19 = 1.0;
const ℝ option_p_ini_zd19 = 0.1;

ℝ t19=0.0;
ℝ δt19=0.0;

ℝ² coord19[nodes19], X19[nodes19], b19[nodes19], bt19[nodes19];
ℝ²ˣ² Ar19[nodes19], Mt19[nodes19];
ℝ² ur19[nodes19];
ℝ p_ic19[cells19], ρ_ic19[cells19], V_ic19[cells19];
ℝ c19[cells19], m19[cells19], p19[cells19], ρ19[cells19], e19[cells19], E19[cells19], V19[cells19];
ℝ δtj19[cells19];
ℝ² uj19[cells19], center19[cells19];
ℝ l19[cells19, nodesOfCell19];
ℝ² C_ic19[cells19, nodesOfCell19], C19[cells19, nodesOfCell19], F19[cells19, nodesOfCell19];
ℝ²ˣ² Ajr19[cells19, nodesOfCell19];


// Options obligatoires pour générer
const ℝ LENGTH20 = 0.01;
const ℕ X_EDGE_ELEMS20 = 100;
const ℕ Y_EDGE_ELEMS20 = 10;
const ℕ Z_EDGE_ELEMS20 = 1;
const ℝ option_stoptime20 = 0.2;
const ℕ option_max_iterations20 = 20000;

// Autres options
const ℝ γ20 = 1.4;
const ℝ option_x_interface20 = 0.5;
const ℝ option_δt_ini20 = 1.0e-5;
const ℝ option_δt_cfl20 = 0.4;
const ℝ option_ρ_ini_zg20 = 1.0;
const ℝ option_ρ_ini_zd20 = 0.125;
const ℝ option_p_ini_zg20 = 1.0;
const ℝ option_p_ini_zd20 = 0.1;

ℝ t20=0.0;
ℝ δt20=0.0;

ℝ² coord20[nodes20], X20[nodes20], b20[nodes20], bt20[nodes20];
ℝ²ˣ² Ar20[nodes20], Mt20[nodes20];
ℝ² ur20[nodes20];
ℝ p_ic20[cells20], ρ_ic20[cells20], V_ic20[cells20];
ℝ c20[cells20], m20[cells20], p20[cells20], ρ20[cells20], e20[cells20], E20[cells20], V20[cells20];
ℝ δtj20[cells20];
ℝ² uj20[cells20], center20[cells20];
ℝ l20[cells20, nodesOfCell20];
ℝ² C_ic20[cells20, nodesOfCell20], C20[cells20, nodesOfCell20], F20[cells20, nodesOfCell20];
ℝ²ˣ² Ajr20[cells20, nodesOfCell20];


// Options obligatoires pour générer
const ℝ LENGTH21 = 0.01;
const ℕ X_EDGE_ELEMS21 = 100;
const ℕ Y_EDGE_ELEMS21 = 10;
const ℕ Z_EDGE_ELEMS21 = 1;
const ℝ option_stoptime21 = 0.2;
const ℕ option_max_iterations21 = 20000;

// Autres options
const ℝ γ21 = 1.4;
const ℝ option_x_interface21 = 0.5;
const ℝ option_δt_ini21 = 1.0e-5;
const ℝ option_δt_cfl21 = 0.4;
const ℝ option_ρ_ini_zg21 = 1.0;
const ℝ option_ρ_ini_zd21 = 0.125;
const ℝ option_p_ini_zg21 = 1.0;
const ℝ option_p_ini_zd21 = 0.1;

ℝ t21=0.0;
ℝ δt21=0.0;

ℝ² coord21[nodes21], X21[nodes21], b21[nodes21], bt21[nodes21];
ℝ²ˣ² Ar21[nodes21], Mt21[nodes21];
ℝ² ur21[nodes21];
ℝ p_ic21[cells21], ρ_ic21[cells21], V_ic21[cells21];
ℝ c21[cells21], m21[cells21], p21[cells21], ρ21[cells21], e21[cells21], E21[cells21], V21[cells21];
ℝ δtj21[cells21];
ℝ² uj21[cells21], center21[cells21];
ℝ l21[cells21, nodesOfCell21];
ℝ² C_ic21[cells21, nodesOfCell21], C21[cells21, nodesOfCell21], F21[cells21, nodesOfCell21];
ℝ²ˣ² Ajr21[cells21, nodesOfCell21];


// Options obligatoires pour générer
const ℝ LENGTH22 = 0.01;
const ℕ X_EDGE_ELEMS22 = 100;
const ℕ Y_EDGE_ELEMS22 = 10;
const ℕ Z_EDGE_ELEMS22 = 1;
const ℝ option_stoptime22 = 0.2;
const ℕ option_max_iterations22 = 20000;

// Autres options
const ℝ γ22 = 1.4;
const ℝ option_x_interface22 = 0.5;
const ℝ option_δt_ini22 = 1.0e-5;
const ℝ option_δt_cfl22 = 0.4;
const ℝ option_ρ_ini_zg22 = 1.0;
const ℝ option_ρ_ini_zd22 = 0.125;
const ℝ option_p_ini_zg22 = 1.0;
const ℝ option_p_ini_zd22 = 0.1;

ℝ t22=0.0;
ℝ δt22=0.0;

ℝ² coord22[nodes22], X22[nodes22], b22[nodes22], bt22[nodes22];
ℝ²ˣ² Ar22[nodes22], Mt22[nodes22];
ℝ² ur22[nodes22];
ℝ p_ic22[cells22], ρ_ic22[cells22], V_ic22[cells22];
ℝ c22[cells22], m22[cells22], p22[cells22], ρ22[cells22], e22[cells22], E22[cells22], V22[cells22];
ℝ δtj22[cells22];
ℝ² uj22[cells22], center22[cells22];
ℝ l22[cells22, nodesOfCell22];
ℝ² C_ic22[cells22, nodesOfCell22], C22[cells22, nodesOfCell22], F22[cells22, nodesOfCell22];
ℝ²ˣ² Ajr22[cells22, nodesOfCell22];


// Options obligatoires pour générer
const ℝ LENGTH23 = 0.01;
const ℕ X_EDGE_ELEMS23 = 100;
const ℕ Y_EDGE_ELEMS23 = 10;
const ℕ Z_EDGE_ELEMS23 = 1;
const ℝ option_stoptime23 = 0.2;
const ℕ option_max_iterations23 = 20000;

// Autres options
const ℝ γ23 = 1.4;
const ℝ option_x_interface23 = 0.5;
const ℝ option_δt_ini23 = 1.0e-5;
const ℝ option_δt_cfl23 = 0.4;
const ℝ option_ρ_ini_zg23 = 1.0;
const ℝ option_ρ_ini_zd23 = 0.125;
const ℝ option_p_ini_zg23 = 1.0;
const ℝ option_p_ini_zd23 = 0.1;

ℝ t23=0.0;
ℝ δt23=0.0;

ℝ² coord23[nodes23], X23[nodes23], b23[nodes23], bt23[nodes23];
ℝ²ˣ² Ar23[nodes23], Mt23[nodes23];
ℝ² ur23[nodes23];
ℝ p_ic23[cells23], ρ_ic23[cells23], V_ic23[cells23];
ℝ c23[cells23], m23[cells23], p23[cells23], ρ23[cells23], e23[cells23], E23[cells23], V23[cells23];
ℝ δtj23[cells23];
ℝ² uj23[cells23], center23[cells23];
ℝ l23[cells23, nodesOfCell23];
ℝ² C_ic23[cells23, nodesOfCell23], C23[cells23, nodesOfCell23], F23[cells23, nodesOfCell23];
ℝ²ˣ² Ajr23[cells23, nodesOfCell23];


// Options obligatoires pour générer
const ℝ LENGTH24 = 0.01;
const ℕ X_EDGE_ELEMS24 = 100;
const ℕ Y_EDGE_ELEMS24 = 10;
const ℕ Z_EDGE_ELEMS24 = 1;
const ℝ option_stoptime24 = 0.2;
const ℕ option_max_iterations24 = 20000;

// Autres options
const ℝ γ24 = 1.4;
const ℝ option_x_interface24 = 0.5;
const ℝ option_δt_ini24 = 1.0e-5;
const ℝ option_δt_cfl24 = 0.4;
const ℝ option_ρ_ini_zg24 = 1.0;
const ℝ option_ρ_ini_zd24 = 0.125;
const ℝ option_p_ini_zg24 = 1.0;
const ℝ option_p_ini_zd24 = 0.1;

ℝ t24=0.0;
ℝ δt24=0.0;

ℝ² coord24[nodes24], X24[nodes24], b24[nodes24], bt24[nodes24];
ℝ²ˣ² Ar24[nodes24], Mt24[nodes24];
ℝ² ur24[nodes24];
ℝ p_ic24[cells24], ρ_ic24[cells24], V_ic24[cells24];
ℝ c24[cells24], m24[cells24], p24[cells24], ρ24[cells24], e24[cells24], E24[cells24], V24[cells24];
ℝ δtj24[cells24];
ℝ² uj24[cells24], center24[cells24];
ℝ l24[cells24, nodesOfCell24];
ℝ² C_ic24[cells24, nodesOfCell24], C24[cells24, nodesOfCell24], F24[cells24, nodesOfCell24];
ℝ²ˣ² Ajr24[cells24, nodesOfCell24];


// Options obligatoires pour générer
const ℝ LENGTH25 = 0.01;
const ℕ X_EDGE_ELEMS25 = 100;
const ℕ Y_EDGE_ELEMS25 = 10;
const ℕ Z_EDGE_ELEMS25 = 1;
const ℝ option_stoptime25 = 0.2;
const ℕ option_max_iterations25 = 20000;

// Autres options
const ℝ γ25 = 1.4;
const ℝ option_x_interface25 = 0.5;
const ℝ option_δt_ini25 = 1.0e-5;
const ℝ option_δt_cfl25 = 0.4;
const ℝ option_ρ_ini_zg25 = 1.0;
const ℝ option_ρ_ini_zd25 = 0.125;
const ℝ option_p_ini_zg25 = 1.0;
const ℝ option_p_ini_zd25 = 0.1;

ℝ t25=0.0;
ℝ δt25=0.0;

ℝ² coord25[nodes25], X25[nodes25], b25[nodes25], bt25[nodes25];
ℝ²ˣ² Ar25[nodes25], Mt25[nodes25];
ℝ² ur25[nodes25];
ℝ p_ic25[cells25], ρ_ic25[cells25], V_ic25[cells25];
ℝ c25[cells25], m25[cells25], p25[cells25], ρ25[cells25], e25[cells25], E25[cells25], V25[cells25];
ℝ δtj25[cells25];
ℝ² uj25[cells25], center25[cells25];
ℝ l25[cells25, nodesOfCell25];
ℝ² C_ic25[cells25, nodesOfCell25], C25[cells25, nodesOfCell25], F25[cells25, nodesOfCell25];
ℝ²ˣ² Ajr25[cells25, nodesOfCell25];


// Options obligatoires pour générer
const ℝ LENGTH26 = 0.01;
const ℕ X_EDGE_ELEMS26 = 100;
const ℕ Y_EDGE_ELEMS26 = 10;
const ℕ Z_EDGE_ELEMS26 = 1;
const ℝ option_stoptime26 = 0.2;
const ℕ option_max_iterations26 = 20000;

// Autres options
const ℝ γ26 = 1.4;
const ℝ option_x_interface26 = 0.5;
const ℝ option_δt_ini26 = 1.0e-5;
const ℝ option_δt_cfl26 = 0.4;
const ℝ option_ρ_ini_zg26 = 1.0;
const ℝ option_ρ_ini_zd26 = 0.125;
const ℝ option_p_ini_zg26 = 1.0;
const ℝ option_p_ini_zd26 = 0.1;

ℝ t26=0.0;
ℝ δt26=0.0;

ℝ² coord26[nodes26], X26[nodes26], b26[nodes26], bt26[nodes26];
ℝ²ˣ² Ar26[nodes26], Mt26[nodes26];
ℝ² ur26[nodes26];
ℝ p_ic26[cells26], ρ_ic26[cells26], V_ic26[cells26];
ℝ c26[cells26], m26[cells26], p26[cells26], ρ26[cells26], e26[cells26], E26[cells26], V26[cells26];
ℝ δtj26[cells26];
ℝ² uj26[cells26], center26[cells26];
ℝ l26[cells26, nodesOfCell26];
ℝ² C_ic26[cells26, nodesOfCell26], C26[cells26, nodesOfCell26], F26[cells26, nodesOfCell26];
ℝ²ˣ² Ajr26[cells26, nodesOfCell26];


// Options obligatoires pour générer
const ℝ LENGTH27 = 0.01;
const ℕ X_EDGE_ELEMS27 = 100;
const ℕ Y_EDGE_ELEMS27 = 10;
const ℕ Z_EDGE_ELEMS27 = 1;
const ℝ option_stoptime27 = 0.2;
const ℕ option_max_iterations27 = 20000;

// Autres options
const ℝ γ27 = 1.4;
const ℝ option_x_interface27 = 0.5;
const ℝ option_δt_ini27 = 1.0e-5;
const ℝ option_δt_cfl27 = 0.4;
const ℝ option_ρ_ini_zg27 = 1.0;
const ℝ option_ρ_ini_zd27 = 0.125;
const ℝ option_p_ini_zg27 = 1.0;
const ℝ option_p_ini_zd27 = 0.1;

ℝ t27=0.0;
ℝ δt27=0.0;

ℝ² coord27[nodes27], X27[nodes27], b27[nodes27], bt27[nodes27];
ℝ²ˣ² Ar27[nodes27], Mt27[nodes27];
ℝ² ur27[nodes27];
ℝ p_ic27[cells27], ρ_ic27[cells27], V_ic27[cells27];
ℝ c27[cells27], m27[cells27], p27[cells27], ρ27[cells27], e27[cells27], E27[cells27], V27[cells27];
ℝ δtj27[cells27];
ℝ² uj27[cells27], center27[cells27];
ℝ l27[cells27, nodesOfCell27];
ℝ² C_ic27[cells27, nodesOfCell27], C27[cells27, nodesOfCell27], F27[cells27, nodesOfCell27];
ℝ²ˣ² Ajr27[cells27, nodesOfCell27];


// Options obligatoires pour générer
const ℝ LENGTH28 = 0.01;
const ℕ X_EDGE_ELEMS28 = 100;
const ℕ Y_EDGE_ELEMS28 = 10;
const ℕ Z_EDGE_ELEMS28 = 1;
const ℝ option_stoptime28 = 0.2;
const ℕ option_max_iterations28 = 20000;

// Autres options
const ℝ γ28 = 1.4;
const ℝ option_x_interface28 = 0.5;
const ℝ option_δt_ini28 = 1.0e-5;
const ℝ option_δt_cfl28 = 0.4;
const ℝ option_ρ_ini_zg28 = 1.0;
const ℝ option_ρ_ini_zd28 = 0.125;
const ℝ option_p_ini_zg28 = 1.0;
const ℝ option_p_ini_zd28 = 0.1;

ℝ t28=0.0;
ℝ δt28=0.0;

ℝ² coord28[nodes28], X28[nodes28], b28[nodes28], bt28[nodes28];
ℝ²ˣ² Ar28[nodes28], Mt28[nodes28];
ℝ² ur28[nodes28];
ℝ p_ic28[cells28], ρ_ic28[cells28], V_ic28[cells28];
ℝ c28[cells28], m28[cells28], p28[cells28], ρ28[cells28], e28[cells28], E28[cells28], V28[cells28];
ℝ δtj28[cells28];
ℝ² uj28[cells28], center28[cells28];
ℝ l28[cells28, nodesOfCell28];
ℝ² C_ic28[cells28, nodesOfCell28], C28[cells28, nodesOfCell28], F28[cells28, nodesOfCell28];
ℝ²ˣ² Ajr28[cells28, nodesOfCell28];


// Options obligatoires pour générer
const ℝ LENGTH29 = 0.01;
const ℕ X_EDGE_ELEMS29 = 100;
const ℕ Y_EDGE_ELEMS29 = 10;
const ℕ Z_EDGE_ELEMS29 = 1;
const ℝ option_stoptime29 = 0.2;
const ℕ option_max_iterations29 = 20000;

// Autres options
const ℝ γ29 = 1.4;
const ℝ option_x_interface29 = 0.5;
const ℝ option_δt_ini29 = 1.0e-5;
const ℝ option_δt_cfl29 = 0.4;
const ℝ option_ρ_ini_zg29 = 1.0;
const ℝ option_ρ_ini_zd29 = 0.125;
const ℝ option_p_ini_zg29 = 1.0;
const ℝ option_p_ini_zd29 = 0.1;

ℝ t29=0.0;
ℝ δt29=0.0;

ℝ² coord29[nodes29], X29[nodes29], b29[nodes29], bt29[nodes29];
ℝ²ˣ² Ar29[nodes29], Mt29[nodes29];
ℝ² ur29[nodes29];
ℝ p_ic29[cells29], ρ_ic29[cells29], V_ic29[cells29];
ℝ c29[cells29], m29[cells29], p29[cells29], ρ29[cells29], e29[cells29], E29[cells29], V29[cells29];
ℝ δtj29[cells29];
ℝ² uj29[cells29], center29[cells29];
ℝ l29[cells29, nodesOfCell29];
ℝ² C_ic29[cells29, nodesOfCell29], C29[cells29, nodesOfCell29], F29[cells29, nodesOfCell29];
ℝ²ˣ² Ajr29[cells29, nodesOfCell29];


// Options obligatoires pour générer
const ℝ LENGTH30 = 0.01;
const ℕ X_EDGE_ELEMS30 = 100;
const ℕ Y_EDGE_ELEMS30 = 10;
const ℕ Z_EDGE_ELEMS30 = 1;
const ℝ option_stoptime30 = 0.2;
const ℕ option_max_iterations30 = 20000;

// Autres options
const ℝ γ30 = 1.4;
const ℝ option_x_interface30 = 0.5;
const ℝ option_δt_ini30 = 1.0e-5;
const ℝ option_δt_cfl30 = 0.4;
const ℝ option_ρ_ini_zg30 = 1.0;
const ℝ option_ρ_ini_zd30 = 0.125;
const ℝ option_p_ini_zg30 = 1.0;
const ℝ option_p_ini_zd30 = 0.1;

ℝ t30=0.0;
ℝ δt30=0.0;

ℝ² coord30[nodes30], X30[nodes30], b30[nodes30], bt30[nodes30];
ℝ²ˣ² Ar30[nodes30], Mt30[nodes30];
ℝ² ur30[nodes30];
ℝ p_ic30[cells30], ρ_ic30[cells30], V_ic30[cells30];
ℝ c30[cells30], m30[cells30], p30[cells30], ρ30[cells30], e30[cells30], E30[cells30], V30[cells30];
ℝ δtj30[cells30];
ℝ² uj30[cells30], center30[cells30];
ℝ l30[cells30, nodesOfCell30];
ℝ² C_ic30[cells30, nodesOfCell30], C30[cells30, nodesOfCell30], F30[cells30, nodesOfCell30];
ℝ²ˣ² Ajr30[cells30, nodesOfCell30];


// Options obligatoires pour générer
const ℝ LENGTH31 = 0.01;
const ℕ X_EDGE_ELEMS31 = 100;
const ℕ Y_EDGE_ELEMS31 = 10;
const ℕ Z_EDGE_ELEMS31 = 1;
const ℝ option_stoptime31 = 0.2;
const ℕ option_max_iterations31 = 20000;

// Autres options
const ℝ γ31 = 1.4;
const ℝ option_x_interface31 = 0.5;
const ℝ option_δt_ini31 = 1.0e-5;
const ℝ option_δt_cfl31 = 0.4;
const ℝ option_ρ_ini_zg31 = 1.0;
const ℝ option_ρ_ini_zd31 = 0.125;
const ℝ option_p_ini_zg31 = 1.0;
const ℝ option_p_ini_zd31 = 0.1;

ℝ t31=0.0;
ℝ δt31=0.0;

ℝ² coord31[nodes31], X31[nodes31], b31[nodes31], bt31[nodes31];
ℝ²ˣ² Ar31[nodes31], Mt31[nodes31];
ℝ² ur31[nodes31];
ℝ p_ic31[cells31], ρ_ic31[cells31], V_ic31[cells31];
ℝ c31[cells31], m31[cells31], p31[cells31], ρ31[cells31], e31[cells31], E31[cells31], V31[cells31];
ℝ δtj31[cells31];
ℝ² uj31[cells31], center31[cells31];
ℝ l31[cells31, nodesOfCell31];
ℝ² C_ic31[cells31, nodesOfCell31], C31[cells31, nodesOfCell31], F31[cells31, nodesOfCell31];
ℝ²ˣ² Ajr31[cells31, nodesOfCell31];


// Options obligatoires pour générer
const ℝ LENGTH32 = 0.01;
const ℕ X_EDGE_ELEMS32 = 100;
const ℕ Y_EDGE_ELEMS32 = 10;
const ℕ Z_EDGE_ELEMS32 = 1;
const ℝ option_stoptime32 = 0.2;
const ℕ option_max_iterations32 = 20000;

// Autres options
const ℝ γ32 = 1.4;
const ℝ option_x_interface32 = 0.5;
const ℝ option_δt_ini32 = 1.0e-5;
const ℝ option_δt_cfl32 = 0.4;
const ℝ option_ρ_ini_zg32 = 1.0;
const ℝ option_ρ_ini_zd32 = 0.125;
const ℝ option_p_ini_zg32 = 1.0;
const ℝ option_p_ini_zd32 = 0.1;

ℝ t32=0.0;
ℝ δt32=0.0;

ℝ² coord32[nodes32], X32[nodes32], b32[nodes32], bt32[nodes32];
ℝ²ˣ² Ar32[nodes32], Mt32[nodes32];
ℝ² ur32[nodes32];
ℝ p_ic32[cells32], ρ_ic32[cells32], V_ic32[cells32];
ℝ c32[cells32], m32[cells32], p32[cells32], ρ32[cells32], e32[cells32], E32[cells32], V32[cells32];
ℝ δtj32[cells32];
ℝ² uj32[cells32], center32[cells32];
ℝ l32[cells32, nodesOfCell32];
ℝ² C_ic32[cells32, nodesOfCell32], C32[cells32, nodesOfCell32], F32[cells32, nodesOfCell32];
ℝ²ˣ² Ajr32[cells32, nodesOfCell32];


// Options obligatoires pour générer
const ℝ LENGTH33 = 0.01;
const ℕ X_EDGE_ELEMS33 = 100;
const ℕ Y_EDGE_ELEMS33 = 10;
const ℕ Z_EDGE_ELEMS33 = 1;
const ℝ option_stoptime33 = 0.2;
const ℕ option_max_iterations33 = 20000;

// Autres options
const ℝ γ33 = 1.4;
const ℝ option_x_interface33 = 0.5;
const ℝ option_δt_ini33 = 1.0e-5;
const ℝ option_δt_cfl33 = 0.4;
const ℝ option_ρ_ini_zg33 = 1.0;
const ℝ option_ρ_ini_zd33 = 0.125;
const ℝ option_p_ini_zg33 = 1.0;
const ℝ option_p_ini_zd33 = 0.1;

ℝ t33=0.0;
ℝ δt33=0.0;

ℝ² coord33[nodes33], X33[nodes33], b33[nodes33], bt33[nodes33];
ℝ²ˣ² Ar33[nodes33], Mt33[nodes33];
ℝ² ur33[nodes33];
ℝ p_ic33[cells33], ρ_ic33[cells33], V_ic33[cells33];
ℝ c33[cells33], m33[cells33], p33[cells33], ρ33[cells33], e33[cells33], E33[cells33], V33[cells33];
ℝ δtj33[cells33];
ℝ² uj33[cells33], center33[cells33];
ℝ l33[cells33, nodesOfCell33];
ℝ² C_ic33[cells33, nodesOfCell33], C33[cells33, nodesOfCell33], F33[cells33, nodesOfCell33];
ℝ²ˣ² Ajr33[cells33, nodesOfCell33];


// Options obligatoires pour générer
const ℝ LENGTH34 = 0.01;
const ℕ X_EDGE_ELEMS34 = 100;
const ℕ Y_EDGE_ELEMS34 = 10;
const ℕ Z_EDGE_ELEMS34 = 1;
const ℝ option_stoptime34 = 0.2;
const ℕ option_max_iterations34 = 20000;

// Autres options
const ℝ γ34 = 1.4;
const ℝ option_x_interface34 = 0.5;
const ℝ option_δt_ini34 = 1.0e-5;
const ℝ option_δt_cfl34 = 0.4;
const ℝ option_ρ_ini_zg34 = 1.0;
const ℝ option_ρ_ini_zd34 = 0.125;
const ℝ option_p_ini_zg34 = 1.0;
const ℝ option_p_ini_zd34 = 0.1;

ℝ t34=0.0;
ℝ δt34=0.0;

ℝ² coord34[nodes34], X34[nodes34], b34[nodes34], bt34[nodes34];
ℝ²ˣ² Ar34[nodes34], Mt34[nodes34];
ℝ² ur34[nodes34];
ℝ p_ic34[cells34], ρ_ic34[cells34], V_ic34[cells34];
ℝ c34[cells34], m34[cells34], p34[cells34], ρ34[cells34], e34[cells34], E34[cells34], V34[cells34];
ℝ δtj34[cells34];
ℝ² uj34[cells34], center34[cells34];
ℝ l34[cells34, nodesOfCell34];
ℝ² C_ic34[cells34, nodesOfCell34], C34[cells34, nodesOfCell34], F34[cells34, nodesOfCell34];
ℝ²ˣ² Ajr34[cells34, nodesOfCell34];


// Options obligatoires pour générer
const ℝ LENGTH35 = 0.01;
const ℕ X_EDGE_ELEMS35 = 100;
const ℕ Y_EDGE_ELEMS35 = 10;
const ℕ Z_EDGE_ELEMS35 = 1;
const ℝ option_stoptime35 = 0.2;
const ℕ option_max_iterations35 = 20000;

// Autres options
const ℝ γ35 = 1.4;
const ℝ option_x_interface35 = 0.5;
const ℝ option_δt_ini35 = 1.0e-5;
const ℝ option_δt_cfl35 = 0.4;
const ℝ option_ρ_ini_zg35 = 1.0;
const ℝ option_ρ_ini_zd35 = 0.125;
const ℝ option_p_ini_zg35 = 1.0;
const ℝ option_p_ini_zd35 = 0.1;

ℝ t35=0.0;
ℝ δt35=0.0;

ℝ² coord35[nodes35], X35[nodes35], b35[nodes35], bt35[nodes35];
ℝ²ˣ² Ar35[nodes35], Mt35[nodes35];
ℝ² ur35[nodes35];
ℝ p_ic35[cells35], ρ_ic35[cells35], V_ic35[cells35];
ℝ c35[cells35], m35[cells35], p35[cells35], ρ35[cells35], e35[cells35], E35[cells35], V35[cells35];
ℝ δtj35[cells35];
ℝ² uj35[cells35], center35[cells35];
ℝ l35[cells35, nodesOfCell35];
ℝ² C_ic35[cells35, nodesOfCell35], C35[cells35, nodesOfCell35], F35[cells35, nodesOfCell35];
ℝ²ˣ² Ajr35[cells35, nodesOfCell35];


// Options obligatoires pour générer
const ℝ LENGTH36 = 0.01;
const ℕ X_EDGE_ELEMS36 = 100;
const ℕ Y_EDGE_ELEMS36 = 10;
const ℕ Z_EDGE_ELEMS36 = 1;
const ℝ option_stoptime36 = 0.2;
const ℕ option_max_iterations36 = 20000;

// Autres options
const ℝ γ36 = 1.4;
const ℝ option_x_interface36 = 0.5;
const ℝ option_δt_ini36 = 1.0e-5;
const ℝ option_δt_cfl36 = 0.4;
const ℝ option_ρ_ini_zg36 = 1.0;
const ℝ option_ρ_ini_zd36 = 0.125;
const ℝ option_p_ini_zg36 = 1.0;
const ℝ option_p_ini_zd36 = 0.1;

ℝ t36=0.0;
ℝ δt36=0.0;

ℝ² coord36[nodes36], X36[nodes36], b36[nodes36], bt36[nodes36];
ℝ²ˣ² Ar36[nodes36], Mt36[nodes36];
ℝ² ur36[nodes36];
ℝ p_ic36[cells36], ρ_ic36[cells36], V_ic36[cells36];
ℝ c36[cells36], m36[cells36], p36[cells36], ρ36[cells36], e36[cells36], E36[cells36], V36[cells36];
ℝ δtj36[cells36];
ℝ² uj36[cells36], center36[cells36];
ℝ l36[cells36, nodesOfCell36];
ℝ² C_ic36[cells36, nodesOfCell36], C36[cells36, nodesOfCell36], F36[cells36, nodesOfCell36];
ℝ²ˣ² Ajr36[cells36, nodesOfCell36];


// Options obligatoires pour générer
const ℝ LENGTH37 = 0.01;
const ℕ X_EDGE_ELEMS37 = 100;
const ℕ Y_EDGE_ELEMS37 = 10;
const ℕ Z_EDGE_ELEMS37 = 1;
const ℝ option_stoptime37 = 0.2;
const ℕ option_max_iterations37 = 20000;

// Autres options
const ℝ γ37 = 1.4;
const ℝ option_x_interface37 = 0.5;
const ℝ option_δt_ini37 = 1.0e-5;
const ℝ option_δt_cfl37 = 0.4;
const ℝ option_ρ_ini_zg37 = 1.0;
const ℝ option_ρ_ini_zd37 = 0.125;
const ℝ option_p_ini_zg37 = 1.0;
const ℝ option_p_ini_zd37 = 0.1;

ℝ t37=0.0;
ℝ δt37=0.0;

ℝ² coord37[nodes37], X37[nodes37], b37[nodes37], bt37[nodes37];
ℝ²ˣ² Ar37[nodes37], Mt37[nodes37];
ℝ² ur37[nodes37];
ℝ p_ic37[cells37], ρ_ic37[cells37], V_ic37[cells37];
ℝ c37[cells37], m37[cells37], p37[cells37], ρ37[cells37], e37[cells37], E37[cells37], V37[cells37];
ℝ δtj37[cells37];
ℝ² uj37[cells37], center37[cells37];
ℝ l37[cells37, nodesOfCell37];
ℝ² C_ic37[cells37, nodesOfCell37], C37[cells37, nodesOfCell37], F37[cells37, nodesOfCell37];
ℝ²ˣ² Ajr37[cells37, nodesOfCell37];


// Options obligatoires pour générer
const ℝ LENGTH38 = 0.01;
const ℕ X_EDGE_ELEMS38 = 100;
const ℕ Y_EDGE_ELEMS38 = 10;
const ℕ Z_EDGE_ELEMS38 = 1;
const ℝ option_stoptime38 = 0.2;
const ℕ option_max_iterations38 = 20000;

// Autres options
const ℝ γ38 = 1.4;
const ℝ option_x_interface38 = 0.5;
const ℝ option_δt_ini38 = 1.0e-5;
const ℝ option_δt_cfl38 = 0.4;
const ℝ option_ρ_ini_zg38 = 1.0;
const ℝ option_ρ_ini_zd38 = 0.125;
const ℝ option_p_ini_zg38 = 1.0;
const ℝ option_p_ini_zd38 = 0.1;

ℝ t38=0.0;
ℝ δt38=0.0;

ℝ² coord38[nodes38], X38[nodes38], b38[nodes38], bt38[nodes38];
ℝ²ˣ² Ar38[nodes38], Mt38[nodes38];
ℝ² ur38[nodes38];
ℝ p_ic38[cells38], ρ_ic38[cells38], V_ic38[cells38];
ℝ c38[cells38], m38[cells38], p38[cells38], ρ38[cells38], e38[cells38], E38[cells38], V38[cells38];
ℝ δtj38[cells38];
ℝ² uj38[cells38], center38[cells38];
ℝ l38[cells38, nodesOfCell38];
ℝ² C_ic38[cells38, nodesOfCell38], C38[cells38, nodesOfCell38], F38[cells38, nodesOfCell38];
ℝ²ˣ² Ajr38[cells38, nodesOfCell38];


// Options obligatoires pour générer
const ℝ LENGTH39 = 0.01;
const ℕ X_EDGE_ELEMS39 = 100;
const ℕ Y_EDGE_ELEMS39 = 10;
const ℕ Z_EDGE_ELEMS39 = 1;
const ℝ option_stoptime39 = 0.2;
const ℕ option_max_iterations39 = 20000;

// Autres options
const ℝ γ39 = 1.4;
const ℝ option_x_interface39 = 0.5;
const ℝ option_δt_ini39 = 1.0e-5;
const ℝ option_δt_cfl39 = 0.4;
const ℝ option_ρ_ini_zg39 = 1.0;
const ℝ option_ρ_ini_zd39 = 0.125;
const ℝ option_p_ini_zg39 = 1.0;
const ℝ option_p_ini_zd39 = 0.1;

ℝ t39=0.0;
ℝ δt39=0.0;

ℝ² coord39[nodes39], X39[nodes39], b39[nodes39], bt39[nodes39];
ℝ²ˣ² Ar39[nodes39], Mt39[nodes39];
ℝ² ur39[nodes39];
ℝ p_ic39[cells39], ρ_ic39[cells39], V_ic39[cells39];
ℝ c39[cells39], m39[cells39], p39[cells39], ρ39[cells39], e39[cells39], E39[cells39], V39[cells39];
ℝ δtj39[cells39];
ℝ² uj39[cells39], center39[cells39];
ℝ l39[cells39, nodesOfCell39];
ℝ² C_ic39[cells39, nodesOfCell39], C39[cells39, nodesOfCell39], F39[cells39, nodesOfCell39];
ℝ²ˣ² Ajr39[cells39, nodesOfCell39];


// Options obligatoires pour générer
const ℝ LENGTH40 = 0.01;
const ℕ X_EDGE_ELEMS40 = 100;
const ℕ Y_EDGE_ELEMS40 = 10;
const ℕ Z_EDGE_ELEMS40 = 1;
const ℝ option_stoptime40 = 0.2;
const ℕ option_max_iterations40 = 20000;

// Autres options
const ℝ γ40 = 1.4;
const ℝ option_x_interface40 = 0.5;
const ℝ option_δt_ini40 = 1.0e-5;
const ℝ option_δt_cfl40 = 0.4;
const ℝ option_ρ_ini_zg40 = 1.0;
const ℝ option_ρ_ini_zd40 = 0.125;
const ℝ option_p_ini_zg40 = 1.0;
const ℝ option_p_ini_zd40 = 0.1;

ℝ t40=0.0;
ℝ δt40=0.0;

ℝ² coord40[nodes40], X40[nodes40], b40[nodes40], bt40[nodes40];
ℝ²ˣ² Ar40[nodes40], Mt40[nodes40];
ℝ² ur40[nodes40];
ℝ p_ic40[cells40], ρ_ic40[cells40], V_ic40[cells40];
ℝ c40[cells40], m40[cells40], p40[cells40], ρ40[cells40], e40[cells40], E40[cells40], V40[cells40];
ℝ δtj40[cells40];
ℝ² uj40[cells40], center40[cells40];
ℝ l40[cells40, nodesOfCell40];
ℝ² C_ic40[cells40, nodesOfCell40], C40[cells40, nodesOfCell40], F40[cells40, nodesOfCell40];
ℝ²ˣ² Ajr40[cells40, nodesOfCell40];


// Options obligatoires pour générer
const ℝ LENGTH41 = 0.01;
const ℕ X_EDGE_ELEMS41 = 100;
const ℕ Y_EDGE_ELEMS41 = 10;
const ℕ Z_EDGE_ELEMS41 = 1;
const ℝ option_stoptime41 = 0.2;
const ℕ option_max_iterations41 = 20000;

// Autres options
const ℝ γ41 = 1.4;
const ℝ option_x_interface41 = 0.5;
const ℝ option_δt_ini41 = 1.0e-5;
const ℝ option_δt_cfl41 = 0.4;
const ℝ option_ρ_ini_zg41 = 1.0;
const ℝ option_ρ_ini_zd41 = 0.125;
const ℝ option_p_ini_zg41 = 1.0;
const ℝ option_p_ini_zd41 = 0.1;

ℝ t41=0.0;
ℝ δt41=0.0;

ℝ² coord41[nodes41], X41[nodes41], b41[nodes41], bt41[nodes41];
ℝ²ˣ² Ar41[nodes41], Mt41[nodes41];
ℝ² ur41[nodes41];
ℝ p_ic41[cells41], ρ_ic41[cells41], V_ic41[cells41];
ℝ c41[cells41], m41[cells41], p41[cells41], ρ41[cells41], e41[cells41], E41[cells41], V41[cells41];
ℝ δtj41[cells41];
ℝ² uj41[cells41], center41[cells41];
ℝ l41[cells41, nodesOfCell41];
ℝ² C_ic41[cells41, nodesOfCell41], C41[cells41, nodesOfCell41], F41[cells41, nodesOfCell41];
ℝ²ˣ² Ajr41[cells41, nodesOfCell41];


// Options obligatoires pour générer
const ℝ LENGTH42 = 0.01;
const ℕ X_EDGE_ELEMS42 = 100;
const ℕ Y_EDGE_ELEMS42 = 10;
const ℕ Z_EDGE_ELEMS42 = 1;
const ℝ option_stoptime42 = 0.2;
const ℕ option_max_iterations42 = 20000;

// Autres options
const ℝ γ42 = 1.4;
const ℝ option_x_interface42 = 0.5;
const ℝ option_δt_ini42 = 1.0e-5;
const ℝ option_δt_cfl42 = 0.4;
const ℝ option_ρ_ini_zg42 = 1.0;
const ℝ option_ρ_ini_zd42 = 0.125;
const ℝ option_p_ini_zg42 = 1.0;
const ℝ option_p_ini_zd42 = 0.1;

ℝ t42=0.0;
ℝ δt42=0.0;

ℝ² coord42[nodes42], X42[nodes42], b42[nodes42], bt42[nodes42];
ℝ²ˣ² Ar42[nodes42], Mt42[nodes42];
ℝ² ur42[nodes42];
ℝ p_ic42[cells42], ρ_ic42[cells42], V_ic42[cells42];
ℝ c42[cells42], m42[cells42], p42[cells42], ρ42[cells42], e42[cells42], E42[cells42], V42[cells42];
ℝ δtj42[cells42];
ℝ² uj42[cells42], center42[cells42];
ℝ l42[cells42, nodesOfCell42];
ℝ² C_ic42[cells42, nodesOfCell42], C42[cells42, nodesOfCell42], F42[cells42, nodesOfCell42];
ℝ²ˣ² Ajr42[cells42, nodesOfCell42];


// Options obligatoires pour générer
const ℝ LENGTH43 = 0.01;
const ℕ X_EDGE_ELEMS43 = 100;
const ℕ Y_EDGE_ELEMS43 = 10;
const ℕ Z_EDGE_ELEMS43 = 1;
const ℝ option_stoptime43 = 0.2;
const ℕ option_max_iterations43 = 20000;

// Autres options
const ℝ γ43 = 1.4;
const ℝ option_x_interface43 = 0.5;
const ℝ option_δt_ini43 = 1.0e-5;
const ℝ option_δt_cfl43 = 0.4;
const ℝ option_ρ_ini_zg43 = 1.0;
const ℝ option_ρ_ini_zd43 = 0.125;
const ℝ option_p_ini_zg43 = 1.0;
const ℝ option_p_ini_zd43 = 0.1;

ℝ t43=0.0;
ℝ δt43=0.0;

ℝ² coord43[nodes43], X43[nodes43], b43[nodes43], bt43[nodes43];
ℝ²ˣ² Ar43[nodes43], Mt43[nodes43];
ℝ² ur43[nodes43];
ℝ p_ic43[cells43], ρ_ic43[cells43], V_ic43[cells43];
ℝ c43[cells43], m43[cells43], p43[cells43], ρ43[cells43], e43[cells43], E43[cells43], V43[cells43];
ℝ δtj43[cells43];
ℝ² uj43[cells43], center43[cells43];
ℝ l43[cells43, nodesOfCell43];
ℝ² C_ic43[cells43, nodesOfCell43], C43[cells43, nodesOfCell43], F43[cells43, nodesOfCell43];
ℝ²ˣ² Ajr43[cells43, nodesOfCell43];


// Options obligatoires pour générer
const ℝ LENGTH44 = 0.01;
const ℕ X_EDGE_ELEMS44 = 100;
const ℕ Y_EDGE_ELEMS44 = 10;
const ℕ Z_EDGE_ELEMS44 = 1;
const ℝ option_stoptime44 = 0.2;
const ℕ option_max_iterations44 = 20000;

// Autres options
const ℝ γ44 = 1.4;
const ℝ option_x_interface44 = 0.5;
const ℝ option_δt_ini44 = 1.0e-5;
const ℝ option_δt_cfl44 = 0.4;
const ℝ option_ρ_ini_zg44 = 1.0;
const ℝ option_ρ_ini_zd44 = 0.125;
const ℝ option_p_ini_zg44 = 1.0;
const ℝ option_p_ini_zd44 = 0.1;

ℝ t44=0.0;
ℝ δt44=0.0;

ℝ² coord44[nodes44], X44[nodes44], b44[nodes44], bt44[nodes44];
ℝ²ˣ² Ar44[nodes44], Mt44[nodes44];
ℝ² ur44[nodes44];
ℝ p_ic44[cells44], ρ_ic44[cells44], V_ic44[cells44];
ℝ c44[cells44], m44[cells44], p44[cells44], ρ44[cells44], e44[cells44], E44[cells44], V44[cells44];
ℝ δtj44[cells44];
ℝ² uj44[cells44], center44[cells44];
ℝ l44[cells44, nodesOfCell44];
ℝ² C_ic44[cells44, nodesOfCell44], C44[cells44, nodesOfCell44], F44[cells44, nodesOfCell44];
ℝ²ˣ² Ajr44[cells44, nodesOfCell44];


// Options obligatoires pour générer
const ℝ LENGTH45 = 0.01;
const ℕ X_EDGE_ELEMS45 = 100;
const ℕ Y_EDGE_ELEMS45 = 10;
const ℕ Z_EDGE_ELEMS45 = 1;
const ℝ option_stoptime45 = 0.2;
const ℕ option_max_iterations45 = 20000;

// Autres options
const ℝ γ45 = 1.4;
const ℝ option_x_interface45 = 0.5;
const ℝ option_δt_ini45 = 1.0e-5;
const ℝ option_δt_cfl45 = 0.4;
const ℝ option_ρ_ini_zg45 = 1.0;
const ℝ option_ρ_ini_zd45 = 0.125;
const ℝ option_p_ini_zg45 = 1.0;
const ℝ option_p_ini_zd45 = 0.1;

ℝ t45=0.0;
ℝ δt45=0.0;

ℝ² coord45[nodes45], X45[nodes45], b45[nodes45], bt45[nodes45];
ℝ²ˣ² Ar45[nodes45], Mt45[nodes45];
ℝ² ur45[nodes45];
ℝ p_ic45[cells45], ρ_ic45[cells45], V_ic45[cells45];
ℝ c45[cells45], m45[cells45], p45[cells45], ρ45[cells45], e45[cells45], E45[cells45], V45[cells45];
ℝ δtj45[cells45];
ℝ² uj45[cells45], center45[cells45];
ℝ l45[cells45, nodesOfCell45];
ℝ² C_ic45[cells45, nodesOfCell45], C45[cells45, nodesOfCell45], F45[cells45, nodesOfCell45];
ℝ²ˣ² Ajr45[cells45, nodesOfCell45];


// Options obligatoires pour générer
const ℝ LENGTH46 = 0.01;
const ℕ X_EDGE_ELEMS46 = 100;
const ℕ Y_EDGE_ELEMS46 = 10;
const ℕ Z_EDGE_ELEMS46 = 1;
const ℝ option_stoptime46 = 0.2;
const ℕ option_max_iterations46 = 20000;

// Autres options
const ℝ γ46 = 1.4;
const ℝ option_x_interface46 = 0.5;
const ℝ option_δt_ini46 = 1.0e-5;
const ℝ option_δt_cfl46 = 0.4;
const ℝ option_ρ_ini_zg46 = 1.0;
const ℝ option_ρ_ini_zd46 = 0.125;
const ℝ option_p_ini_zg46 = 1.0;
const ℝ option_p_ini_zd46 = 0.1;

ℝ t46=0.0;
ℝ δt46=0.0;

ℝ² coord46[nodes46], X46[nodes46], b46[nodes46], bt46[nodes46];
ℝ²ˣ² Ar46[nodes46], Mt46[nodes46];
ℝ² ur46[nodes46];
ℝ p_ic46[cells46], ρ_ic46[cells46], V_ic46[cells46];
ℝ c46[cells46], m46[cells46], p46[cells46], ρ46[cells46], e46[cells46], E46[cells46], V46[cells46];
ℝ δtj46[cells46];
ℝ² uj46[cells46], center46[cells46];
ℝ l46[cells46, nodesOfCell46];
ℝ² C_ic46[cells46, nodesOfCell46], C46[cells46, nodesOfCell46], F46[cells46, nodesOfCell46];
ℝ²ˣ² Ajr46[cells46, nodesOfCell46];


// Options obligatoires pour générer
const ℝ LENGTH47 = 0.01;
const ℕ X_EDGE_ELEMS47 = 100;
const ℕ Y_EDGE_ELEMS47 = 10;
const ℕ Z_EDGE_ELEMS47 = 1;
const ℝ option_stoptime47 = 0.2;
const ℕ option_max_iterations47 = 20000;

// Autres options
const ℝ γ47 = 1.4;
const ℝ option_x_interface47 = 0.5;
const ℝ option_δt_ini47 = 1.0e-5;
const ℝ option_δt_cfl47 = 0.4;
const ℝ option_ρ_ini_zg47 = 1.0;
const ℝ option_ρ_ini_zd47 = 0.125;
const ℝ option_p_ini_zg47 = 1.0;
const ℝ option_p_ini_zd47 = 0.1;

ℝ t47=0.0;
ℝ δt47=0.0;

ℝ² coord47[nodes47], X47[nodes47], b47[nodes47], bt47[nodes47];
ℝ²ˣ² Ar47[nodes47], Mt47[nodes47];
ℝ² ur47[nodes47];
ℝ p_ic47[cells47], ρ_ic47[cells47], V_ic47[cells47];
ℝ c47[cells47], m47[cells47], p47[cells47], ρ47[cells47], e47[cells47], E47[cells47], V47[cells47];
ℝ δtj47[cells47];
ℝ² uj47[cells47], center47[cells47];
ℝ l47[cells47, nodesOfCell47];
ℝ² C_ic47[cells47, nodesOfCell47], C47[cells47, nodesOfCell47], F47[cells47, nodesOfCell47];
ℝ²ˣ² Ajr47[cells47, nodesOfCell47];


// Options obligatoires pour générer
const ℝ LENGTH48 = 0.01;
const ℕ X_EDGE_ELEMS48 = 100;
const ℕ Y_EDGE_ELEMS48 = 10;
const ℕ Z_EDGE_ELEMS48 = 1;
const ℝ option_stoptime48 = 0.2;
const ℕ option_max_iterations48 = 20000;

// Autres options
const ℝ γ48 = 1.4;
const ℝ option_x_interface48 = 0.5;
const ℝ option_δt_ini48 = 1.0e-5;
const ℝ option_δt_cfl48 = 0.4;
const ℝ option_ρ_ini_zg48 = 1.0;
const ℝ option_ρ_ini_zd48 = 0.125;
const ℝ option_p_ini_zg48 = 1.0;
const ℝ option_p_ini_zd48 = 0.1;

ℝ t48=0.0;
ℝ δt48=0.0;

ℝ² coord48[nodes48], X48[nodes48], b48[nodes48], bt48[nodes48];
ℝ²ˣ² Ar48[nodes48], Mt48[nodes48];
ℝ² ur48[nodes48];
ℝ p_ic48[cells48], ρ_ic48[cells48], V_ic48[cells48];
ℝ c48[cells48], m48[cells48], p48[cells48], ρ48[cells48], e48[cells48], E48[cells48], V48[cells48];
ℝ δtj48[cells48];
ℝ² uj48[cells48], center48[cells48];
ℝ l48[cells48, nodesOfCell48];
ℝ² C_ic48[cells48, nodesOfCell48], C48[cells48, nodesOfCell48], F48[cells48, nodesOfCell48];
ℝ²ˣ² Ajr48[cells48, nodesOfCell48];


// Options obligatoires pour générer
const ℝ LENGTH49 = 0.01;
const ℕ X_EDGE_ELEMS49 = 100;
const ℕ Y_EDGE_ELEMS49 = 10;
const ℕ Z_EDGE_ELEMS49 = 1;
const ℝ option_stoptime49 = 0.2;
const ℕ option_max_iterations49 = 20000;

// Autres options
const ℝ γ49 = 1.4;
const ℝ option_x_interface49 = 0.5;
const ℝ option_δt_ini49 = 1.0e-5;
const ℝ option_δt_cfl49 = 0.4;
const ℝ option_ρ_ini_zg49 = 1.0;
const ℝ option_ρ_ini_zd49 = 0.125;
const ℝ option_p_ini_zg49 = 1.0;
const ℝ option_p_ini_zd49 = 0.1;

ℝ t49=0.0;
ℝ δt49=0.0;

ℝ² coord49[nodes49], X49[nodes49], b49[nodes49], bt49[nodes49];
ℝ²ˣ² Ar49[nodes49], Mt49[nodes49];
ℝ² ur49[nodes49];
ℝ p_ic49[cells49], ρ_ic49[cells49], V_ic49[cells49];
ℝ c49[cells49], m49[cells49], p49[cells49], ρ49[cells49], e49[cells49], E49[cells49], V49[cells49];
ℝ δtj49[cells49];
ℝ² uj49[cells49], center49[cells49];
ℝ l49[cells49, nodesOfCell49];
ℝ² C_ic49[cells49, nodesOfCell49], C49[cells49, nodesOfCell49], F49[cells49, nodesOfCell49];
ℝ²ˣ² Ajr49[cells49, nodesOfCell49];


// Options obligatoires pour générer
const ℝ LENGTH50 = 0.01;
const ℕ X_EDGE_ELEMS50 = 100;
const ℕ Y_EDGE_ELEMS50 = 10;
const ℕ Z_EDGE_ELEMS50 = 1;
const ℝ option_stoptime50 = 0.2;
const ℕ option_max_iterations50 = 20000;

// Autres options
const ℝ γ50 = 1.4;
const ℝ option_x_interface50 = 0.5;
const ℝ option_δt_ini50 = 1.0e-5;
const ℝ option_δt_cfl50 = 0.4;
const ℝ option_ρ_ini_zg50 = 1.0;
const ℝ option_ρ_ini_zd50 = 0.125;
const ℝ option_p_ini_zg50 = 1.0;
const ℝ option_p_ini_zd50 = 0.1;

ℝ t50=0.0;
ℝ δt50=0.0;

ℝ² coord50[nodes50], X50[nodes50], b50[nodes50], bt50[nodes50];
ℝ²ˣ² Ar50[nodes50], Mt50[nodes50];
ℝ² ur50[nodes50];
ℝ p_ic50[cells50], ρ_ic50[cells50], V_ic50[cells50];
ℝ c50[cells50], m50[cells50], p50[cells50], ρ50[cells50], e50[cells50], E50[cells50], V50[cells50];
ℝ δtj50[cells50];
ℝ² uj50[cells50], center50[cells50];
ℝ l50[cells50, nodesOfCell50];
ℝ² C_ic50[cells50, nodesOfCell50], C50[cells50, nodesOfCell50], F50[cells50, nodesOfCell50];
ℝ²ˣ² Ajr50[cells50, nodesOfCell50];


// Options obligatoires pour générer
const ℝ LENGTH51 = 0.01;
const ℕ X_EDGE_ELEMS51 = 100;
const ℕ Y_EDGE_ELEMS51 = 10;
const ℕ Z_EDGE_ELEMS51 = 1;
const ℝ option_stoptime51 = 0.2;
const ℕ option_max_iterations51 = 20000;

// Autres options
const ℝ γ51 = 1.4;
const ℝ option_x_interface51 = 0.5;
const ℝ option_δt_ini51 = 1.0e-5;
const ℝ option_δt_cfl51 = 0.4;
const ℝ option_ρ_ini_zg51 = 1.0;
const ℝ option_ρ_ini_zd51 = 0.125;
const ℝ option_p_ini_zg51 = 1.0;
const ℝ option_p_ini_zd51 = 0.1;

ℝ t51=0.0;
ℝ δt51=0.0;

ℝ² coord51[nodes51], X51[nodes51], b51[nodes51], bt51[nodes51];
ℝ²ˣ² Ar51[nodes51], Mt51[nodes51];
ℝ² ur51[nodes51];
ℝ p_ic51[cells51], ρ_ic51[cells51], V_ic51[cells51];
ℝ c51[cells51], m51[cells51], p51[cells51], ρ51[cells51], e51[cells51], E51[cells51], V51[cells51];
ℝ δtj51[cells51];
ℝ² uj51[cells51], center51[cells51];
ℝ l51[cells51, nodesOfCell51];
ℝ² C_ic51[cells51, nodesOfCell51], C51[cells51, nodesOfCell51], F51[cells51, nodesOfCell51];
ℝ²ˣ² Ajr51[cells51, nodesOfCell51];


// Options obligatoires pour générer
const ℝ LENGTH52 = 0.01;
const ℕ X_EDGE_ELEMS52 = 100;
const ℕ Y_EDGE_ELEMS52 = 10;
const ℕ Z_EDGE_ELEMS52 = 1;
const ℝ option_stoptime52 = 0.2;
const ℕ option_max_iterations52 = 20000;

// Autres options
const ℝ γ52 = 1.4;
const ℝ option_x_interface52 = 0.5;
const ℝ option_δt_ini52 = 1.0e-5;
const ℝ option_δt_cfl52 = 0.4;
const ℝ option_ρ_ini_zg52 = 1.0;
const ℝ option_ρ_ini_zd52 = 0.125;
const ℝ option_p_ini_zg52 = 1.0;
const ℝ option_p_ini_zd52 = 0.1;

ℝ t52=0.0;
ℝ δt52=0.0;

ℝ² coord52[nodes52], X52[nodes52], b52[nodes52], bt52[nodes52];
ℝ²ˣ² Ar52[nodes52], Mt52[nodes52];
ℝ² ur52[nodes52];
ℝ p_ic52[cells52], ρ_ic52[cells52], V_ic52[cells52];
ℝ c52[cells52], m52[cells52], p52[cells52], ρ52[cells52], e52[cells52], E52[cells52], V52[cells52];
ℝ δtj52[cells52];
ℝ² uj52[cells52], center52[cells52];
ℝ l52[cells52, nodesOfCell52];
ℝ² C_ic52[cells52, nodesOfCell52], C52[cells52, nodesOfCell52], F52[cells52, nodesOfCell52];
ℝ²ˣ² Ajr52[cells52, nodesOfCell52];


// Options obligatoires pour générer
const ℝ LENGTH53 = 0.01;
const ℕ X_EDGE_ELEMS53 = 100;
const ℕ Y_EDGE_ELEMS53 = 10;
const ℕ Z_EDGE_ELEMS53 = 1;
const ℝ option_stoptime53 = 0.2;
const ℕ option_max_iterations53 = 20000;

// Autres options
const ℝ γ53 = 1.4;
const ℝ option_x_interface53 = 0.5;
const ℝ option_δt_ini53 = 1.0e-5;
const ℝ option_δt_cfl53 = 0.4;
const ℝ option_ρ_ini_zg53 = 1.0;
const ℝ option_ρ_ini_zd53 = 0.125;
const ℝ option_p_ini_zg53 = 1.0;
const ℝ option_p_ini_zd53 = 0.1;

ℝ t53=0.0;
ℝ δt53=0.0;

ℝ² coord53[nodes53], X53[nodes53], b53[nodes53], bt53[nodes53];
ℝ²ˣ² Ar53[nodes53], Mt53[nodes53];
ℝ² ur53[nodes53];
ℝ p_ic53[cells53], ρ_ic53[cells53], V_ic53[cells53];
ℝ c53[cells53], m53[cells53], p53[cells53], ρ53[cells53], e53[cells53], E53[cells53], V53[cells53];
ℝ δtj53[cells53];
ℝ² uj53[cells53], center53[cells53];
ℝ l53[cells53, nodesOfCell53];
ℝ² C_ic53[cells53, nodesOfCell53], C53[cells53, nodesOfCell53], F53[cells53, nodesOfCell53];
ℝ²ˣ² Ajr53[cells53, nodesOfCell53];


// Options obligatoires pour générer
const ℝ LENGTH54 = 0.01;
const ℕ X_EDGE_ELEMS54 = 100;
const ℕ Y_EDGE_ELEMS54 = 10;
const ℕ Z_EDGE_ELEMS54 = 1;
const ℝ option_stoptime54 = 0.2;
const ℕ option_max_iterations54 = 20000;

// Autres options
const ℝ γ54 = 1.4;
const ℝ option_x_interface54 = 0.5;
const ℝ option_δt_ini54 = 1.0e-5;
const ℝ option_δt_cfl54 = 0.4;
const ℝ option_ρ_ini_zg54 = 1.0;
const ℝ option_ρ_ini_zd54 = 0.125;
const ℝ option_p_ini_zg54 = 1.0;
const ℝ option_p_ini_zd54 = 0.1;

ℝ t54=0.0;
ℝ δt54=0.0;

ℝ² coord54[nodes54], X54[nodes54], b54[nodes54], bt54[nodes54];
ℝ²ˣ² Ar54[nodes54], Mt54[nodes54];
ℝ² ur54[nodes54];
ℝ p_ic54[cells54], ρ_ic54[cells54], V_ic54[cells54];
ℝ c54[cells54], m54[cells54], p54[cells54], ρ54[cells54], e54[cells54], E54[cells54], V54[cells54];
ℝ δtj54[cells54];
ℝ² uj54[cells54], center54[cells54];
ℝ l54[cells54, nodesOfCell54];
ℝ² C_ic54[cells54, nodesOfCell54], C54[cells54, nodesOfCell54], F54[cells54, nodesOfCell54];
ℝ²ˣ² Ajr54[cells54, nodesOfCell54];


// Options obligatoires pour générer
const ℝ LENGTH55 = 0.01;
const ℕ X_EDGE_ELEMS55 = 100;
const ℕ Y_EDGE_ELEMS55 = 10;
const ℕ Z_EDGE_ELEMS55 = 1;
const ℝ option_stoptime55 = 0.2;
const ℕ option_max_iterations55 = 20000;

// Autres options
const ℝ γ55 = 1.4;
const ℝ option_x_interface55 = 0.5;
const ℝ option_δt_ini55 = 1.0e-5;
const ℝ option_δt_cfl55 = 0.4;
const ℝ option_ρ_ini_zg55 = 1.0;
const ℝ option_ρ_ini_zd55 = 0.125;
const ℝ option_p_ini_zg55 = 1.0;
const ℝ option_p_ini_zd55 = 0.1;

ℝ t55=0.0;
ℝ δt55=0.0;

ℝ² coord55[nodes55], X55[nodes55], b55[nodes55], bt55[nodes55];
ℝ²ˣ² Ar55[nodes55], Mt55[nodes55];
ℝ² ur55[nodes55];
ℝ p_ic55[cells55], ρ_ic55[cells55], V_ic55[cells55];
ℝ c55[cells55], m55[cells55], p55[cells55], ρ55[cells55], e55[cells55], E55[cells55], V55[cells55];
ℝ δtj55[cells55];
ℝ² uj55[cells55], center55[cells55];
ℝ l55[cells55, nodesOfCell55];
ℝ² C_ic55[cells55, nodesOfCell55], C55[cells55, nodesOfCell55], F55[cells55, nodesOfCell55];
ℝ²ˣ² Ajr55[cells55, nodesOfCell55];


// Options obligatoires pour générer
const ℝ LENGTH56 = 0.01;
const ℕ X_EDGE_ELEMS56 = 100;
const ℕ Y_EDGE_ELEMS56 = 10;
const ℕ Z_EDGE_ELEMS56 = 1;
const ℝ option_stoptime56 = 0.2;
const ℕ option_max_iterations56 = 20000;

// Autres options
const ℝ γ56 = 1.4;
const ℝ option_x_interface56 = 0.5;
const ℝ option_δt_ini56 = 1.0e-5;
const ℝ option_δt_cfl56 = 0.4;
const ℝ option_ρ_ini_zg56 = 1.0;
const ℝ option_ρ_ini_zd56 = 0.125;
const ℝ option_p_ini_zg56 = 1.0;
const ℝ option_p_ini_zd56 = 0.1;

ℝ t56=0.0;
ℝ δt56=0.0;

ℝ² coord56[nodes56], X56[nodes56], b56[nodes56], bt56[nodes56];
ℝ²ˣ² Ar56[nodes56], Mt56[nodes56];
ℝ² ur56[nodes56];
ℝ p_ic56[cells56], ρ_ic56[cells56], V_ic56[cells56];
ℝ c56[cells56], m56[cells56], p56[cells56], ρ56[cells56], e56[cells56], E56[cells56], V56[cells56];
ℝ δtj56[cells56];
ℝ² uj56[cells56], center56[cells56];
ℝ l56[cells56, nodesOfCell56];
ℝ² C_ic56[cells56, nodesOfCell56], C56[cells56, nodesOfCell56], F56[cells56, nodesOfCell56];
ℝ²ˣ² Ajr56[cells56, nodesOfCell56];


// Options obligatoires pour générer
const ℝ LENGTH57 = 0.01;
const ℕ X_EDGE_ELEMS57 = 100;
const ℕ Y_EDGE_ELEMS57 = 10;
const ℕ Z_EDGE_ELEMS57 = 1;
const ℝ option_stoptime57 = 0.2;
const ℕ option_max_iterations57 = 20000;

// Autres options
const ℝ γ57 = 1.4;
const ℝ option_x_interface57 = 0.5;
const ℝ option_δt_ini57 = 1.0e-5;
const ℝ option_δt_cfl57 = 0.4;
const ℝ option_ρ_ini_zg57 = 1.0;
const ℝ option_ρ_ini_zd57 = 0.125;
const ℝ option_p_ini_zg57 = 1.0;
const ℝ option_p_ini_zd57 = 0.1;

ℝ t57=0.0;
ℝ δt57=0.0;

ℝ² coord57[nodes57], X57[nodes57], b57[nodes57], bt57[nodes57];
ℝ²ˣ² Ar57[nodes57], Mt57[nodes57];
ℝ² ur57[nodes57];
ℝ p_ic57[cells57], ρ_ic57[cells57], V_ic57[cells57];
ℝ c57[cells57], m57[cells57], p57[cells57], ρ57[cells57], e57[cells57], E57[cells57], V57[cells57];
ℝ δtj57[cells57];
ℝ² uj57[cells57], center57[cells57];
ℝ l57[cells57, nodesOfCell57];
ℝ² C_ic57[cells57, nodesOfCell57], C57[cells57, nodesOfCell57], F57[cells57, nodesOfCell57];
ℝ²ˣ² Ajr57[cells57, nodesOfCell57];


// Options obligatoires pour générer
const ℝ LENGTH58 = 0.01;
const ℕ X_EDGE_ELEMS58 = 100;
const ℕ Y_EDGE_ELEMS58 = 10;
const ℕ Z_EDGE_ELEMS58 = 1;
const ℝ option_stoptime58 = 0.2;
const ℕ option_max_iterations58 = 20000;

// Autres options
const ℝ γ58 = 1.4;
const ℝ option_x_interface58 = 0.5;
const ℝ option_δt_ini58 = 1.0e-5;
const ℝ option_δt_cfl58 = 0.4;
const ℝ option_ρ_ini_zg58 = 1.0;
const ℝ option_ρ_ini_zd58 = 0.125;
const ℝ option_p_ini_zg58 = 1.0;
const ℝ option_p_ini_zd58 = 0.1;

ℝ t58=0.0;
ℝ δt58=0.0;

ℝ² coord58[nodes58], X58[nodes58], b58[nodes58], bt58[nodes58];
ℝ²ˣ² Ar58[nodes58], Mt58[nodes58];
ℝ² ur58[nodes58];
ℝ p_ic58[cells58], ρ_ic58[cells58], V_ic58[cells58];
ℝ c58[cells58], m58[cells58], p58[cells58], ρ58[cells58], e58[cells58], E58[cells58], V58[cells58];
ℝ δtj58[cells58];
ℝ² uj58[cells58], center58[cells58];
ℝ l58[cells58, nodesOfCell58];
ℝ² C_ic58[cells58, nodesOfCell58], C58[cells58, nodesOfCell58], F58[cells58, nodesOfCell58];
ℝ²ˣ² Ajr58[cells58, nodesOfCell58];


// Options obligatoires pour générer
const ℝ LENGTH59 = 0.01;
const ℕ X_EDGE_ELEMS59 = 100;
const ℕ Y_EDGE_ELEMS59 = 10;
const ℕ Z_EDGE_ELEMS59 = 1;
const ℝ option_stoptime59 = 0.2;
const ℕ option_max_iterations59 = 20000;

// Autres options
const ℝ γ59 = 1.4;
const ℝ option_x_interface59 = 0.5;
const ℝ option_δt_ini59 = 1.0e-5;
const ℝ option_δt_cfl59 = 0.4;
const ℝ option_ρ_ini_zg59 = 1.0;
const ℝ option_ρ_ini_zd59 = 0.125;
const ℝ option_p_ini_zg59 = 1.0;
const ℝ option_p_ini_zd59 = 0.1;

ℝ t59=0.0;
ℝ δt59=0.0;

ℝ² coord59[nodes59], X59[nodes59], b59[nodes59], bt59[nodes59];
ℝ²ˣ² Ar59[nodes59], Mt59[nodes59];
ℝ² ur59[nodes59];
ℝ p_ic59[cells59], ρ_ic59[cells59], V_ic59[cells59];
ℝ c59[cells59], m59[cells59], p59[cells59], ρ59[cells59], e59[cells59], E59[cells59], V59[cells59];
ℝ δtj59[cells59];
ℝ² uj59[cells59], center59[cells59];
ℝ l59[cells59, nodesOfCell59];
ℝ² C_ic59[cells59, nodesOfCell59], C59[cells59, nodesOfCell59], F59[cells59, nodesOfCell59];
ℝ²ˣ² Ajr59[cells59, nodesOfCell59];


// Options obligatoires pour générer
const ℝ LENGTH60 = 0.01;
const ℕ X_EDGE_ELEMS60 = 100;
const ℕ Y_EDGE_ELEMS60 = 10;
const ℕ Z_EDGE_ELEMS60 = 1;
const ℝ option_stoptime60 = 0.2;
const ℕ option_max_iterations60 = 20000;

// Autres options
const ℝ γ60 = 1.4;
const ℝ option_x_interface60 = 0.5;
const ℝ option_δt_ini60 = 1.0e-5;
const ℝ option_δt_cfl60 = 0.4;
const ℝ option_ρ_ini_zg60 = 1.0;
const ℝ option_ρ_ini_zd60 = 0.125;
const ℝ option_p_ini_zg60 = 1.0;
const ℝ option_p_ini_zd60 = 0.1;

ℝ t60=0.0;
ℝ δt60=0.0;

ℝ² coord60[nodes60], X60[nodes60], b60[nodes60], bt60[nodes60];
ℝ²ˣ² Ar60[nodes60], Mt60[nodes60];
ℝ² ur60[nodes60];
ℝ p_ic60[cells60], ρ_ic60[cells60], V_ic60[cells60];
ℝ c60[cells60], m60[cells60], p60[cells60], ρ60[cells60], e60[cells60], E60[cells60], V60[cells60];
ℝ δtj60[cells60];
ℝ² uj60[cells60], center60[cells60];
ℝ l60[cells60, nodesOfCell60];
ℝ² C_ic60[cells60, nodesOfCell60], C60[cells60, nodesOfCell60], F60[cells60, nodesOfCell60];
ℝ²ˣ² Ajr60[cells60, nodesOfCell60];


// Options obligatoires pour générer
const ℝ LENGTH61 = 0.01;
const ℕ X_EDGE_ELEMS61 = 100;
const ℕ Y_EDGE_ELEMS61 = 10;
const ℕ Z_EDGE_ELEMS61 = 1;
const ℝ option_stoptime61 = 0.2;
const ℕ option_max_iterations61 = 20000;

// Autres options
const ℝ γ61 = 1.4;
const ℝ option_x_interface61 = 0.5;
const ℝ option_δt_ini61 = 1.0e-5;
const ℝ option_δt_cfl61 = 0.4;
const ℝ option_ρ_ini_zg61 = 1.0;
const ℝ option_ρ_ini_zd61 = 0.125;
const ℝ option_p_ini_zg61 = 1.0;
const ℝ option_p_ini_zd61 = 0.1;

ℝ t61=0.0;
ℝ δt61=0.0;

ℝ² coord61[nodes61], X61[nodes61], b61[nodes61], bt61[nodes61];
ℝ²ˣ² Ar61[nodes61], Mt61[nodes61];
ℝ² ur61[nodes61];
ℝ p_ic61[cells61], ρ_ic61[cells61], V_ic61[cells61];
ℝ c61[cells61], m61[cells61], p61[cells61], ρ61[cells61], e61[cells61], E61[cells61], V61[cells61];
ℝ δtj61[cells61];
ℝ² uj61[cells61], center61[cells61];
ℝ l61[cells61, nodesOfCell61];
ℝ² C_ic61[cells61, nodesOfCell61], C61[cells61, nodesOfCell61], F61[cells61, nodesOfCell61];
ℝ²ˣ² Ajr61[cells61, nodesOfCell61];


// Options obligatoires pour générer
const ℝ LENGTH62 = 0.01;
const ℕ X_EDGE_ELEMS62 = 100;
const ℕ Y_EDGE_ELEMS62 = 10;
const ℕ Z_EDGE_ELEMS62 = 1;
const ℝ option_stoptime62 = 0.2;
const ℕ option_max_iterations62 = 20000;

// Autres options
const ℝ γ62 = 1.4;
const ℝ option_x_interface62 = 0.5;
const ℝ option_δt_ini62 = 1.0e-5;
const ℝ option_δt_cfl62 = 0.4;
const ℝ option_ρ_ini_zg62 = 1.0;
const ℝ option_ρ_ini_zd62 = 0.125;
const ℝ option_p_ini_zg62 = 1.0;
const ℝ option_p_ini_zd62 = 0.1;

ℝ t62=0.0;
ℝ δt62=0.0;

ℝ² coord62[nodes62], X62[nodes62], b62[nodes62], bt62[nodes62];
ℝ²ˣ² Ar62[nodes62], Mt62[nodes62];
ℝ² ur62[nodes62];
ℝ p_ic62[cells62], ρ_ic62[cells62], V_ic62[cells62];
ℝ c62[cells62], m62[cells62], p62[cells62], ρ62[cells62], e62[cells62], E62[cells62], V62[cells62];
ℝ δtj62[cells62];
ℝ² uj62[cells62], center62[cells62];
ℝ l62[cells62, nodesOfCell62];
ℝ² C_ic62[cells62, nodesOfCell62], C62[cells62, nodesOfCell62], F62[cells62, nodesOfCell62];
ℝ²ˣ² Ajr62[cells62, nodesOfCell62];


// Options obligatoires pour générer
const ℝ LENGTH63 = 0.01;
const ℕ X_EDGE_ELEMS63 = 100;
const ℕ Y_EDGE_ELEMS63 = 10;
const ℕ Z_EDGE_ELEMS63 = 1;
const ℝ option_stoptime63 = 0.2;
const ℕ option_max_iterations63 = 20000;

// Autres options
const ℝ γ63 = 1.4;
const ℝ option_x_interface63 = 0.5;
const ℝ option_δt_ini63 = 1.0e-5;
const ℝ option_δt_cfl63 = 0.4;
const ℝ option_ρ_ini_zg63 = 1.0;
const ℝ option_ρ_ini_zd63 = 0.125;
const ℝ option_p_ini_zg63 = 1.0;
const ℝ option_p_ini_zd63 = 0.1;

ℝ t63=0.0;
ℝ δt63=0.0;

ℝ² coord63[nodes63], X63[nodes63], b63[nodes63], bt63[nodes63];
ℝ²ˣ² Ar63[nodes63], Mt63[nodes63];
ℝ² ur63[nodes63];
ℝ p_ic63[cells63], ρ_ic63[cells63], V_ic63[cells63];
ℝ c63[cells63], m63[cells63], p63[cells63], ρ63[cells63], e63[cells63], E63[cells63], V63[cells63];
ℝ δtj63[cells63];
ℝ² uj63[cells63], center63[cells63];
ℝ l63[cells63, nodesOfCell63];
ℝ² C_ic63[cells63, nodesOfCell63], C63[cells63, nodesOfCell63], F63[cells63, nodesOfCell63];
ℝ²ˣ² Ajr63[cells63, nodesOfCell63];


// Options obligatoires pour générer
const ℝ LENGTH64 = 0.01;
const ℕ X_EDGE_ELEMS64 = 100;
const ℕ Y_EDGE_ELEMS64 = 10;
const ℕ Z_EDGE_ELEMS64 = 1;
const ℝ option_stoptime64 = 0.2;
const ℕ option_max_iterations64 = 20000;

// Autres options
const ℝ γ64 = 1.4;
const ℝ option_x_interface64 = 0.5;
const ℝ option_δt_ini64 = 1.0e-5;
const ℝ option_δt_cfl64 = 0.4;
const ℝ option_ρ_ini_zg64 = 1.0;
const ℝ option_ρ_ini_zd64 = 0.125;
const ℝ option_p_ini_zg64 = 1.0;
const ℝ option_p_ini_zd64 = 0.1;

ℝ t64=0.0;
ℝ δt64=0.0;

ℝ² coord64[nodes64], X64[nodes64], b64[nodes64], bt64[nodes64];
ℝ²ˣ² Ar64[nodes64], Mt64[nodes64];
ℝ² ur64[nodes64];
ℝ p_ic64[cells64], ρ_ic64[cells64], V_ic64[cells64];
ℝ c64[cells64], m64[cells64], p64[cells64], ρ64[cells64], e64[cells64], E64[cells64], V64[cells64];
ℝ δtj64[cells64];
ℝ² uj64[cells64], center64[cells64];
ℝ l64[cells64, nodesOfCell64];
ℝ² C_ic64[cells64, nodesOfCell64], C64[cells64, nodesOfCell64], F64[cells64, nodesOfCell64];
ℝ²ˣ² Ajr64[cells64, nodesOfCell64];


// Options obligatoires pour générer
const ℝ LENGTH65 = 0.01;
const ℕ X_EDGE_ELEMS65 = 100;
const ℕ Y_EDGE_ELEMS65 = 10;
const ℕ Z_EDGE_ELEMS65 = 1;
const ℝ option_stoptime65 = 0.2;
const ℕ option_max_iterations65 = 20000;

// Autres options
const ℝ γ65 = 1.4;
const ℝ option_x_interface65 = 0.5;
const ℝ option_δt_ini65 = 1.0e-5;
const ℝ option_δt_cfl65 = 0.4;
const ℝ option_ρ_ini_zg65 = 1.0;
const ℝ option_ρ_ini_zd65 = 0.125;
const ℝ option_p_ini_zg65 = 1.0;
const ℝ option_p_ini_zd65 = 0.1;

ℝ t65=0.0;
ℝ δt65=0.0;

ℝ² coord65[nodes65], X65[nodes65], b65[nodes65], bt65[nodes65];
ℝ²ˣ² Ar65[nodes65], Mt65[nodes65];
ℝ² ur65[nodes65];
ℝ p_ic65[cells65], ρ_ic65[cells65], V_ic65[cells65];
ℝ c65[cells65], m65[cells65], p65[cells65], ρ65[cells65], e65[cells65], E65[cells65], V65[cells65];
ℝ δtj65[cells65];
ℝ² uj65[cells65], center65[cells65];
ℝ l65[cells65, nodesOfCell65];
ℝ² C_ic65[cells65, nodesOfCell65], C65[cells65, nodesOfCell65], F65[cells65, nodesOfCell65];
ℝ²ˣ² Ajr65[cells65, nodesOfCell65];


// Options obligatoires pour générer
const ℝ LENGTH66 = 0.01;
const ℕ X_EDGE_ELEMS66 = 100;
const ℕ Y_EDGE_ELEMS66 = 10;
const ℕ Z_EDGE_ELEMS66 = 1;
const ℝ option_stoptime66 = 0.2;
const ℕ option_max_iterations66 = 20000;

// Autres options
const ℝ γ66 = 1.4;
const ℝ option_x_interface66 = 0.5;
const ℝ option_δt_ini66 = 1.0e-5;
const ℝ option_δt_cfl66 = 0.4;
const ℝ option_ρ_ini_zg66 = 1.0;
const ℝ option_ρ_ini_zd66 = 0.125;
const ℝ option_p_ini_zg66 = 1.0;
const ℝ option_p_ini_zd66 = 0.1;

ℝ t66=0.0;
ℝ δt66=0.0;

ℝ² coord66[nodes66], X66[nodes66], b66[nodes66], bt66[nodes66];
ℝ²ˣ² Ar66[nodes66], Mt66[nodes66];
ℝ² ur66[nodes66];
ℝ p_ic66[cells66], ρ_ic66[cells66], V_ic66[cells66];
ℝ c66[cells66], m66[cells66], p66[cells66], ρ66[cells66], e66[cells66], E66[cells66], V66[cells66];
ℝ δtj66[cells66];
ℝ² uj66[cells66], center66[cells66];
ℝ l66[cells66, nodesOfCell66];
ℝ² C_ic66[cells66, nodesOfCell66], C66[cells66, nodesOfCell66], F66[cells66, nodesOfCell66];
ℝ²ˣ² Ajr66[cells66, nodesOfCell66];


// Options obligatoires pour générer
const ℝ LENGTH67 = 0.01;
const ℕ X_EDGE_ELEMS67 = 100;
const ℕ Y_EDGE_ELEMS67 = 10;
const ℕ Z_EDGE_ELEMS67 = 1;
const ℝ option_stoptime67 = 0.2;
const ℕ option_max_iterations67 = 20000;

// Autres options
const ℝ γ67 = 1.4;
const ℝ option_x_interface67 = 0.5;
const ℝ option_δt_ini67 = 1.0e-5;
const ℝ option_δt_cfl67 = 0.4;
const ℝ option_ρ_ini_zg67 = 1.0;
const ℝ option_ρ_ini_zd67 = 0.125;
const ℝ option_p_ini_zg67 = 1.0;
const ℝ option_p_ini_zd67 = 0.1;

ℝ t67=0.0;
ℝ δt67=0.0;

ℝ² coord67[nodes67], X67[nodes67], b67[nodes67], bt67[nodes67];
ℝ²ˣ² Ar67[nodes67], Mt67[nodes67];
ℝ² ur67[nodes67];
ℝ p_ic67[cells67], ρ_ic67[cells67], V_ic67[cells67];
ℝ c67[cells67], m67[cells67], p67[cells67], ρ67[cells67], e67[cells67], E67[cells67], V67[cells67];
ℝ δtj67[cells67];
ℝ² uj67[cells67], center67[cells67];
ℝ l67[cells67, nodesOfCell67];
ℝ² C_ic67[cells67, nodesOfCell67], C67[cells67, nodesOfCell67], F67[cells67, nodesOfCell67];
ℝ²ˣ² Ajr67[cells67, nodesOfCell67];


// Options obligatoires pour générer
const ℝ LENGTH68 = 0.01;
const ℕ X_EDGE_ELEMS68 = 100;
const ℕ Y_EDGE_ELEMS68 = 10;
const ℕ Z_EDGE_ELEMS68 = 1;
const ℝ option_stoptime68 = 0.2;
const ℕ option_max_iterations68 = 20000;

// Autres options
const ℝ γ68 = 1.4;
const ℝ option_x_interface68 = 0.5;
const ℝ option_δt_ini68 = 1.0e-5;
const ℝ option_δt_cfl68 = 0.4;
const ℝ option_ρ_ini_zg68 = 1.0;
const ℝ option_ρ_ini_zd68 = 0.125;
const ℝ option_p_ini_zg68 = 1.0;
const ℝ option_p_ini_zd68 = 0.1;

ℝ t68=0.0;
ℝ δt68=0.0;

ℝ² coord68[nodes68], X68[nodes68], b68[nodes68], bt68[nodes68];
ℝ²ˣ² Ar68[nodes68], Mt68[nodes68];
ℝ² ur68[nodes68];
ℝ p_ic68[cells68], ρ_ic68[cells68], V_ic68[cells68];
ℝ c68[cells68], m68[cells68], p68[cells68], ρ68[cells68], e68[cells68], E68[cells68], V68[cells68];
ℝ δtj68[cells68];
ℝ² uj68[cells68], center68[cells68];
ℝ l68[cells68, nodesOfCell68];
ℝ² C_ic68[cells68, nodesOfCell68], C68[cells68, nodesOfCell68], F68[cells68, nodesOfCell68];
ℝ²ˣ² Ajr68[cells68, nodesOfCell68];


// Options obligatoires pour générer
const ℝ LENGTH69 = 0.01;
const ℕ X_EDGE_ELEMS69 = 100;
const ℕ Y_EDGE_ELEMS69 = 10;
const ℕ Z_EDGE_ELEMS69 = 1;
const ℝ option_stoptime69 = 0.2;
const ℕ option_max_iterations69 = 20000;

// Autres options
const ℝ γ69 = 1.4;
const ℝ option_x_interface69 = 0.5;
const ℝ option_δt_ini69 = 1.0e-5;
const ℝ option_δt_cfl69 = 0.4;
const ℝ option_ρ_ini_zg69 = 1.0;
const ℝ option_ρ_ini_zd69 = 0.125;
const ℝ option_p_ini_zg69 = 1.0;
const ℝ option_p_ini_zd69 = 0.1;

ℝ t69=0.0;
ℝ δt69=0.0;

ℝ² coord69[nodes69], X69[nodes69], b69[nodes69], bt69[nodes69];
ℝ²ˣ² Ar69[nodes69], Mt69[nodes69];
ℝ² ur69[nodes69];
ℝ p_ic69[cells69], ρ_ic69[cells69], V_ic69[cells69];
ℝ c69[cells69], m69[cells69], p69[cells69], ρ69[cells69], e69[cells69], E69[cells69], V69[cells69];
ℝ δtj69[cells69];
ℝ² uj69[cells69], center69[cells69];
ℝ l69[cells69, nodesOfCell69];
ℝ² C_ic69[cells69, nodesOfCell69], C69[cells69, nodesOfCell69], F69[cells69, nodesOfCell69];
ℝ²ˣ² Ajr69[cells69, nodesOfCell69];


// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter1: ∀j1∈cells1(), center1{j1} = (1.0/4.0) * ∑{r1∈nodesOfCell1(j1)}(coord1{r1});
IniIc1: ∀j1∈cells1(), if (center1{j1}.x < option_x_interface1) {
  ρ_ic1{j1}=option_ρ_ini_zg1;
  p_ic1{j1}=option_p_ini_zg1;
} else {
  ρ_ic1{j1}=option_ρ_ini_zd1;
  p_ic1{j1}=option_p_ini_zd1;
}

ComputeCjrIc1: ∀j1∈cells1(), ∀r1∈nodesOfCell1(j1), 
	C_ic1{j1,r1} = 0.5 * perp1(coord1{►(r1)} - coord1{◄(r1)});
IniVIc1: ∀j1∈cells1(), V_ic1{j1} = 0.5 * ∑{r1∈nodesOfCell1(j1)}(dot(C_ic1{j1,r1}, coord1{r1}));
IniM1: ∀j1∈cells1(), m1{j1} = ρ_ic1{j1} * V_ic1{j1}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr1: ∀j1∈cells1(), ∀r1∈nodesOfCell1(j1), C1{j1,r1} = 0.5 * perp1(X1{►(r1)} - X1{◄(r1)});
ComputeLjr1: ∀j1∈cells1(), ∀r1∈nodesOfCell1(j1), l1{j1,r1} = norm(C1{j1,r1});
Computeδtj1: ∀j1∈cells1(), δtj1{j1} = 2.0 * V1{j1} / (c1{j1} * ∑{r1∈nodesOfCell1(j1)}(l1{j1,r1}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity1: ∀j1∈cells1(), ρ1{j1} = m1{j1} / V1{j1};
ComputeEOSp1: ∀j1∈cells1(), p1{j1} = (γ1-1.0) * ρ1{j1} * e1{j1};
ComputeInternalEngergy1: ∀j1∈cells1(), e1{j1} = E1{j1} - 0.5 * dot(uj1{j1}, uj1{j1});
ComputeEOSc1: ∀j1∈cells1(), c1{j1} = √(γ1*p1{j1}/ρ1{j1}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr1: ∀j1∈cells1(), ∀r1∈nodesOfCell1(j1), Ajr1{j1,r1} = ((ρ1{j1}*c1{j1})/l1{j1,r1}) * tensProduct1(C1{j1,r1}, C1{j1,r1});
ComputeFjr1: ∀j1∈cells1(), ∀r1∈nodesOfCell1(j1), F1{j1,r1} = p1{j1}*C1{j1,r1} + matVectProduct1(Ajr1{j1,r1}, (uj1{j1}-ur1{r1}));
ComputeAr1: ∀r1∈nodes1(), Ar1{r1} = ∑{j1∈cellsOfNode1(r1)}(Ajr1{j1,r1});
ComputeBr1: ∀r1∈nodes1(), b1{r1} = ∑{j1∈cellsOfNode1(r1)}(p1{j1}*C1{j1,r1} + matVectProduct1(Ajr1{j1,r1}, uj1{j1}));
ComputeMt1: ∀r1∈innerNodes1(), Mt1{r1} = Ar1{r1};
ComputeBt1: ∀r1∈innerNodes1(), bt1{r1} = b1{r1};

OuterFacesComputations1: ∀k1∈outerFaces1(), {
	const ℝ epsilon1 = 1.0e-10;
	ℝ²ˣ² I1 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN1 = 0.0;
	ℝ X_MAX1 = X_EDGE_ELEMS1 * LENGTH1;
	ℝ Y_MIN1 = 0.0; 
	ℝ Y_MAX1 = Y_EDGE_ELEMS1 * LENGTH1;
	ℝ² nY1 = {0.0,1.0};
	
	∀r1∈nodesOfFace1(k1), {
		// Y boundary conditions (must be done before X)
		if ((X1{r1}.y-Y_MIN1 < epsilon1) || (X1{r1}.y-Y_MAX1 < epsilon1)) {
			ℝ sign1 = 0.0;
			if (X1{r1}.y-Y_MIN1 < epsilon1) sign1 = -1.0;
			else sign1 = 1.0;
			ℝ² n1 = sign1 * nY1;
      		ℝ²ˣ² nxn1 = tensProduct1(n1,n1);
      		ℝ²ˣ² IcP1 = I1 - nxn1;
			bt1{r1} = matVectProduct1(IcP1, b1{r1});
			Mt1{r1} = IcP1 * (Ar1{r1} * IcP1) + nxn1*trace1(Ar1{r1});
		}

		// X boundary conditions
		if ((Math.fabs(X1{r1}.x-X_MIN1) < epsilon1) || ( (Math.fabs(X1{r1}.x-X_MAX1) < epsilon1) )) {
			Mt1{r1} = I1;
			bt1{r1} = {0.0, 0.0};
		}
	}
}


ComputeU1: ∀r1∈nodes1(), ur1{r1} = matVectProduct1(inverse1(Mt1{r1}), bt1{r1});
ComputeV1: ∀j1∈cells1(), V1{j1} = 0.5 * ∑{r1∈nodesOfCell1(j1)}(dot(C1{j1,r1},X1{r1}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn1: ∀n1∈ℕ, ∀r01∈nodes1(), X1{r01}^{n1=0}=coord1{r01}; , ∀r1∈nodes1(), X1{r1}^{n1+1}=X1{r1}^{n1}+δt1^{n1}*ur1{r1};
ComputeUn1: ∀n1∈ℕ, ∀j01∈cells1(), uj1{j01}^{n1=0}={0.0,0.0}; , ∀j1∈cells1(), uj1{j1}^{n1+1}=uj1{j1}^{n1}-(δt1^{n1}/m1{j1})*∑{r1∈nodesOfCell1(j1)}(F1{j1,r1});
ComputeEn1: ∀n1∈ℕ, ∀j01∈cells1(), E1{j01}^{n1=0}=p_ic1{j01}/((γ1-1.0)*ρ_ic1{j01}); , ∀j1∈cells1(), E1{j1}^{n1+1}=E1{j1}^{n1} - (δt1^{n1} / m1{j1}) * ∑{r1∈nodesOfCell1(j1)}(dot(F1{j1,r1},ur1{r1}));
ComputeDt1: ∀n1∈ℕ, δt1^{n1=0}=option_δt_ini1;, δt1^{n1+1}=option_δt_cfl1*reduceMin{j1∈cells1()}(δtj1{j1});
ComputeTn1: ∀n1∈ℕ, t1^{n1=0}=0.0; , t1^{n1+1}=t1^{n1}+δt1^{n1+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter2: ∀j2∈cells2(), center2{j2} = (1.0/4.0) * ∑{r2∈nodesOfCell2(j2)}(coord2{r2});
IniIc2: ∀j2∈cells2(), if (center2{j2}.x < option_x_interface2) {
  ρ_ic2{j2}=option_ρ_ini_zg2;
  p_ic2{j2}=option_p_ini_zg2;
} else {
  ρ_ic2{j2}=option_ρ_ini_zd2;
  p_ic2{j2}=option_p_ini_zd2;
}

ComputeCjrIc2: ∀j2∈cells2(), ∀r2∈nodesOfCell2(j2), 
	C_ic2{j2,r2} = 0.5 * perp2(coord2{►(r2)} - coord2{◄(r2)});
IniVIc2: ∀j2∈cells2(), V_ic2{j2} = 0.5 * ∑{r2∈nodesOfCell2(j2)}(dot(C_ic2{j2,r2}, coord2{r2}));
IniM2: ∀j2∈cells2(), m2{j2} = ρ_ic2{j2} * V_ic2{j2}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr2: ∀j2∈cells2(), ∀r2∈nodesOfCell2(j2), C2{j2,r2} = 0.5 * perp2(X2{►(r2)} - X2{◄(r2)});
ComputeLjr2: ∀j2∈cells2(), ∀r2∈nodesOfCell2(j2), l2{j2,r2} = norm(C2{j2,r2});
Computeδtj2: ∀j2∈cells2(), δtj2{j2} = 2.0 * V2{j2} / (c2{j2} * ∑{r2∈nodesOfCell2(j2)}(l2{j2,r2}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity2: ∀j2∈cells2(), ρ2{j2} = m2{j2} / V2{j2};
ComputeEOSp2: ∀j2∈cells2(), p2{j2} = (γ2-1.0) * ρ2{j2} * e2{j2};
ComputeInternalEngergy2: ∀j2∈cells2(), e2{j2} = E2{j2} - 0.5 * dot(uj2{j2}, uj2{j2});
ComputeEOSc2: ∀j2∈cells2(), c2{j2} = √(γ2*p2{j2}/ρ2{j2}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr2: ∀j2∈cells2(), ∀r2∈nodesOfCell2(j2), Ajr2{j2,r2} = ((ρ2{j2}*c2{j2})/l2{j2,r2}) * tensProduct2(C2{j2,r2}, C2{j2,r2});
ComputeFjr2: ∀j2∈cells2(), ∀r2∈nodesOfCell2(j2), F2{j2,r2} = p2{j2}*C2{j2,r2} + matVectProduct2(Ajr2{j2,r2}, (uj2{j2}-ur2{r2}));
ComputeAr2: ∀r2∈nodes2(), Ar2{r2} = ∑{j2∈cellsOfNode2(r2)}(Ajr2{j2,r2});
ComputeBr2: ∀r2∈nodes2(), b2{r2} = ∑{j2∈cellsOfNode2(r2)}(p2{j2}*C2{j2,r2} + matVectProduct2(Ajr2{j2,r2}, uj2{j2}));
ComputeMt2: ∀r2∈innerNodes2(), Mt2{r2} = Ar2{r2};
ComputeBt2: ∀r2∈innerNodes2(), bt2{r2} = b2{r2};

OuterFacesComputations2: ∀k2∈outerFaces2(), {
	const ℝ epsilon2 = 1.0e-10;
	ℝ²ˣ² I2 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN2 = 0.0;
	ℝ X_MAX2 = X_EDGE_ELEMS2 * LENGTH2;
	ℝ Y_MIN2 = 0.0; 
	ℝ Y_MAX2 = Y_EDGE_ELEMS2 * LENGTH2;
	ℝ² nY2 = {0.0,1.0};
	
	∀r2∈nodesOfFace2(k2), {
		// Y boundary conditions (must be done before X)
		if ((X2{r2}.y-Y_MIN2 < epsilon2) || (X2{r2}.y-Y_MAX2 < epsilon2)) {
			ℝ sign2 = 0.0;
			if (X2{r2}.y-Y_MIN2 < epsilon2) sign2 = -1.0;
			else sign2 = 1.0;
			ℝ² n2 = sign2 * nY2;
      		ℝ²ˣ² nxn2 = tensProduct2(n2,n2);
      		ℝ²ˣ² IcP2 = I2 - nxn2;
			bt1{r2} = matVectProduct2(IcP2, b2{r2});
			Mt1{r2} = IcP2 * (Ar2{r2} * IcP2) + nxn2*trace2(Ar2{r2});
		}

		// X boundary conditions
		if ((Math.fabs(X2{r2}.x-X_MIN2) < epsilon2) || ( (Math.fabs(X2{r2}.x-X_MAX2) < epsilon2) )) {
			Mt2{r2} = I2;
			bt2{r2} = {0.0, 0.0};
		}
	}
}


ComputeU2: ∀r2∈nodes2(), ur2{r2} = matVectProduct2(inverse2(Mt2{r2}), bt2{r2});
ComputeV2: ∀j2∈cells2(), V2{j2} = 0.5 * ∑{r2∈nodesOfCell2(j2)}(dot(C2{j2,r2},X2{r2}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn2: ∀n2∈ℕ, ∀r02∈nodes2(), X2{r02}^{n2=0}=coord2{r02}; , ∀r2∈nodes2(), X2{r2}^{n2+1}=X2{r2}^{n2}+δt2^{n2}*ur2{r2};
ComputeUn2: ∀n2∈ℕ, ∀j02∈cells2(), uj2{j02}^{n2=0}={0.0,0.0}; , ∀j2∈cells2(), uj2{j2}^{n2+1}=uj2{j2}^{n2}-(δt2^{n2}/m2{j2})*∑{r2∈nodesOfCell2(j2)}(F2{j2,r2});
ComputeEn2: ∀n2∈ℕ, ∀j02∈cells2(), E2{j02}^{n2=0}=p_ic2{j02}/((γ2-1.0)*ρ_ic2{j02}); , ∀j2∈cells2(), E2{j2}^{n2+1}=E2{j2}^{n2} - (δt2^{n2} / m2{j2}) * ∑{r2∈nodesOfCell2(j2)}(dot(F2{j2,r2},ur2{r2}));
ComputeDt2: ∀n2∈ℕ, δt2^{n2=0}=option_δt_ini2;, δt2^{n2+1}=option_δt_cfl2*reduceMin{j2∈cells2()}(δtj2{j2});
ComputeTn2: ∀n2∈ℕ, t2^{n2=0}=0.0; , t2^{n2+1}=t2^{n2}+δt2^{n2+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter3: ∀j3∈cells3(), center3{j3} = (1.0/4.0) * ∑{r3∈nodesOfCell3(j3)}(coord3{r3});
IniIc3: ∀j3∈cells3(), if (center3{j3}.x < option_x_interface3) {
  ρ_ic3{j3}=option_ρ_ini_zg3;
  p_ic3{j3}=option_p_ini_zg3;
} else {
  ρ_ic3{j3}=option_ρ_ini_zd3;
  p_ic3{j3}=option_p_ini_zd3;
}

ComputeCjrIc3: ∀j3∈cells3(), ∀r3∈nodesOfCell3(j3), 
	C_ic3{j3,r3} = 0.5 * perp3(coord3{►(r3)} - coord3{◄(r3)});
IniVIc3: ∀j3∈cells3(), V_ic3{j3} = 0.5 * ∑{r3∈nodesOfCell3(j3)}(dot(C_ic3{j3,r3}, coord3{r3}));
IniM3: ∀j3∈cells3(), m3{j3} = ρ_ic3{j3} * V_ic3{j3}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr3: ∀j3∈cells3(), ∀r3∈nodesOfCell3(j3), C3{j3,r3} = 0.5 * perp3(X3{►(r3)} - X3{◄(r3)});
ComputeLjr3: ∀j3∈cells3(), ∀r3∈nodesOfCell3(j3), l3{j3,r3} = norm(C3{j3,r3});
Computeδtj3: ∀j3∈cells3(), δtj3{j3} = 2.0 * V3{j3} / (c3{j3} * ∑{r3∈nodesOfCell3(j3)}(l3{j3,r3}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity3: ∀j3∈cells3(), ρ3{j3} = m3{j3} / V3{j3};
ComputeEOSp3: ∀j3∈cells3(), p3{j3} = (γ3-1.0) * ρ3{j3} * e3{j3};
ComputeInternalEngergy3: ∀j3∈cells3(), e3{j3} = E3{j3} - 0.5 * dot(uj3{j3}, uj3{j3});
ComputeEOSc3: ∀j3∈cells3(), c3{j3} = √(γ3*p3{j3}/ρ3{j3}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr3: ∀j3∈cells3(), ∀r3∈nodesOfCell3(j3), Ajr3{j3,r3} = ((ρ3{j3}*c3{j3})/l3{j3,r3}) * tensProduct3(C3{j3,r3}, C3{j3,r3});
ComputeFjr3: ∀j3∈cells3(), ∀r3∈nodesOfCell3(j3), F3{j3,r3} = p3{j3}*C3{j3,r3} + matVectProduct3(Ajr3{j3,r3}, (uj3{j3}-ur3{r3}));
ComputeAr3: ∀r3∈nodes3(), Ar3{r3} = ∑{j3∈cellsOfNode3(r3)}(Ajr3{j3,r3});
ComputeBr3: ∀r3∈nodes3(), b3{r3} = ∑{j3∈cellsOfNode3(r3)}(p3{j3}*C3{j3,r3} + matVectProduct3(Ajr3{j3,r3}, uj3{j3}));
ComputeMt3: ∀r3∈innerNodes3(), Mt3{r3} = Ar3{r3};
ComputeBt3: ∀r3∈innerNodes3(), bt3{r3} = b3{r3};

OuterFacesComputations3: ∀k3∈outerFaces3(), {
	const ℝ epsilon3 = 1.0e-10;
	ℝ²ˣ² I3 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN3 = 0.0;
	ℝ X_MAX3 = X_EDGE_ELEMS3 * LENGTH3;
	ℝ Y_MIN3 = 0.0; 
	ℝ Y_MAX3 = Y_EDGE_ELEMS3 * LENGTH3;
	ℝ² nY3 = {0.0,1.0};
	
	∀r3∈nodesOfFace3(k3), {
		// Y boundary conditions (must be done before X)
		if ((X3{r3}.y-Y_MIN3 < epsilon3) || (X3{r3}.y-Y_MAX3 < epsilon3)) {
			ℝ sign3 = 0.0;
			if (X3{r3}.y-Y_MIN3 < epsilon3) sign3 = -1.0;
			else sign3 = 1.0;
			ℝ² n3 = sign3 * nY3;
      		ℝ²ˣ² nxn3 = tensProduct3(n3,n3);
      		ℝ²ˣ² IcP3 = I3 - nxn3;
			bt1{r3} = matVectProduct3(IcP3, b3{r3});
			Mt1{r3} = IcP3 * (Ar3{r3} * IcP3) + nxn3*trace3(Ar3{r3});
		}

		// X boundary conditions
		if ((Math.fabs(X3{r3}.x-X_MIN3) < epsilon3) || ( (Math.fabs(X3{r3}.x-X_MAX3) < epsilon3) )) {
			Mt3{r3} = I3;
			bt3{r3} = {0.0, 0.0};
		}
	}
}


ComputeU3: ∀r3∈nodes3(), ur3{r3} = matVectProduct3(inverse3(Mt3{r3}), bt3{r3});
ComputeV3: ∀j3∈cells3(), V3{j3} = 0.5 * ∑{r3∈nodesOfCell3(j3)}(dot(C3{j3,r3},X3{r3}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn3: ∀n3∈ℕ, ∀r03∈nodes3(), X3{r03}^{n3=0}=coord3{r03}; , ∀r3∈nodes3(), X3{r3}^{n3+1}=X3{r3}^{n3}+δt3^{n3}*ur3{r3};
ComputeUn3: ∀n3∈ℕ, ∀j03∈cells3(), uj3{j03}^{n3=0}={0.0,0.0}; , ∀j3∈cells3(), uj3{j3}^{n3+1}=uj3{j3}^{n3}-(δt3^{n3}/m3{j3})*∑{r3∈nodesOfCell3(j3)}(F3{j3,r3});
ComputeEn3: ∀n3∈ℕ, ∀j03∈cells3(), E3{j03}^{n3=0}=p_ic3{j03}/((γ3-1.0)*ρ_ic3{j03}); , ∀j3∈cells3(), E3{j3}^{n3+1}=E3{j3}^{n3} - (δt3^{n3} / m3{j3}) * ∑{r3∈nodesOfCell3(j3)}(dot(F3{j3,r3},ur3{r3}));
ComputeDt3: ∀n3∈ℕ, δt3^{n3=0}=option_δt_ini3;, δt3^{n3+1}=option_δt_cfl3*reduceMin{j3∈cells3()}(δtj3{j3});
ComputeTn3: ∀n3∈ℕ, t3^{n3=0}=0.0; , t3^{n3+1}=t3^{n3}+δt3^{n3+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter4: ∀j4∈cells4(), center4{j4} = (1.0/4.0) * ∑{r4∈nodesOfCell4(j4)}(coord4{r4});
IniIc4: ∀j4∈cells4(), if (center4{j4}.x < option_x_interface4) {
  ρ_ic4{j4}=option_ρ_ini_zg4;
  p_ic4{j4}=option_p_ini_zg4;
} else {
  ρ_ic4{j4}=option_ρ_ini_zd4;
  p_ic4{j4}=option_p_ini_zd4;
}

ComputeCjrIc4: ∀j4∈cells4(), ∀r4∈nodesOfCell4(j4), 
	C_ic4{j4,r4} = 0.5 * perp4(coord4{►(r4)} - coord4{◄(r4)});
IniVIc4: ∀j4∈cells4(), V_ic4{j4} = 0.5 * ∑{r4∈nodesOfCell4(j4)}(dot(C_ic4{j4,r4}, coord4{r4}));
IniM4: ∀j4∈cells4(), m4{j4} = ρ_ic4{j4} * V_ic4{j4}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr4: ∀j4∈cells4(), ∀r4∈nodesOfCell4(j4), C4{j4,r4} = 0.5 * perp4(X4{►(r4)} - X4{◄(r4)});
ComputeLjr4: ∀j4∈cells4(), ∀r4∈nodesOfCell4(j4), l4{j4,r4} = norm(C4{j4,r4});
Computeδtj4: ∀j4∈cells4(), δtj4{j4} = 2.0 * V4{j4} / (c4{j4} * ∑{r4∈nodesOfCell4(j4)}(l4{j4,r4}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity4: ∀j4∈cells4(), ρ4{j4} = m4{j4} / V4{j4};
ComputeEOSp4: ∀j4∈cells4(), p4{j4} = (γ4-1.0) * ρ4{j4} * e4{j4};
ComputeInternalEngergy4: ∀j4∈cells4(), e4{j4} = E4{j4} - 0.5 * dot(uj4{j4}, uj4{j4});
ComputeEOSc4: ∀j4∈cells4(), c4{j4} = √(γ4*p4{j4}/ρ4{j4}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr4: ∀j4∈cells4(), ∀r4∈nodesOfCell4(j4), Ajr4{j4,r4} = ((ρ4{j4}*c4{j4})/l4{j4,r4}) * tensProduct4(C4{j4,r4}, C4{j4,r4});
ComputeFjr4: ∀j4∈cells4(), ∀r4∈nodesOfCell4(j4), F4{j4,r4} = p4{j4}*C4{j4,r4} + matVectProduct4(Ajr4{j4,r4}, (uj4{j4}-ur4{r4}));
ComputeAr4: ∀r4∈nodes4(), Ar4{r4} = ∑{j4∈cellsOfNode4(r4)}(Ajr4{j4,r4});
ComputeBr4: ∀r4∈nodes4(), b4{r4} = ∑{j4∈cellsOfNode4(r4)}(p4{j4}*C4{j4,r4} + matVectProduct4(Ajr4{j4,r4}, uj4{j4}));
ComputeMt4: ∀r4∈innerNodes4(), Mt4{r4} = Ar4{r4};
ComputeBt4: ∀r4∈innerNodes4(), bt4{r4} = b4{r4};

OuterFacesComputations4: ∀k4∈outerFaces4(), {
	const ℝ epsilon4 = 1.0e-10;
	ℝ²ˣ² I4 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN4 = 0.0;
	ℝ X_MAX4 = X_EDGE_ELEMS4 * LENGTH4;
	ℝ Y_MIN4 = 0.0; 
	ℝ Y_MAX4 = Y_EDGE_ELEMS4 * LENGTH4;
	ℝ² nY4 = {0.0,1.0};
	
	∀r4∈nodesOfFace4(k4), {
		// Y boundary conditions (must be done before X)
		if ((X4{r4}.y-Y_MIN4 < epsilon4) || (X4{r4}.y-Y_MAX4 < epsilon4)) {
			ℝ sign4 = 0.0;
			if (X4{r4}.y-Y_MIN4 < epsilon4) sign4 = -1.0;
			else sign4 = 1.0;
			ℝ² n4 = sign4 * nY4;
      		ℝ²ˣ² nxn4 = tensProduct4(n4,n4);
      		ℝ²ˣ² IcP4 = I4 - nxn4;
			bt1{r4} = matVectProduct4(IcP4, b4{r4});
			Mt1{r4} = IcP4 * (Ar4{r4} * IcP4) + nxn4*trace4(Ar4{r4});
		}

		// X boundary conditions
		if ((Math.fabs(X4{r4}.x-X_MIN4) < epsilon4) || ( (Math.fabs(X4{r4}.x-X_MAX4) < epsilon4) )) {
			Mt4{r4} = I4;
			bt4{r4} = {0.0, 0.0};
		}
	}
}


ComputeU4: ∀r4∈nodes4(), ur4{r4} = matVectProduct4(inverse4(Mt4{r4}), bt4{r4});
ComputeV4: ∀j4∈cells4(), V4{j4} = 0.5 * ∑{r4∈nodesOfCell4(j4)}(dot(C4{j4,r4},X4{r4}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn4: ∀n4∈ℕ, ∀r04∈nodes4(), X4{r04}^{n4=0}=coord4{r04}; , ∀r4∈nodes4(), X4{r4}^{n4+1}=X4{r4}^{n4}+δt4^{n4}*ur4{r4};
ComputeUn4: ∀n4∈ℕ, ∀j04∈cells4(), uj4{j04}^{n4=0}={0.0,0.0}; , ∀j4∈cells4(), uj4{j4}^{n4+1}=uj4{j4}^{n4}-(δt4^{n4}/m4{j4})*∑{r4∈nodesOfCell4(j4)}(F4{j4,r4});
ComputeEn4: ∀n4∈ℕ, ∀j04∈cells4(), E4{j04}^{n4=0}=p_ic4{j04}/((γ4-1.0)*ρ_ic4{j04}); , ∀j4∈cells4(), E4{j4}^{n4+1}=E4{j4}^{n4} - (δt4^{n4} / m4{j4}) * ∑{r4∈nodesOfCell4(j4)}(dot(F4{j4,r4},ur4{r4}));
ComputeDt4: ∀n4∈ℕ, δt4^{n4=0}=option_δt_ini4;, δt4^{n4+1}=option_δt_cfl4*reduceMin{j4∈cells4()}(δtj4{j4});
ComputeTn4: ∀n4∈ℕ, t4^{n4=0}=0.0; , t4^{n4+1}=t4^{n4}+δt4^{n4+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter5: ∀j5∈cells5(), center5{j5} = (1.0/4.0) * ∑{r5∈nodesOfCell5(j5)}(coord5{r5});
IniIc5: ∀j5∈cells5(), if (center5{j5}.x < option_x_interface5) {
  ρ_ic5{j5}=option_ρ_ini_zg5;
  p_ic5{j5}=option_p_ini_zg5;
} else {
  ρ_ic5{j5}=option_ρ_ini_zd5;
  p_ic5{j5}=option_p_ini_zd5;
}

ComputeCjrIc5: ∀j5∈cells5(), ∀r5∈nodesOfCell5(j5), 
	C_ic5{j5,r5} = 0.5 * perp5(coord5{►(r5)} - coord5{◄(r5)});
IniVIc5: ∀j5∈cells5(), V_ic5{j5} = 0.5 * ∑{r5∈nodesOfCell5(j5)}(dot(C_ic5{j5,r5}, coord5{r5}));
IniM5: ∀j5∈cells5(), m5{j5} = ρ_ic5{j5} * V_ic5{j5}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr5: ∀j5∈cells5(), ∀r5∈nodesOfCell5(j5), C5{j5,r5} = 0.5 * perp5(X5{►(r5)} - X5{◄(r5)});
ComputeLjr5: ∀j5∈cells5(), ∀r5∈nodesOfCell5(j5), l5{j5,r5} = norm(C5{j5,r5});
Computeδtj5: ∀j5∈cells5(), δtj5{j5} = 2.0 * V5{j5} / (c5{j5} * ∑{r5∈nodesOfCell5(j5)}(l5{j5,r5}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity5: ∀j5∈cells5(), ρ5{j5} = m5{j5} / V5{j5};
ComputeEOSp5: ∀j5∈cells5(), p5{j5} = (γ5-1.0) * ρ5{j5} * e5{j5};
ComputeInternalEngergy5: ∀j5∈cells5(), e5{j5} = E5{j5} - 0.5 * dot(uj5{j5}, uj5{j5});
ComputeEOSc5: ∀j5∈cells5(), c5{j5} = √(γ5*p5{j5}/ρ5{j5}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr5: ∀j5∈cells5(), ∀r5∈nodesOfCell5(j5), Ajr5{j5,r5} = ((ρ5{j5}*c5{j5})/l5{j5,r5}) * tensProduct5(C5{j5,r5}, C5{j5,r5});
ComputeFjr5: ∀j5∈cells5(), ∀r5∈nodesOfCell5(j5), F5{j5,r5} = p5{j5}*C5{j5,r5} + matVectProduct5(Ajr5{j5,r5}, (uj5{j5}-ur5{r5}));
ComputeAr5: ∀r5∈nodes5(), Ar5{r5} = ∑{j5∈cellsOfNode5(r5)}(Ajr5{j5,r5});
ComputeBr5: ∀r5∈nodes5(), b5{r5} = ∑{j5∈cellsOfNode5(r5)}(p5{j5}*C5{j5,r5} + matVectProduct5(Ajr5{j5,r5}, uj5{j5}));
ComputeMt5: ∀r5∈innerNodes5(), Mt5{r5} = Ar5{r5};
ComputeBt5: ∀r5∈innerNodes5(), bt5{r5} = b5{r5};

OuterFacesComputations5: ∀k5∈outerFaces5(), {
	const ℝ epsilon5 = 1.0e-10;
	ℝ²ˣ² I5 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN5 = 0.0;
	ℝ X_MAX5 = X_EDGE_ELEMS5 * LENGTH5;
	ℝ Y_MIN5 = 0.0; 
	ℝ Y_MAX5 = Y_EDGE_ELEMS5 * LENGTH5;
	ℝ² nY5 = {0.0,1.0};
	
	∀r5∈nodesOfFace5(k5), {
		// Y boundary conditions (must be done before X)
		if ((X5{r5}.y-Y_MIN5 < epsilon5) || (X5{r5}.y-Y_MAX5 < epsilon5)) {
			ℝ sign5 = 0.0;
			if (X5{r5}.y-Y_MIN5 < epsilon5) sign5 = -1.0;
			else sign5 = 1.0;
			ℝ² n5 = sign5 * nY5;
      		ℝ²ˣ² nxn5 = tensProduct5(n5,n5);
      		ℝ²ˣ² IcP5 = I5 - nxn5;
			bt1{r5} = matVectProduct5(IcP5, b5{r5});
			Mt1{r5} = IcP5 * (Ar5{r5} * IcP5) + nxn5*trace5(Ar5{r5});
		}

		// X boundary conditions
		if ((Math.fabs(X5{r5}.x-X_MIN5) < epsilon5) || ( (Math.fabs(X5{r5}.x-X_MAX5) < epsilon5) )) {
			Mt5{r5} = I5;
			bt5{r5} = {0.0, 0.0};
		}
	}
}


ComputeU5: ∀r5∈nodes5(), ur5{r5} = matVectProduct5(inverse5(Mt5{r5}), bt5{r5});
ComputeV5: ∀j5∈cells5(), V5{j5} = 0.5 * ∑{r5∈nodesOfCell5(j5)}(dot(C5{j5,r5},X5{r5}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn5: ∀n5∈ℕ, ∀r05∈nodes5(), X5{r05}^{n5=0}=coord5{r05}; , ∀r5∈nodes5(), X5{r5}^{n5+1}=X5{r5}^{n5}+δt5^{n5}*ur5{r5};
ComputeUn5: ∀n5∈ℕ, ∀j05∈cells5(), uj5{j05}^{n5=0}={0.0,0.0}; , ∀j5∈cells5(), uj5{j5}^{n5+1}=uj5{j5}^{n5}-(δt5^{n5}/m5{j5})*∑{r5∈nodesOfCell5(j5)}(F5{j5,r5});
ComputeEn5: ∀n5∈ℕ, ∀j05∈cells5(), E5{j05}^{n5=0}=p_ic5{j05}/((γ5-1.0)*ρ_ic5{j05}); , ∀j5∈cells5(), E5{j5}^{n5+1}=E5{j5}^{n5} - (δt5^{n5} / m5{j5}) * ∑{r5∈nodesOfCell5(j5)}(dot(F5{j5,r5},ur5{r5}));
ComputeDt5: ∀n5∈ℕ, δt5^{n5=0}=option_δt_ini5;, δt5^{n5+1}=option_δt_cfl5*reduceMin{j5∈cells5()}(δtj5{j5});
ComputeTn5: ∀n5∈ℕ, t5^{n5=0}=0.0; , t5^{n5+1}=t5^{n5}+δt5^{n5+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter6: ∀j6∈cells6(), center6{j6} = (1.0/4.0) * ∑{r6∈nodesOfCell6(j6)}(coord6{r6});
IniIc6: ∀j6∈cells6(), if (center6{j6}.x < option_x_interface6) {
  ρ_ic6{j6}=option_ρ_ini_zg6;
  p_ic6{j6}=option_p_ini_zg6;
} else {
  ρ_ic6{j6}=option_ρ_ini_zd6;
  p_ic6{j6}=option_p_ini_zd6;
}

ComputeCjrIc6: ∀j6∈cells6(), ∀r6∈nodesOfCell6(j6), 
	C_ic6{j6,r6} = 0.5 * perp6(coord6{►(r6)} - coord6{◄(r6)});
IniVIc6: ∀j6∈cells6(), V_ic6{j6} = 0.5 * ∑{r6∈nodesOfCell6(j6)}(dot(C_ic6{j6,r6}, coord6{r6}));
IniM6: ∀j6∈cells6(), m6{j6} = ρ_ic6{j6} * V_ic6{j6}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr6: ∀j6∈cells6(), ∀r6∈nodesOfCell6(j6), C6{j6,r6} = 0.5 * perp6(X6{►(r6)} - X6{◄(r6)});
ComputeLjr6: ∀j6∈cells6(), ∀r6∈nodesOfCell6(j6), l6{j6,r6} = norm(C6{j6,r6});
Computeδtj6: ∀j6∈cells6(), δtj6{j6} = 2.0 * V6{j6} / (c6{j6} * ∑{r6∈nodesOfCell6(j6)}(l6{j6,r6}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity6: ∀j6∈cells6(), ρ6{j6} = m6{j6} / V6{j6};
ComputeEOSp6: ∀j6∈cells6(), p6{j6} = (γ6-1.0) * ρ6{j6} * e6{j6};
ComputeInternalEngergy6: ∀j6∈cells6(), e6{j6} = E6{j6} - 0.5 * dot(uj6{j6}, uj6{j6});
ComputeEOSc6: ∀j6∈cells6(), c6{j6} = √(γ6*p6{j6}/ρ6{j6}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr6: ∀j6∈cells6(), ∀r6∈nodesOfCell6(j6), Ajr6{j6,r6} = ((ρ6{j6}*c6{j6})/l6{j6,r6}) * tensProduct6(C6{j6,r6}, C6{j6,r6});
ComputeFjr6: ∀j6∈cells6(), ∀r6∈nodesOfCell6(j6), F6{j6,r6} = p6{j6}*C6{j6,r6} + matVectProduct6(Ajr6{j6,r6}, (uj6{j6}-ur6{r6}));
ComputeAr6: ∀r6∈nodes6(), Ar6{r6} = ∑{j6∈cellsOfNode6(r6)}(Ajr6{j6,r6});
ComputeBr6: ∀r6∈nodes6(), b6{r6} = ∑{j6∈cellsOfNode6(r6)}(p6{j6}*C6{j6,r6} + matVectProduct6(Ajr6{j6,r6}, uj6{j6}));
ComputeMt6: ∀r6∈innerNodes6(), Mt6{r6} = Ar6{r6};
ComputeBt6: ∀r6∈innerNodes6(), bt6{r6} = b6{r6};

OuterFacesComputations6: ∀k6∈outerFaces6(), {
	const ℝ epsilon6 = 1.0e-10;
	ℝ²ˣ² I6 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN6 = 0.0;
	ℝ X_MAX6 = X_EDGE_ELEMS6 * LENGTH6;
	ℝ Y_MIN6 = 0.0; 
	ℝ Y_MAX6 = Y_EDGE_ELEMS6 * LENGTH6;
	ℝ² nY6 = {0.0,1.0};
	
	∀r6∈nodesOfFace6(k6), {
		// Y boundary conditions (must be done before X)
		if ((X6{r6}.y-Y_MIN6 < epsilon6) || (X6{r6}.y-Y_MAX6 < epsilon6)) {
			ℝ sign6 = 0.0;
			if (X6{r6}.y-Y_MIN6 < epsilon6) sign6 = -1.0;
			else sign6 = 1.0;
			ℝ² n6 = sign6 * nY6;
      		ℝ²ˣ² nxn6 = tensProduct6(n6,n6);
      		ℝ²ˣ² IcP6 = I6 - nxn6;
			bt1{r6} = matVectProduct6(IcP6, b6{r6});
			Mt1{r6} = IcP6 * (Ar6{r6} * IcP6) + nxn6*trace6(Ar6{r6});
		}

		// X boundary conditions
		if ((Math.fabs(X6{r6}.x-X_MIN6) < epsilon6) || ( (Math.fabs(X6{r6}.x-X_MAX6) < epsilon6) )) {
			Mt6{r6} = I6;
			bt6{r6} = {0.0, 0.0};
		}
	}
}


ComputeU6: ∀r6∈nodes6(), ur6{r6} = matVectProduct6(inverse6(Mt6{r6}), bt6{r6});
ComputeV6: ∀j6∈cells6(), V6{j6} = 0.5 * ∑{r6∈nodesOfCell6(j6)}(dot(C6{j6,r6},X6{r6}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn6: ∀n6∈ℕ, ∀r06∈nodes6(), X6{r06}^{n6=0}=coord6{r06}; , ∀r6∈nodes6(), X6{r6}^{n6+1}=X6{r6}^{n6}+δt6^{n6}*ur6{r6};
ComputeUn6: ∀n6∈ℕ, ∀j06∈cells6(), uj6{j06}^{n6=0}={0.0,0.0}; , ∀j6∈cells6(), uj6{j6}^{n6+1}=uj6{j6}^{n6}-(δt6^{n6}/m6{j6})*∑{r6∈nodesOfCell6(j6)}(F6{j6,r6});
ComputeEn6: ∀n6∈ℕ, ∀j06∈cells6(), E6{j06}^{n6=0}=p_ic6{j06}/((γ6-1.0)*ρ_ic6{j06}); , ∀j6∈cells6(), E6{j6}^{n6+1}=E6{j6}^{n6} - (δt6^{n6} / m6{j6}) * ∑{r6∈nodesOfCell6(j6)}(dot(F6{j6,r6},ur6{r6}));
ComputeDt6: ∀n6∈ℕ, δt6^{n6=0}=option_δt_ini6;, δt6^{n6+1}=option_δt_cfl6*reduceMin{j6∈cells6()}(δtj6{j6});
ComputeTn6: ∀n6∈ℕ, t6^{n6=0}=0.0; , t6^{n6+1}=t6^{n6}+δt6^{n6+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter7: ∀j7∈cells7(), center7{j7} = (1.0/4.0) * ∑{r7∈nodesOfCell7(j7)}(coord7{r7});
IniIc7: ∀j7∈cells7(), if (center7{j7}.x < option_x_interface7) {
  ρ_ic7{j7}=option_ρ_ini_zg7;
  p_ic7{j7}=option_p_ini_zg7;
} else {
  ρ_ic7{j7}=option_ρ_ini_zd7;
  p_ic7{j7}=option_p_ini_zd7;
}

ComputeCjrIc7: ∀j7∈cells7(), ∀r7∈nodesOfCell7(j7), 
	C_ic7{j7,r7} = 0.5 * perp7(coord7{►(r7)} - coord7{◄(r7)});
IniVIc7: ∀j7∈cells7(), V_ic7{j7} = 0.5 * ∑{r7∈nodesOfCell7(j7)}(dot(C_ic7{j7,r7}, coord7{r7}));
IniM7: ∀j7∈cells7(), m7{j7} = ρ_ic7{j7} * V_ic7{j7}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr7: ∀j7∈cells7(), ∀r7∈nodesOfCell7(j7), C7{j7,r7} = 0.5 * perp7(X7{►(r7)} - X7{◄(r7)});
ComputeLjr7: ∀j7∈cells7(), ∀r7∈nodesOfCell7(j7), l7{j7,r7} = norm(C7{j7,r7});
Computeδtj7: ∀j7∈cells7(), δtj7{j7} = 2.0 * V7{j7} / (c7{j7} * ∑{r7∈nodesOfCell7(j7)}(l7{j7,r7}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity7: ∀j7∈cells7(), ρ7{j7} = m7{j7} / V7{j7};
ComputeEOSp7: ∀j7∈cells7(), p7{j7} = (γ7-1.0) * ρ7{j7} * e7{j7};
ComputeInternalEngergy7: ∀j7∈cells7(), e7{j7} = E7{j7} - 0.5 * dot(uj7{j7}, uj7{j7});
ComputeEOSc7: ∀j7∈cells7(), c7{j7} = √(γ7*p7{j7}/ρ7{j7}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr7: ∀j7∈cells7(), ∀r7∈nodesOfCell7(j7), Ajr7{j7,r7} = ((ρ7{j7}*c7{j7})/l7{j7,r7}) * tensProduct7(C7{j7,r7}, C7{j7,r7});
ComputeFjr7: ∀j7∈cells7(), ∀r7∈nodesOfCell7(j7), F7{j7,r7} = p7{j7}*C7{j7,r7} + matVectProduct7(Ajr7{j7,r7}, (uj7{j7}-ur7{r7}));
ComputeAr7: ∀r7∈nodes7(), Ar7{r7} = ∑{j7∈cellsOfNode7(r7)}(Ajr7{j7,r7});
ComputeBr7: ∀r7∈nodes7(), b7{r7} = ∑{j7∈cellsOfNode7(r7)}(p7{j7}*C7{j7,r7} + matVectProduct7(Ajr7{j7,r7}, uj7{j7}));
ComputeMt7: ∀r7∈innerNodes7(), Mt7{r7} = Ar7{r7};
ComputeBt7: ∀r7∈innerNodes7(), bt7{r7} = b7{r7};

OuterFacesComputations7: ∀k7∈outerFaces7(), {
	const ℝ epsilon7 = 1.0e-10;
	ℝ²ˣ² I7 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN7 = 0.0;
	ℝ X_MAX7 = X_EDGE_ELEMS7 * LENGTH7;
	ℝ Y_MIN7 = 0.0; 
	ℝ Y_MAX7 = Y_EDGE_ELEMS7 * LENGTH7;
	ℝ² nY7 = {0.0,1.0};
	
	∀r7∈nodesOfFace7(k7), {
		// Y boundary conditions (must be done before X)
		if ((X7{r7}.y-Y_MIN7 < epsilon7) || (X7{r7}.y-Y_MAX7 < epsilon7)) {
			ℝ sign7 = 0.0;
			if (X7{r7}.y-Y_MIN7 < epsilon7) sign7 = -1.0;
			else sign7 = 1.0;
			ℝ² n7 = sign7 * nY7;
      		ℝ²ˣ² nxn7 = tensProduct7(n7,n7);
      		ℝ²ˣ² IcP7 = I7 - nxn7;
			bt1{r7} = matVectProduct7(IcP7, b7{r7});
			Mt1{r7} = IcP7 * (Ar7{r7} * IcP7) + nxn7*trace7(Ar7{r7});
		}

		// X boundary conditions
		if ((Math.fabs(X7{r7}.x-X_MIN7) < epsilon7) || ( (Math.fabs(X7{r7}.x-X_MAX7) < epsilon7) )) {
			Mt7{r7} = I7;
			bt7{r7} = {0.0, 0.0};
		}
	}
}


ComputeU7: ∀r7∈nodes7(), ur7{r7} = matVectProduct7(inverse7(Mt7{r7}), bt7{r7});
ComputeV7: ∀j7∈cells7(), V7{j7} = 0.5 * ∑{r7∈nodesOfCell7(j7)}(dot(C7{j7,r7},X7{r7}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn7: ∀n7∈ℕ, ∀r07∈nodes7(), X7{r07}^{n7=0}=coord7{r07}; , ∀r7∈nodes7(), X7{r7}^{n7+1}=X7{r7}^{n7}+δt7^{n7}*ur7{r7};
ComputeUn7: ∀n7∈ℕ, ∀j07∈cells7(), uj7{j07}^{n7=0}={0.0,0.0}; , ∀j7∈cells7(), uj7{j7}^{n7+1}=uj7{j7}^{n7}-(δt7^{n7}/m7{j7})*∑{r7∈nodesOfCell7(j7)}(F7{j7,r7});
ComputeEn7: ∀n7∈ℕ, ∀j07∈cells7(), E7{j07}^{n7=0}=p_ic7{j07}/((γ7-1.0)*ρ_ic7{j07}); , ∀j7∈cells7(), E7{j7}^{n7+1}=E7{j7}^{n7} - (δt7^{n7} / m7{j7}) * ∑{r7∈nodesOfCell7(j7)}(dot(F7{j7,r7},ur7{r7}));
ComputeDt7: ∀n7∈ℕ, δt7^{n7=0}=option_δt_ini7;, δt7^{n7+1}=option_δt_cfl7*reduceMin{j7∈cells7()}(δtj7{j7});
ComputeTn7: ∀n7∈ℕ, t7^{n7=0}=0.0; , t7^{n7+1}=t7^{n7}+δt7^{n7+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter8: ∀j8∈cells8(), center8{j8} = (1.0/4.0) * ∑{r8∈nodesOfCell8(j8)}(coord8{r8});
IniIc8: ∀j8∈cells8(), if (center8{j8}.x < option_x_interface8) {
  ρ_ic8{j8}=option_ρ_ini_zg8;
  p_ic8{j8}=option_p_ini_zg8;
} else {
  ρ_ic8{j8}=option_ρ_ini_zd8;
  p_ic8{j8}=option_p_ini_zd8;
}

ComputeCjrIc8: ∀j8∈cells8(), ∀r8∈nodesOfCell8(j8), 
	C_ic8{j8,r8} = 0.5 * perp8(coord8{►(r8)} - coord8{◄(r8)});
IniVIc8: ∀j8∈cells8(), V_ic8{j8} = 0.5 * ∑{r8∈nodesOfCell8(j8)}(dot(C_ic8{j8,r8}, coord8{r8}));
IniM8: ∀j8∈cells8(), m8{j8} = ρ_ic8{j8} * V_ic8{j8}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr8: ∀j8∈cells8(), ∀r8∈nodesOfCell8(j8), C8{j8,r8} = 0.5 * perp8(X8{►(r8)} - X8{◄(r8)});
ComputeLjr8: ∀j8∈cells8(), ∀r8∈nodesOfCell8(j8), l8{j8,r8} = norm(C8{j8,r8});
Computeδtj8: ∀j8∈cells8(), δtj8{j8} = 2.0 * V8{j8} / (c8{j8} * ∑{r8∈nodesOfCell8(j8)}(l8{j8,r8}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity8: ∀j8∈cells8(), ρ8{j8} = m8{j8} / V8{j8};
ComputeEOSp8: ∀j8∈cells8(), p8{j8} = (γ8-1.0) * ρ8{j8} * e8{j8};
ComputeInternalEngergy8: ∀j8∈cells8(), e8{j8} = E8{j8} - 0.5 * dot(uj8{j8}, uj8{j8});
ComputeEOSc8: ∀j8∈cells8(), c8{j8} = √(γ8*p8{j8}/ρ8{j8}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr8: ∀j8∈cells8(), ∀r8∈nodesOfCell8(j8), Ajr8{j8,r8} = ((ρ8{j8}*c8{j8})/l8{j8,r8}) * tensProduct8(C8{j8,r8}, C8{j8,r8});
ComputeFjr8: ∀j8∈cells8(), ∀r8∈nodesOfCell8(j8), F8{j8,r8} = p8{j8}*C8{j8,r8} + matVectProduct8(Ajr8{j8,r8}, (uj8{j8}-ur8{r8}));
ComputeAr8: ∀r8∈nodes8(), Ar8{r8} = ∑{j8∈cellsOfNode8(r8)}(Ajr8{j8,r8});
ComputeBr8: ∀r8∈nodes8(), b8{r8} = ∑{j8∈cellsOfNode8(r8)}(p8{j8}*C8{j8,r8} + matVectProduct8(Ajr8{j8,r8}, uj8{j8}));
ComputeMt8: ∀r8∈innerNodes8(), Mt8{r8} = Ar8{r8};
ComputeBt8: ∀r8∈innerNodes8(), bt8{r8} = b8{r8};

OuterFacesComputations8: ∀k8∈outerFaces8(), {
	const ℝ epsilon8 = 1.0e-10;
	ℝ²ˣ² I8 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN8 = 0.0;
	ℝ X_MAX8 = X_EDGE_ELEMS8 * LENGTH8;
	ℝ Y_MIN8 = 0.0; 
	ℝ Y_MAX8 = Y_EDGE_ELEMS8 * LENGTH8;
	ℝ² nY8 = {0.0,1.0};
	
	∀r8∈nodesOfFace8(k8), {
		// Y boundary conditions (must be done before X)
		if ((X8{r8}.y-Y_MIN8 < epsilon8) || (X8{r8}.y-Y_MAX8 < epsilon8)) {
			ℝ sign8 = 0.0;
			if (X8{r8}.y-Y_MIN8 < epsilon8) sign8 = -1.0;
			else sign8 = 1.0;
			ℝ² n8 = sign8 * nY8;
      		ℝ²ˣ² nxn8 = tensProduct8(n8,n8);
      		ℝ²ˣ² IcP8 = I8 - nxn8;
			bt1{r8} = matVectProduct8(IcP8, b8{r8});
			Mt1{r8} = IcP8 * (Ar8{r8} * IcP8) + nxn8*trace8(Ar8{r8});
		}

		// X boundary conditions
		if ((Math.fabs(X8{r8}.x-X_MIN8) < epsilon8) || ( (Math.fabs(X8{r8}.x-X_MAX8) < epsilon8) )) {
			Mt8{r8} = I8;
			bt8{r8} = {0.0, 0.0};
		}
	}
}


ComputeU8: ∀r8∈nodes8(), ur8{r8} = matVectProduct8(inverse8(Mt8{r8}), bt8{r8});
ComputeV8: ∀j8∈cells8(), V8{j8} = 0.5 * ∑{r8∈nodesOfCell8(j8)}(dot(C8{j8,r8},X8{r8}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn8: ∀n8∈ℕ, ∀r08∈nodes8(), X8{r08}^{n8=0}=coord8{r08}; , ∀r8∈nodes8(), X8{r8}^{n8+1}=X8{r8}^{n8}+δt8^{n8}*ur8{r8};
ComputeUn8: ∀n8∈ℕ, ∀j08∈cells8(), uj8{j08}^{n8=0}={0.0,0.0}; , ∀j8∈cells8(), uj8{j8}^{n8+1}=uj8{j8}^{n8}-(δt8^{n8}/m8{j8})*∑{r8∈nodesOfCell8(j8)}(F8{j8,r8});
ComputeEn8: ∀n8∈ℕ, ∀j08∈cells8(), E8{j08}^{n8=0}=p_ic8{j08}/((γ8-1.0)*ρ_ic8{j08}); , ∀j8∈cells8(), E8{j8}^{n8+1}=E8{j8}^{n8} - (δt8^{n8} / m8{j8}) * ∑{r8∈nodesOfCell8(j8)}(dot(F8{j8,r8},ur8{r8}));
ComputeDt8: ∀n8∈ℕ, δt8^{n8=0}=option_δt_ini8;, δt8^{n8+1}=option_δt_cfl8*reduceMin{j8∈cells8()}(δtj8{j8});
ComputeTn8: ∀n8∈ℕ, t8^{n8=0}=0.0; , t8^{n8+1}=t8^{n8}+δt8^{n8+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter9: ∀j9∈cells9(), center9{j9} = (1.0/4.0) * ∑{r9∈nodesOfCell9(j9)}(coord9{r9});
IniIc9: ∀j9∈cells9(), if (center9{j9}.x < option_x_interface9) {
  ρ_ic9{j9}=option_ρ_ini_zg9;
  p_ic9{j9}=option_p_ini_zg9;
} else {
  ρ_ic9{j9}=option_ρ_ini_zd9;
  p_ic9{j9}=option_p_ini_zd9;
}

ComputeCjrIc9: ∀j9∈cells9(), ∀r9∈nodesOfCell9(j9), 
	C_ic9{j9,r9} = 0.5 * perp9(coord9{►(r9)} - coord9{◄(r9)});
IniVIc9: ∀j9∈cells9(), V_ic9{j9} = 0.5 * ∑{r9∈nodesOfCell9(j9)}(dot(C_ic9{j9,r9}, coord9{r9}));
IniM9: ∀j9∈cells9(), m9{j9} = ρ_ic9{j9} * V_ic9{j9}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr9: ∀j9∈cells9(), ∀r9∈nodesOfCell9(j9), C9{j9,r9} = 0.5 * perp9(X9{►(r9)} - X9{◄(r9)});
ComputeLjr9: ∀j9∈cells9(), ∀r9∈nodesOfCell9(j9), l9{j9,r9} = norm(C9{j9,r9});
Computeδtj9: ∀j9∈cells9(), δtj9{j9} = 2.0 * V9{j9} / (c9{j9} * ∑{r9∈nodesOfCell9(j9)}(l9{j9,r9}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity9: ∀j9∈cells9(), ρ9{j9} = m9{j9} / V9{j9};
ComputeEOSp9: ∀j9∈cells9(), p9{j9} = (γ9-1.0) * ρ9{j9} * e9{j9};
ComputeInternalEngergy9: ∀j9∈cells9(), e9{j9} = E9{j9} - 0.5 * dot(uj9{j9}, uj9{j9});
ComputeEOSc9: ∀j9∈cells9(), c9{j9} = √(γ9*p9{j9}/ρ9{j9}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr9: ∀j9∈cells9(), ∀r9∈nodesOfCell9(j9), Ajr9{j9,r9} = ((ρ9{j9}*c9{j9})/l9{j9,r9}) * tensProduct9(C9{j9,r9}, C9{j9,r9});
ComputeFjr9: ∀j9∈cells9(), ∀r9∈nodesOfCell9(j9), F9{j9,r9} = p9{j9}*C9{j9,r9} + matVectProduct9(Ajr9{j9,r9}, (uj9{j9}-ur9{r9}));
ComputeAr9: ∀r9∈nodes9(), Ar9{r9} = ∑{j9∈cellsOfNode9(r9)}(Ajr9{j9,r9});
ComputeBr9: ∀r9∈nodes9(), b9{r9} = ∑{j9∈cellsOfNode9(r9)}(p9{j9}*C9{j9,r9} + matVectProduct9(Ajr9{j9,r9}, uj9{j9}));
ComputeMt9: ∀r9∈innerNodes9(), Mt9{r9} = Ar9{r9};
ComputeBt9: ∀r9∈innerNodes9(), bt9{r9} = b9{r9};

OuterFacesComputations9: ∀k9∈outerFaces9(), {
	const ℝ epsilon9 = 1.0e-10;
	ℝ²ˣ² I9 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN9 = 0.0;
	ℝ X_MAX9 = X_EDGE_ELEMS9 * LENGTH9;
	ℝ Y_MIN9 = 0.0; 
	ℝ Y_MAX9 = Y_EDGE_ELEMS9 * LENGTH9;
	ℝ² nY9 = {0.0,1.0};
	
	∀r9∈nodesOfFace9(k9), {
		// Y boundary conditions (must be done before X)
		if ((X9{r9}.y-Y_MIN9 < epsilon9) || (X9{r9}.y-Y_MAX9 < epsilon9)) {
			ℝ sign9 = 0.0;
			if (X9{r9}.y-Y_MIN9 < epsilon9) sign9 = -1.0;
			else sign9 = 1.0;
			ℝ² n9 = sign9 * nY9;
      		ℝ²ˣ² nxn9 = tensProduct9(n9,n9);
      		ℝ²ˣ² IcP9 = I9 - nxn9;
			bt1{r9} = matVectProduct9(IcP9, b9{r9});
			Mt1{r9} = IcP9 * (Ar9{r9} * IcP9) + nxn9*trace9(Ar9{r9});
		}

		// X boundary conditions
		if ((Math.fabs(X9{r9}.x-X_MIN9) < epsilon9) || ( (Math.fabs(X9{r9}.x-X_MAX9) < epsilon9) )) {
			Mt9{r9} = I9;
			bt9{r9} = {0.0, 0.0};
		}
	}
}


ComputeU9: ∀r9∈nodes9(), ur9{r9} = matVectProduct9(inverse9(Mt9{r9}), bt9{r9});
ComputeV9: ∀j9∈cells9(), V9{j9} = 0.5 * ∑{r9∈nodesOfCell9(j9)}(dot(C9{j9,r9},X9{r9}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn9: ∀n9∈ℕ, ∀r09∈nodes9(), X9{r09}^{n9=0}=coord9{r09}; , ∀r9∈nodes9(), X9{r9}^{n9+1}=X9{r9}^{n9}+δt9^{n9}*ur9{r9};
ComputeUn9: ∀n9∈ℕ, ∀j09∈cells9(), uj9{j09}^{n9=0}={0.0,0.0}; , ∀j9∈cells9(), uj9{j9}^{n9+1}=uj9{j9}^{n9}-(δt9^{n9}/m9{j9})*∑{r9∈nodesOfCell9(j9)}(F9{j9,r9});
ComputeEn9: ∀n9∈ℕ, ∀j09∈cells9(), E9{j09}^{n9=0}=p_ic9{j09}/((γ9-1.0)*ρ_ic9{j09}); , ∀j9∈cells9(), E9{j9}^{n9+1}=E9{j9}^{n9} - (δt9^{n9} / m9{j9}) * ∑{r9∈nodesOfCell9(j9)}(dot(F9{j9,r9},ur9{r9}));
ComputeDt9: ∀n9∈ℕ, δt9^{n9=0}=option_δt_ini9;, δt9^{n9+1}=option_δt_cfl9*reduceMin{j9∈cells9()}(δtj9{j9});
ComputeTn9: ∀n9∈ℕ, t9^{n9=0}=0.0; , t9^{n9+1}=t9^{n9}+δt9^{n9+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter10: ∀j10∈cells10(), center10{j10} = (1.0/4.0) * ∑{r10∈nodesOfCell10(j10)}(coord10{r10});
IniIc10: ∀j10∈cells10(), if (center10{j10}.x < option_x_interface10) {
  ρ_ic10{j10}=option_ρ_ini_zg10;
  p_ic10{j10}=option_p_ini_zg10;
} else {
  ρ_ic10{j10}=option_ρ_ini_zd10;
  p_ic10{j10}=option_p_ini_zd10;
}

ComputeCjrIc10: ∀j10∈cells10(), ∀r10∈nodesOfCell10(j10), 
	C_ic10{j10,r10} = 0.5 * perp10(coord10{►(r10)} - coord10{◄(r10)});
IniVIc10: ∀j10∈cells10(), V_ic10{j10} = 0.5 * ∑{r10∈nodesOfCell10(j10)}(dot(C_ic10{j10,r10}, coord10{r10}));
IniM10: ∀j10∈cells10(), m10{j10} = ρ_ic10{j10} * V_ic10{j10}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr10: ∀j10∈cells10(), ∀r10∈nodesOfCell10(j10), C10{j10,r10} = 0.5 * perp10(X10{►(r10)} - X10{◄(r10)});
ComputeLjr10: ∀j10∈cells10(), ∀r10∈nodesOfCell10(j10), l10{j10,r10} = norm(C10{j10,r10});
Computeδtj10: ∀j10∈cells10(), δtj10{j10} = 2.0 * V10{j10} / (c10{j10} * ∑{r10∈nodesOfCell10(j10)}(l10{j10,r10}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity10: ∀j10∈cells10(), ρ10{j10} = m10{j10} / V10{j10};
ComputeEOSp10: ∀j10∈cells10(), p10{j10} = (γ10-1.0) * ρ10{j10} * e10{j10};
ComputeInternalEngergy10: ∀j10∈cells10(), e10{j10} = E10{j10} - 0.5 * dot(uj10{j10}, uj10{j10});
ComputeEOSc10: ∀j10∈cells10(), c10{j10} = √(γ10*p10{j10}/ρ10{j10}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr10: ∀j10∈cells10(), ∀r10∈nodesOfCell10(j10), Ajr10{j10,r10} = ((ρ10{j10}*c10{j10})/l10{j10,r10}) * tensProduct10(C10{j10,r10}, C10{j10,r10});
ComputeFjr10: ∀j10∈cells10(), ∀r10∈nodesOfCell10(j10), F10{j10,r10} = p10{j10}*C10{j10,r10} + matVectProduct10(Ajr10{j10,r10}, (uj10{j10}-ur10{r10}));
ComputeAr10: ∀r10∈nodes10(), Ar10{r10} = ∑{j10∈cellsOfNode10(r10)}(Ajr10{j10,r10});
ComputeBr10: ∀r10∈nodes10(), b10{r10} = ∑{j10∈cellsOfNode10(r10)}(p10{j10}*C10{j10,r10} + matVectProduct10(Ajr10{j10,r10}, uj10{j10}));
ComputeMt10: ∀r10∈innerNodes10(), Mt10{r10} = Ar10{r10};
ComputeBt10: ∀r10∈innerNodes10(), bt10{r10} = b10{r10};

OuterFacesComputations10: ∀k10∈outerFaces10(), {
	const ℝ epsilon10 = 1.0e-10;
	ℝ²ˣ² I10 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN10 = 0.0;
	ℝ X_MAX10 = X_EDGE_ELEMS10 * LENGTH10;
	ℝ Y_MIN10 = 0.0; 
	ℝ Y_MAX10 = Y_EDGE_ELEMS10 * LENGTH10;
	ℝ² nY10 = {0.0,1.0};
	
	∀r10∈nodesOfFace10(k10), {
		// Y boundary conditions (must be done before X)
		if ((X10{r10}.y-Y_MIN10 < epsilon10) || (X10{r10}.y-Y_MAX10 < epsilon10)) {
			ℝ sign10 = 0.0;
			if (X10{r10}.y-Y_MIN10 < epsilon10) sign10 = -1.0;
			else sign10 = 1.0;
			ℝ² n10 = sign10 * nY10;
      		ℝ²ˣ² nxn10 = tensProduct10(n10,n10);
      		ℝ²ˣ² IcP10 = I10 - nxn10;
			bt1{r10} = matVectProduct10(IcP10, b10{r10});
			Mt1{r10} = IcP10 * (Ar10{r10} * IcP10) + nxn10*trace10(Ar10{r10});
		}

		// X boundary conditions
		if ((Math.fabs(X10{r10}.x-X_MIN10) < epsilon10) || ( (Math.fabs(X10{r10}.x-X_MAX10) < epsilon10) )) {
			Mt10{r10} = I10;
			bt10{r10} = {0.0, 0.0};
		}
	}
}


ComputeU10: ∀r10∈nodes10(), ur10{r10} = matVectProduct10(inverse10(Mt10{r10}), bt10{r10});
ComputeV10: ∀j10∈cells10(), V10{j10} = 0.5 * ∑{r10∈nodesOfCell10(j10)}(dot(C10{j10,r10},X10{r10}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn10: ∀n10∈ℕ, ∀r010∈nodes10(), X10{r010}^{n10=0}=coord10{r010}; , ∀r10∈nodes10(), X10{r10}^{n10+1}=X10{r10}^{n10}+δt10^{n10}*ur10{r10};
ComputeUn10: ∀n10∈ℕ, ∀j010∈cells10(), uj10{j010}^{n10=0}={0.0,0.0}; , ∀j10∈cells10(), uj10{j10}^{n10+1}=uj10{j10}^{n10}-(δt10^{n10}/m10{j10})*∑{r10∈nodesOfCell10(j10)}(F10{j10,r10});
ComputeEn10: ∀n10∈ℕ, ∀j010∈cells10(), E10{j010}^{n10=0}=p_ic10{j010}/((γ10-1.0)*ρ_ic10{j010}); , ∀j10∈cells10(), E10{j10}^{n10+1}=E10{j10}^{n10} - (δt10^{n10} / m10{j10}) * ∑{r10∈nodesOfCell10(j10)}(dot(F10{j10,r10},ur10{r10}));
ComputeDt10: ∀n10∈ℕ, δt10^{n10=0}=option_δt_ini10;, δt10^{n10+1}=option_δt_cfl10*reduceMin{j10∈cells10()}(δtj10{j10});
ComputeTn10: ∀n10∈ℕ, t10^{n10=0}=0.0; , t10^{n10+1}=t10^{n10}+δt10^{n10+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter11: ∀j11∈cells11(), center11{j11} = (1.0/4.0) * ∑{r11∈nodesOfCell11(j11)}(coord11{r11});
IniIc11: ∀j11∈cells11(), if (center11{j11}.x < option_x_interface11) {
  ρ_ic11{j11}=option_ρ_ini_zg11;
  p_ic11{j11}=option_p_ini_zg11;
} else {
  ρ_ic11{j11}=option_ρ_ini_zd11;
  p_ic11{j11}=option_p_ini_zd11;
}

ComputeCjrIc11: ∀j11∈cells11(), ∀r11∈nodesOfCell11(j11), 
	C_ic11{j11,r11} = 0.5 * perp11(coord11{►(r11)} - coord11{◄(r11)});
IniVIc11: ∀j11∈cells11(), V_ic11{j11} = 0.5 * ∑{r11∈nodesOfCell11(j11)}(dot(C_ic11{j11,r11}, coord11{r11}));
IniM11: ∀j11∈cells11(), m11{j11} = ρ_ic11{j11} * V_ic11{j11}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr11: ∀j11∈cells11(), ∀r11∈nodesOfCell11(j11), C11{j11,r11} = 0.5 * perp11(X11{►(r11)} - X11{◄(r11)});
ComputeLjr11: ∀j11∈cells11(), ∀r11∈nodesOfCell11(j11), l11{j11,r11} = norm(C11{j11,r11});
Computeδtj11: ∀j11∈cells11(), δtj11{j11} = 2.0 * V11{j11} / (c11{j11} * ∑{r11∈nodesOfCell11(j11)}(l11{j11,r11}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity11: ∀j11∈cells11(), ρ11{j11} = m11{j11} / V11{j11};
ComputeEOSp11: ∀j11∈cells11(), p11{j11} = (γ11-1.0) * ρ11{j11} * e11{j11};
ComputeInternalEngergy11: ∀j11∈cells11(), e11{j11} = E11{j11} - 0.5 * dot(uj11{j11}, uj11{j11});
ComputeEOSc11: ∀j11∈cells11(), c11{j11} = √(γ11*p11{j11}/ρ11{j11}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr11: ∀j11∈cells11(), ∀r11∈nodesOfCell11(j11), Ajr11{j11,r11} = ((ρ11{j11}*c11{j11})/l11{j11,r11}) * tensProduct11(C11{j11,r11}, C11{j11,r11});
ComputeFjr11: ∀j11∈cells11(), ∀r11∈nodesOfCell11(j11), F11{j11,r11} = p11{j11}*C11{j11,r11} + matVectProduct11(Ajr11{j11,r11}, (uj11{j11}-ur11{r11}));
ComputeAr11: ∀r11∈nodes11(), Ar11{r11} = ∑{j11∈cellsOfNode11(r11)}(Ajr11{j11,r11});
ComputeBr11: ∀r11∈nodes11(), b11{r11} = ∑{j11∈cellsOfNode11(r11)}(p11{j11}*C11{j11,r11} + matVectProduct11(Ajr11{j11,r11}, uj11{j11}));
ComputeMt11: ∀r11∈innerNodes11(), Mt11{r11} = Ar11{r11};
ComputeBt11: ∀r11∈innerNodes11(), bt11{r11} = b11{r11};

OuterFacesComputations11: ∀k11∈outerFaces11(), {
	const ℝ epsilon11 = 1.0e-10;
	ℝ²ˣ² I11 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN11 = 0.0;
	ℝ X_MAX11 = X_EDGE_ELEMS11 * LENGTH11;
	ℝ Y_MIN11 = 0.0; 
	ℝ Y_MAX11 = Y_EDGE_ELEMS11 * LENGTH11;
	ℝ² nY11 = {0.0,1.0};
	
	∀r11∈nodesOfFace11(k11), {
		// Y boundary conditions (must be done before X)
		if ((X11{r11}.y-Y_MIN11 < epsilon11) || (X11{r11}.y-Y_MAX11 < epsilon11)) {
			ℝ sign11 = 0.0;
			if (X11{r11}.y-Y_MIN11 < epsilon11) sign11 = -1.0;
			else sign11 = 1.0;
			ℝ² n11 = sign11 * nY11;
      		ℝ²ˣ² nxn11 = tensProduct11(n11,n11);
      		ℝ²ˣ² IcP11 = I11 - nxn11;
			bt1{r11} = matVectProduct11(IcP11, b11{r11});
			Mt1{r11} = IcP11 * (Ar11{r11} * IcP11) + nxn11*trace11(Ar11{r11});
		}

		// X boundary conditions
		if ((Math.fabs(X11{r11}.x-X_MIN11) < epsilon11) || ( (Math.fabs(X11{r11}.x-X_MAX11) < epsilon11) )) {
			Mt11{r11} = I11;
			bt11{r11} = {0.0, 0.0};
		}
	}
}


ComputeU11: ∀r11∈nodes11(), ur11{r11} = matVectProduct11(inverse11(Mt11{r11}), bt11{r11});
ComputeV11: ∀j11∈cells11(), V11{j11} = 0.5 * ∑{r11∈nodesOfCell11(j11)}(dot(C11{j11,r11},X11{r11}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn11: ∀n11∈ℕ, ∀r011∈nodes11(), X11{r011}^{n11=0}=coord11{r011}; , ∀r11∈nodes11(), X11{r11}^{n11+1}=X11{r11}^{n11}+δt11^{n11}*ur11{r11};
ComputeUn11: ∀n11∈ℕ, ∀j011∈cells11(), uj11{j011}^{n11=0}={0.0,0.0}; , ∀j11∈cells11(), uj11{j11}^{n11+1}=uj11{j11}^{n11}-(δt11^{n11}/m11{j11})*∑{r11∈nodesOfCell11(j11)}(F11{j11,r11});
ComputeEn11: ∀n11∈ℕ, ∀j011∈cells11(), E11{j011}^{n11=0}=p_ic11{j011}/((γ11-1.0)*ρ_ic11{j011}); , ∀j11∈cells11(), E11{j11}^{n11+1}=E11{j11}^{n11} - (δt11^{n11} / m11{j11}) * ∑{r11∈nodesOfCell11(j11)}(dot(F11{j11,r11},ur11{r11}));
ComputeDt11: ∀n11∈ℕ, δt11^{n11=0}=option_δt_ini11;, δt11^{n11+1}=option_δt_cfl11*reduceMin{j11∈cells11()}(δtj11{j11});
ComputeTn11: ∀n11∈ℕ, t11^{n11=0}=0.0; , t11^{n11+1}=t11^{n11}+δt11^{n11+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter12: ∀j12∈cells12(), center12{j12} = (1.0/4.0) * ∑{r12∈nodesOfCell12(j12)}(coord12{r12});
IniIc12: ∀j12∈cells12(), if (center12{j12}.x < option_x_interface12) {
  ρ_ic12{j12}=option_ρ_ini_zg12;
  p_ic12{j12}=option_p_ini_zg12;
} else {
  ρ_ic12{j12}=option_ρ_ini_zd12;
  p_ic12{j12}=option_p_ini_zd12;
}

ComputeCjrIc12: ∀j12∈cells12(), ∀r12∈nodesOfCell12(j12), 
	C_ic12{j12,r12} = 0.5 * perp12(coord12{►(r12)} - coord12{◄(r12)});
IniVIc12: ∀j12∈cells12(), V_ic12{j12} = 0.5 * ∑{r12∈nodesOfCell12(j12)}(dot(C_ic12{j12,r12}, coord12{r12}));
IniM12: ∀j12∈cells12(), m12{j12} = ρ_ic12{j12} * V_ic12{j12}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr12: ∀j12∈cells12(), ∀r12∈nodesOfCell12(j12), C12{j12,r12} = 0.5 * perp12(X12{►(r12)} - X12{◄(r12)});
ComputeLjr12: ∀j12∈cells12(), ∀r12∈nodesOfCell12(j12), l12{j12,r12} = norm(C12{j12,r12});
Computeδtj12: ∀j12∈cells12(), δtj12{j12} = 2.0 * V12{j12} / (c12{j12} * ∑{r12∈nodesOfCell12(j12)}(l12{j12,r12}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity12: ∀j12∈cells12(), ρ12{j12} = m12{j12} / V12{j12};
ComputeEOSp12: ∀j12∈cells12(), p12{j12} = (γ12-1.0) * ρ12{j12} * e12{j12};
ComputeInternalEngergy12: ∀j12∈cells12(), e12{j12} = E12{j12} - 0.5 * dot(uj12{j12}, uj12{j12});
ComputeEOSc12: ∀j12∈cells12(), c12{j12} = √(γ12*p12{j12}/ρ12{j12}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr12: ∀j12∈cells12(), ∀r12∈nodesOfCell12(j12), Ajr12{j12,r12} = ((ρ12{j12}*c12{j12})/l12{j12,r12}) * tensProduct12(C12{j12,r12}, C12{j12,r12});
ComputeFjr12: ∀j12∈cells12(), ∀r12∈nodesOfCell12(j12), F12{j12,r12} = p12{j12}*C12{j12,r12} + matVectProduct12(Ajr12{j12,r12}, (uj12{j12}-ur12{r12}));
ComputeAr12: ∀r12∈nodes12(), Ar12{r12} = ∑{j12∈cellsOfNode12(r12)}(Ajr12{j12,r12});
ComputeBr12: ∀r12∈nodes12(), b12{r12} = ∑{j12∈cellsOfNode12(r12)}(p12{j12}*C12{j12,r12} + matVectProduct12(Ajr12{j12,r12}, uj12{j12}));
ComputeMt12: ∀r12∈innerNodes12(), Mt12{r12} = Ar12{r12};
ComputeBt12: ∀r12∈innerNodes12(), bt12{r12} = b12{r12};

OuterFacesComputations12: ∀k12∈outerFaces12(), {
	const ℝ epsilon12 = 1.0e-10;
	ℝ²ˣ² I12 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN12 = 0.0;
	ℝ X_MAX12 = X_EDGE_ELEMS12 * LENGTH12;
	ℝ Y_MIN12 = 0.0; 
	ℝ Y_MAX12 = Y_EDGE_ELEMS12 * LENGTH12;
	ℝ² nY12 = {0.0,1.0};
	
	∀r12∈nodesOfFace12(k12), {
		// Y boundary conditions (must be done before X)
		if ((X12{r12}.y-Y_MIN12 < epsilon12) || (X12{r12}.y-Y_MAX12 < epsilon12)) {
			ℝ sign12 = 0.0;
			if (X12{r12}.y-Y_MIN12 < epsilon12) sign12 = -1.0;
			else sign12 = 1.0;
			ℝ² n12 = sign12 * nY12;
      		ℝ²ˣ² nxn12 = tensProduct12(n12,n12);
      		ℝ²ˣ² IcP12 = I12 - nxn12;
			bt1{r12} = matVectProduct12(IcP12, b12{r12});
			Mt1{r12} = IcP12 * (Ar12{r12} * IcP12) + nxn12*trace12(Ar12{r12});
		}

		// X boundary conditions
		if ((Math.fabs(X12{r12}.x-X_MIN12) < epsilon12) || ( (Math.fabs(X12{r12}.x-X_MAX12) < epsilon12) )) {
			Mt12{r12} = I12;
			bt12{r12} = {0.0, 0.0};
		}
	}
}


ComputeU12: ∀r12∈nodes12(), ur12{r12} = matVectProduct12(inverse12(Mt12{r12}), bt12{r12});
ComputeV12: ∀j12∈cells12(), V12{j12} = 0.5 * ∑{r12∈nodesOfCell12(j12)}(dot(C12{j12,r12},X12{r12}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn12: ∀n12∈ℕ, ∀r012∈nodes12(), X12{r012}^{n12=0}=coord12{r012}; , ∀r12∈nodes12(), X12{r12}^{n12+1}=X12{r12}^{n12}+δt12^{n12}*ur12{r12};
ComputeUn12: ∀n12∈ℕ, ∀j012∈cells12(), uj12{j012}^{n12=0}={0.0,0.0}; , ∀j12∈cells12(), uj12{j12}^{n12+1}=uj12{j12}^{n12}-(δt12^{n12}/m12{j12})*∑{r12∈nodesOfCell12(j12)}(F12{j12,r12});
ComputeEn12: ∀n12∈ℕ, ∀j012∈cells12(), E12{j012}^{n12=0}=p_ic12{j012}/((γ12-1.0)*ρ_ic12{j012}); , ∀j12∈cells12(), E12{j12}^{n12+1}=E12{j12}^{n12} - (δt12^{n12} / m12{j12}) * ∑{r12∈nodesOfCell12(j12)}(dot(F12{j12,r12},ur12{r12}));
ComputeDt12: ∀n12∈ℕ, δt12^{n12=0}=option_δt_ini12;, δt12^{n12+1}=option_δt_cfl12*reduceMin{j12∈cells12()}(δtj12{j12});
ComputeTn12: ∀n12∈ℕ, t12^{n12=0}=0.0; , t12^{n12+1}=t12^{n12}+δt12^{n12+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter13: ∀j13∈cells13(), center13{j13} = (1.0/4.0) * ∑{r13∈nodesOfCell13(j13)}(coord13{r13});
IniIc13: ∀j13∈cells13(), if (center13{j13}.x < option_x_interface13) {
  ρ_ic13{j13}=option_ρ_ini_zg13;
  p_ic13{j13}=option_p_ini_zg13;
} else {
  ρ_ic13{j13}=option_ρ_ini_zd13;
  p_ic13{j13}=option_p_ini_zd13;
}

ComputeCjrIc13: ∀j13∈cells13(), ∀r13∈nodesOfCell13(j13), 
	C_ic13{j13,r13} = 0.5 * perp13(coord13{►(r13)} - coord13{◄(r13)});
IniVIc13: ∀j13∈cells13(), V_ic13{j13} = 0.5 * ∑{r13∈nodesOfCell13(j13)}(dot(C_ic13{j13,r13}, coord13{r13}));
IniM13: ∀j13∈cells13(), m13{j13} = ρ_ic13{j13} * V_ic13{j13}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr13: ∀j13∈cells13(), ∀r13∈nodesOfCell13(j13), C13{j13,r13} = 0.5 * perp13(X13{►(r13)} - X13{◄(r13)});
ComputeLjr13: ∀j13∈cells13(), ∀r13∈nodesOfCell13(j13), l13{j13,r13} = norm(C13{j13,r13});
Computeδtj13: ∀j13∈cells13(), δtj13{j13} = 2.0 * V13{j13} / (c13{j13} * ∑{r13∈nodesOfCell13(j13)}(l13{j13,r13}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity13: ∀j13∈cells13(), ρ13{j13} = m13{j13} / V13{j13};
ComputeEOSp13: ∀j13∈cells13(), p13{j13} = (γ13-1.0) * ρ13{j13} * e13{j13};
ComputeInternalEngergy13: ∀j13∈cells13(), e13{j13} = E13{j13} - 0.5 * dot(uj13{j13}, uj13{j13});
ComputeEOSc13: ∀j13∈cells13(), c13{j13} = √(γ13*p13{j13}/ρ13{j13}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr13: ∀j13∈cells13(), ∀r13∈nodesOfCell13(j13), Ajr13{j13,r13} = ((ρ13{j13}*c13{j13})/l13{j13,r13}) * tensProduct13(C13{j13,r13}, C13{j13,r13});
ComputeFjr13: ∀j13∈cells13(), ∀r13∈nodesOfCell13(j13), F13{j13,r13} = p13{j13}*C13{j13,r13} + matVectProduct13(Ajr13{j13,r13}, (uj13{j13}-ur13{r13}));
ComputeAr13: ∀r13∈nodes13(), Ar13{r13} = ∑{j13∈cellsOfNode13(r13)}(Ajr13{j13,r13});
ComputeBr13: ∀r13∈nodes13(), b13{r13} = ∑{j13∈cellsOfNode13(r13)}(p13{j13}*C13{j13,r13} + matVectProduct13(Ajr13{j13,r13}, uj13{j13}));
ComputeMt13: ∀r13∈innerNodes13(), Mt13{r13} = Ar13{r13};
ComputeBt13: ∀r13∈innerNodes13(), bt13{r13} = b13{r13};

OuterFacesComputations13: ∀k13∈outerFaces13(), {
	const ℝ epsilon13 = 1.0e-10;
	ℝ²ˣ² I13 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN13 = 0.0;
	ℝ X_MAX13 = X_EDGE_ELEMS13 * LENGTH13;
	ℝ Y_MIN13 = 0.0; 
	ℝ Y_MAX13 = Y_EDGE_ELEMS13 * LENGTH13;
	ℝ² nY13 = {0.0,1.0};
	
	∀r13∈nodesOfFace13(k13), {
		// Y boundary conditions (must be done before X)
		if ((X13{r13}.y-Y_MIN13 < epsilon13) || (X13{r13}.y-Y_MAX13 < epsilon13)) {
			ℝ sign13 = 0.0;
			if (X13{r13}.y-Y_MIN13 < epsilon13) sign13 = -1.0;
			else sign13 = 1.0;
			ℝ² n13 = sign13 * nY13;
      		ℝ²ˣ² nxn13 = tensProduct13(n13,n13);
      		ℝ²ˣ² IcP13 = I13 - nxn13;
			bt1{r13} = matVectProduct13(IcP13, b13{r13});
			Mt1{r13} = IcP13 * (Ar13{r13} * IcP13) + nxn13*trace13(Ar13{r13});
		}

		// X boundary conditions
		if ((Math.fabs(X13{r13}.x-X_MIN13) < epsilon13) || ( (Math.fabs(X13{r13}.x-X_MAX13) < epsilon13) )) {
			Mt13{r13} = I13;
			bt13{r13} = {0.0, 0.0};
		}
	}
}


ComputeU13: ∀r13∈nodes13(), ur13{r13} = matVectProduct13(inverse13(Mt13{r13}), bt13{r13});
ComputeV13: ∀j13∈cells13(), V13{j13} = 0.5 * ∑{r13∈nodesOfCell13(j13)}(dot(C13{j13,r13},X13{r13}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn13: ∀n13∈ℕ, ∀r013∈nodes13(), X13{r013}^{n13=0}=coord13{r013}; , ∀r13∈nodes13(), X13{r13}^{n13+1}=X13{r13}^{n13}+δt13^{n13}*ur13{r13};
ComputeUn13: ∀n13∈ℕ, ∀j013∈cells13(), uj13{j013}^{n13=0}={0.0,0.0}; , ∀j13∈cells13(), uj13{j13}^{n13+1}=uj13{j13}^{n13}-(δt13^{n13}/m13{j13})*∑{r13∈nodesOfCell13(j13)}(F13{j13,r13});
ComputeEn13: ∀n13∈ℕ, ∀j013∈cells13(), E13{j013}^{n13=0}=p_ic13{j013}/((γ13-1.0)*ρ_ic13{j013}); , ∀j13∈cells13(), E13{j13}^{n13+1}=E13{j13}^{n13} - (δt13^{n13} / m13{j13}) * ∑{r13∈nodesOfCell13(j13)}(dot(F13{j13,r13},ur13{r13}));
ComputeDt13: ∀n13∈ℕ, δt13^{n13=0}=option_δt_ini13;, δt13^{n13+1}=option_δt_cfl13*reduceMin{j13∈cells13()}(δtj13{j13});
ComputeTn13: ∀n13∈ℕ, t13^{n13=0}=0.0; , t13^{n13+1}=t13^{n13}+δt13^{n13+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter14: ∀j14∈cells14(), center14{j14} = (1.0/4.0) * ∑{r14∈nodesOfCell14(j14)}(coord14{r14});
IniIc14: ∀j14∈cells14(), if (center14{j14}.x < option_x_interface14) {
  ρ_ic14{j14}=option_ρ_ini_zg14;
  p_ic14{j14}=option_p_ini_zg14;
} else {
  ρ_ic14{j14}=option_ρ_ini_zd14;
  p_ic14{j14}=option_p_ini_zd14;
}

ComputeCjrIc14: ∀j14∈cells14(), ∀r14∈nodesOfCell14(j14), 
	C_ic14{j14,r14} = 0.5 * perp14(coord14{►(r14)} - coord14{◄(r14)});
IniVIc14: ∀j14∈cells14(), V_ic14{j14} = 0.5 * ∑{r14∈nodesOfCell14(j14)}(dot(C_ic14{j14,r14}, coord14{r14}));
IniM14: ∀j14∈cells14(), m14{j14} = ρ_ic14{j14} * V_ic14{j14}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr14: ∀j14∈cells14(), ∀r14∈nodesOfCell14(j14), C14{j14,r14} = 0.5 * perp14(X14{►(r14)} - X14{◄(r14)});
ComputeLjr14: ∀j14∈cells14(), ∀r14∈nodesOfCell14(j14), l14{j14,r14} = norm(C14{j14,r14});
Computeδtj14: ∀j14∈cells14(), δtj14{j14} = 2.0 * V14{j14} / (c14{j14} * ∑{r14∈nodesOfCell14(j14)}(l14{j14,r14}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity14: ∀j14∈cells14(), ρ14{j14} = m14{j14} / V14{j14};
ComputeEOSp14: ∀j14∈cells14(), p14{j14} = (γ14-1.0) * ρ14{j14} * e14{j14};
ComputeInternalEngergy14: ∀j14∈cells14(), e14{j14} = E14{j14} - 0.5 * dot(uj14{j14}, uj14{j14});
ComputeEOSc14: ∀j14∈cells14(), c14{j14} = √(γ14*p14{j14}/ρ14{j14}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr14: ∀j14∈cells14(), ∀r14∈nodesOfCell14(j14), Ajr14{j14,r14} = ((ρ14{j14}*c14{j14})/l14{j14,r14}) * tensProduct14(C14{j14,r14}, C14{j14,r14});
ComputeFjr14: ∀j14∈cells14(), ∀r14∈nodesOfCell14(j14), F14{j14,r14} = p14{j14}*C14{j14,r14} + matVectProduct14(Ajr14{j14,r14}, (uj14{j14}-ur14{r14}));
ComputeAr14: ∀r14∈nodes14(), Ar14{r14} = ∑{j14∈cellsOfNode14(r14)}(Ajr14{j14,r14});
ComputeBr14: ∀r14∈nodes14(), b14{r14} = ∑{j14∈cellsOfNode14(r14)}(p14{j14}*C14{j14,r14} + matVectProduct14(Ajr14{j14,r14}, uj14{j14}));
ComputeMt14: ∀r14∈innerNodes14(), Mt14{r14} = Ar14{r14};
ComputeBt14: ∀r14∈innerNodes14(), bt14{r14} = b14{r14};

OuterFacesComputations14: ∀k14∈outerFaces14(), {
	const ℝ epsilon14 = 1.0e-10;
	ℝ²ˣ² I14 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN14 = 0.0;
	ℝ X_MAX14 = X_EDGE_ELEMS14 * LENGTH14;
	ℝ Y_MIN14 = 0.0; 
	ℝ Y_MAX14 = Y_EDGE_ELEMS14 * LENGTH14;
	ℝ² nY14 = {0.0,1.0};
	
	∀r14∈nodesOfFace14(k14), {
		// Y boundary conditions (must be done before X)
		if ((X14{r14}.y-Y_MIN14 < epsilon14) || (X14{r14}.y-Y_MAX14 < epsilon14)) {
			ℝ sign14 = 0.0;
			if (X14{r14}.y-Y_MIN14 < epsilon14) sign14 = -1.0;
			else sign14 = 1.0;
			ℝ² n14 = sign14 * nY14;
      		ℝ²ˣ² nxn14 = tensProduct14(n14,n14);
      		ℝ²ˣ² IcP14 = I14 - nxn14;
			bt1{r14} = matVectProduct14(IcP14, b14{r14});
			Mt1{r14} = IcP14 * (Ar14{r14} * IcP14) + nxn14*trace14(Ar14{r14});
		}

		// X boundary conditions
		if ((Math.fabs(X14{r14}.x-X_MIN14) < epsilon14) || ( (Math.fabs(X14{r14}.x-X_MAX14) < epsilon14) )) {
			Mt14{r14} = I14;
			bt14{r14} = {0.0, 0.0};
		}
	}
}


ComputeU14: ∀r14∈nodes14(), ur14{r14} = matVectProduct14(inverse14(Mt14{r14}), bt14{r14});
ComputeV14: ∀j14∈cells14(), V14{j14} = 0.5 * ∑{r14∈nodesOfCell14(j14)}(dot(C14{j14,r14},X14{r14}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn14: ∀n14∈ℕ, ∀r014∈nodes14(), X14{r014}^{n14=0}=coord14{r014}; , ∀r14∈nodes14(), X14{r14}^{n14+1}=X14{r14}^{n14}+δt14^{n14}*ur14{r14};
ComputeUn14: ∀n14∈ℕ, ∀j014∈cells14(), uj14{j014}^{n14=0}={0.0,0.0}; , ∀j14∈cells14(), uj14{j14}^{n14+1}=uj14{j14}^{n14}-(δt14^{n14}/m14{j14})*∑{r14∈nodesOfCell14(j14)}(F14{j14,r14});
ComputeEn14: ∀n14∈ℕ, ∀j014∈cells14(), E14{j014}^{n14=0}=p_ic14{j014}/((γ14-1.0)*ρ_ic14{j014}); , ∀j14∈cells14(), E14{j14}^{n14+1}=E14{j14}^{n14} - (δt14^{n14} / m14{j14}) * ∑{r14∈nodesOfCell14(j14)}(dot(F14{j14,r14},ur14{r14}));
ComputeDt14: ∀n14∈ℕ, δt14^{n14=0}=option_δt_ini14;, δt14^{n14+1}=option_δt_cfl14*reduceMin{j14∈cells14()}(δtj14{j14});
ComputeTn14: ∀n14∈ℕ, t14^{n14=0}=0.0; , t14^{n14+1}=t14^{n14}+δt14^{n14+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter15: ∀j15∈cells15(), center15{j15} = (1.0/4.0) * ∑{r15∈nodesOfCell15(j15)}(coord15{r15});
IniIc15: ∀j15∈cells15(), if (center15{j15}.x < option_x_interface15) {
  ρ_ic15{j15}=option_ρ_ini_zg15;
  p_ic15{j15}=option_p_ini_zg15;
} else {
  ρ_ic15{j15}=option_ρ_ini_zd15;
  p_ic15{j15}=option_p_ini_zd15;
}

ComputeCjrIc15: ∀j15∈cells15(), ∀r15∈nodesOfCell15(j15), 
	C_ic15{j15,r15} = 0.5 * perp15(coord15{►(r15)} - coord15{◄(r15)});
IniVIc15: ∀j15∈cells15(), V_ic15{j15} = 0.5 * ∑{r15∈nodesOfCell15(j15)}(dot(C_ic15{j15,r15}, coord15{r15}));
IniM15: ∀j15∈cells15(), m15{j15} = ρ_ic15{j15} * V_ic15{j15}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr15: ∀j15∈cells15(), ∀r15∈nodesOfCell15(j15), C15{j15,r15} = 0.5 * perp15(X15{►(r15)} - X15{◄(r15)});
ComputeLjr15: ∀j15∈cells15(), ∀r15∈nodesOfCell15(j15), l15{j15,r15} = norm(C15{j15,r15});
Computeδtj15: ∀j15∈cells15(), δtj15{j15} = 2.0 * V15{j15} / (c15{j15} * ∑{r15∈nodesOfCell15(j15)}(l15{j15,r15}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity15: ∀j15∈cells15(), ρ15{j15} = m15{j15} / V15{j15};
ComputeEOSp15: ∀j15∈cells15(), p15{j15} = (γ15-1.0) * ρ15{j15} * e15{j15};
ComputeInternalEngergy15: ∀j15∈cells15(), e15{j15} = E15{j15} - 0.5 * dot(uj15{j15}, uj15{j15});
ComputeEOSc15: ∀j15∈cells15(), c15{j15} = √(γ15*p15{j15}/ρ15{j15}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr15: ∀j15∈cells15(), ∀r15∈nodesOfCell15(j15), Ajr15{j15,r15} = ((ρ15{j15}*c15{j15})/l15{j15,r15}) * tensProduct15(C15{j15,r15}, C15{j15,r15});
ComputeFjr15: ∀j15∈cells15(), ∀r15∈nodesOfCell15(j15), F15{j15,r15} = p15{j15}*C15{j15,r15} + matVectProduct15(Ajr15{j15,r15}, (uj15{j15}-ur15{r15}));
ComputeAr15: ∀r15∈nodes15(), Ar15{r15} = ∑{j15∈cellsOfNode15(r15)}(Ajr15{j15,r15});
ComputeBr15: ∀r15∈nodes15(), b15{r15} = ∑{j15∈cellsOfNode15(r15)}(p15{j15}*C15{j15,r15} + matVectProduct15(Ajr15{j15,r15}, uj15{j15}));
ComputeMt15: ∀r15∈innerNodes15(), Mt15{r15} = Ar15{r15};
ComputeBt15: ∀r15∈innerNodes15(), bt15{r15} = b15{r15};

OuterFacesComputations15: ∀k15∈outerFaces15(), {
	const ℝ epsilon15 = 1.0e-10;
	ℝ²ˣ² I15 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN15 = 0.0;
	ℝ X_MAX15 = X_EDGE_ELEMS15 * LENGTH15;
	ℝ Y_MIN15 = 0.0; 
	ℝ Y_MAX15 = Y_EDGE_ELEMS15 * LENGTH15;
	ℝ² nY15 = {0.0,1.0};
	
	∀r15∈nodesOfFace15(k15), {
		// Y boundary conditions (must be done before X)
		if ((X15{r15}.y-Y_MIN15 < epsilon15) || (X15{r15}.y-Y_MAX15 < epsilon15)) {
			ℝ sign15 = 0.0;
			if (X15{r15}.y-Y_MIN15 < epsilon15) sign15 = -1.0;
			else sign15 = 1.0;
			ℝ² n15 = sign15 * nY15;
      		ℝ²ˣ² nxn15 = tensProduct15(n15,n15);
      		ℝ²ˣ² IcP15 = I15 - nxn15;
			bt1{r15} = matVectProduct15(IcP15, b15{r15});
			Mt1{r15} = IcP15 * (Ar15{r15} * IcP15) + nxn15*trace15(Ar15{r15});
		}

		// X boundary conditions
		if ((Math.fabs(X15{r15}.x-X_MIN15) < epsilon15) || ( (Math.fabs(X15{r15}.x-X_MAX15) < epsilon15) )) {
			Mt15{r15} = I15;
			bt15{r15} = {0.0, 0.0};
		}
	}
}


ComputeU15: ∀r15∈nodes15(), ur15{r15} = matVectProduct15(inverse15(Mt15{r15}), bt15{r15});
ComputeV15: ∀j15∈cells15(), V15{j15} = 0.5 * ∑{r15∈nodesOfCell15(j15)}(dot(C15{j15,r15},X15{r15}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn15: ∀n15∈ℕ, ∀r015∈nodes15(), X15{r015}^{n15=0}=coord15{r015}; , ∀r15∈nodes15(), X15{r15}^{n15+1}=X15{r15}^{n15}+δt15^{n15}*ur15{r15};
ComputeUn15: ∀n15∈ℕ, ∀j015∈cells15(), uj15{j015}^{n15=0}={0.0,0.0}; , ∀j15∈cells15(), uj15{j15}^{n15+1}=uj15{j15}^{n15}-(δt15^{n15}/m15{j15})*∑{r15∈nodesOfCell15(j15)}(F15{j15,r15});
ComputeEn15: ∀n15∈ℕ, ∀j015∈cells15(), E15{j015}^{n15=0}=p_ic15{j015}/((γ15-1.0)*ρ_ic15{j015}); , ∀j15∈cells15(), E15{j15}^{n15+1}=E15{j15}^{n15} - (δt15^{n15} / m15{j15}) * ∑{r15∈nodesOfCell15(j15)}(dot(F15{j15,r15},ur15{r15}));
ComputeDt15: ∀n15∈ℕ, δt15^{n15=0}=option_δt_ini15;, δt15^{n15+1}=option_δt_cfl15*reduceMin{j15∈cells15()}(δtj15{j15});
ComputeTn15: ∀n15∈ℕ, t15^{n15=0}=0.0; , t15^{n15+1}=t15^{n15}+δt15^{n15+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter16: ∀j16∈cells16(), center16{j16} = (1.0/4.0) * ∑{r16∈nodesOfCell16(j16)}(coord16{r16});
IniIc16: ∀j16∈cells16(), if (center16{j16}.x < option_x_interface16) {
  ρ_ic16{j16}=option_ρ_ini_zg16;
  p_ic16{j16}=option_p_ini_zg16;
} else {
  ρ_ic16{j16}=option_ρ_ini_zd16;
  p_ic16{j16}=option_p_ini_zd16;
}

ComputeCjrIc16: ∀j16∈cells16(), ∀r16∈nodesOfCell16(j16), 
	C_ic16{j16,r16} = 0.5 * perp16(coord16{►(r16)} - coord16{◄(r16)});
IniVIc16: ∀j16∈cells16(), V_ic16{j16} = 0.5 * ∑{r16∈nodesOfCell16(j16)}(dot(C_ic16{j16,r16}, coord16{r16}));
IniM16: ∀j16∈cells16(), m16{j16} = ρ_ic16{j16} * V_ic16{j16}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr16: ∀j16∈cells16(), ∀r16∈nodesOfCell16(j16), C16{j16,r16} = 0.5 * perp16(X16{►(r16)} - X16{◄(r16)});
ComputeLjr16: ∀j16∈cells16(), ∀r16∈nodesOfCell16(j16), l16{j16,r16} = norm(C16{j16,r16});
Computeδtj16: ∀j16∈cells16(), δtj16{j16} = 2.0 * V16{j16} / (c16{j16} * ∑{r16∈nodesOfCell16(j16)}(l16{j16,r16}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity16: ∀j16∈cells16(), ρ16{j16} = m16{j16} / V16{j16};
ComputeEOSp16: ∀j16∈cells16(), p16{j16} = (γ16-1.0) * ρ16{j16} * e16{j16};
ComputeInternalEngergy16: ∀j16∈cells16(), e16{j16} = E16{j16} - 0.5 * dot(uj16{j16}, uj16{j16});
ComputeEOSc16: ∀j16∈cells16(), c16{j16} = √(γ16*p16{j16}/ρ16{j16}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr16: ∀j16∈cells16(), ∀r16∈nodesOfCell16(j16), Ajr16{j16,r16} = ((ρ16{j16}*c16{j16})/l16{j16,r16}) * tensProduct16(C16{j16,r16}, C16{j16,r16});
ComputeFjr16: ∀j16∈cells16(), ∀r16∈nodesOfCell16(j16), F16{j16,r16} = p16{j16}*C16{j16,r16} + matVectProduct16(Ajr16{j16,r16}, (uj16{j16}-ur16{r16}));
ComputeAr16: ∀r16∈nodes16(), Ar16{r16} = ∑{j16∈cellsOfNode16(r16)}(Ajr16{j16,r16});
ComputeBr16: ∀r16∈nodes16(), b16{r16} = ∑{j16∈cellsOfNode16(r16)}(p16{j16}*C16{j16,r16} + matVectProduct16(Ajr16{j16,r16}, uj16{j16}));
ComputeMt16: ∀r16∈innerNodes16(), Mt16{r16} = Ar16{r16};
ComputeBt16: ∀r16∈innerNodes16(), bt16{r16} = b16{r16};

OuterFacesComputations16: ∀k16∈outerFaces16(), {
	const ℝ epsilon16 = 1.0e-10;
	ℝ²ˣ² I16 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN16 = 0.0;
	ℝ X_MAX16 = X_EDGE_ELEMS16 * LENGTH16;
	ℝ Y_MIN16 = 0.0; 
	ℝ Y_MAX16 = Y_EDGE_ELEMS16 * LENGTH16;
	ℝ² nY16 = {0.0,1.0};
	
	∀r16∈nodesOfFace16(k16), {
		// Y boundary conditions (must be done before X)
		if ((X16{r16}.y-Y_MIN16 < epsilon16) || (X16{r16}.y-Y_MAX16 < epsilon16)) {
			ℝ sign16 = 0.0;
			if (X16{r16}.y-Y_MIN16 < epsilon16) sign16 = -1.0;
			else sign16 = 1.0;
			ℝ² n16 = sign16 * nY16;
      		ℝ²ˣ² nxn16 = tensProduct16(n16,n16);
      		ℝ²ˣ² IcP16 = I16 - nxn16;
			bt1{r16} = matVectProduct16(IcP16, b16{r16});
			Mt1{r16} = IcP16 * (Ar16{r16} * IcP16) + nxn16*trace16(Ar16{r16});
		}

		// X boundary conditions
		if ((Math.fabs(X16{r16}.x-X_MIN16) < epsilon16) || ( (Math.fabs(X16{r16}.x-X_MAX16) < epsilon16) )) {
			Mt16{r16} = I16;
			bt16{r16} = {0.0, 0.0};
		}
	}
}


ComputeU16: ∀r16∈nodes16(), ur16{r16} = matVectProduct16(inverse16(Mt16{r16}), bt16{r16});
ComputeV16: ∀j16∈cells16(), V16{j16} = 0.5 * ∑{r16∈nodesOfCell16(j16)}(dot(C16{j16,r16},X16{r16}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn16: ∀n16∈ℕ, ∀r016∈nodes16(), X16{r016}^{n16=0}=coord16{r016}; , ∀r16∈nodes16(), X16{r16}^{n16+1}=X16{r16}^{n16}+δt16^{n16}*ur16{r16};
ComputeUn16: ∀n16∈ℕ, ∀j016∈cells16(), uj16{j016}^{n16=0}={0.0,0.0}; , ∀j16∈cells16(), uj16{j16}^{n16+1}=uj16{j16}^{n16}-(δt16^{n16}/m16{j16})*∑{r16∈nodesOfCell16(j16)}(F16{j16,r16});
ComputeEn16: ∀n16∈ℕ, ∀j016∈cells16(), E16{j016}^{n16=0}=p_ic16{j016}/((γ16-1.0)*ρ_ic16{j016}); , ∀j16∈cells16(), E16{j16}^{n16+1}=E16{j16}^{n16} - (δt16^{n16} / m16{j16}) * ∑{r16∈nodesOfCell16(j16)}(dot(F16{j16,r16},ur16{r16}));
ComputeDt16: ∀n16∈ℕ, δt16^{n16=0}=option_δt_ini16;, δt16^{n16+1}=option_δt_cfl16*reduceMin{j16∈cells16()}(δtj16{j16});
ComputeTn16: ∀n16∈ℕ, t16^{n16=0}=0.0; , t16^{n16+1}=t16^{n16}+δt16^{n16+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter17: ∀j17∈cells17(), center17{j17} = (1.0/4.0) * ∑{r17∈nodesOfCell17(j17)}(coord17{r17});
IniIc17: ∀j17∈cells17(), if (center17{j17}.x < option_x_interface17) {
  ρ_ic17{j17}=option_ρ_ini_zg17;
  p_ic17{j17}=option_p_ini_zg17;
} else {
  ρ_ic17{j17}=option_ρ_ini_zd17;
  p_ic17{j17}=option_p_ini_zd17;
}

ComputeCjrIc17: ∀j17∈cells17(), ∀r17∈nodesOfCell17(j17), 
	C_ic17{j17,r17} = 0.5 * perp17(coord17{►(r17)} - coord17{◄(r17)});
IniVIc17: ∀j17∈cells17(), V_ic17{j17} = 0.5 * ∑{r17∈nodesOfCell17(j17)}(dot(C_ic17{j17,r17}, coord17{r17}));
IniM17: ∀j17∈cells17(), m17{j17} = ρ_ic17{j17} * V_ic17{j17}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr17: ∀j17∈cells17(), ∀r17∈nodesOfCell17(j17), C17{j17,r17} = 0.5 * perp17(X17{►(r17)} - X17{◄(r17)});
ComputeLjr17: ∀j17∈cells17(), ∀r17∈nodesOfCell17(j17), l17{j17,r17} = norm(C17{j17,r17});
Computeδtj17: ∀j17∈cells17(), δtj17{j17} = 2.0 * V17{j17} / (c17{j17} * ∑{r17∈nodesOfCell17(j17)}(l17{j17,r17}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity17: ∀j17∈cells17(), ρ17{j17} = m17{j17} / V17{j17};
ComputeEOSp17: ∀j17∈cells17(), p17{j17} = (γ17-1.0) * ρ17{j17} * e17{j17};
ComputeInternalEngergy17: ∀j17∈cells17(), e17{j17} = E17{j17} - 0.5 * dot(uj17{j17}, uj17{j17});
ComputeEOSc17: ∀j17∈cells17(), c17{j17} = √(γ17*p17{j17}/ρ17{j17}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr17: ∀j17∈cells17(), ∀r17∈nodesOfCell17(j17), Ajr17{j17,r17} = ((ρ17{j17}*c17{j17})/l17{j17,r17}) * tensProduct17(C17{j17,r17}, C17{j17,r17});
ComputeFjr17: ∀j17∈cells17(), ∀r17∈nodesOfCell17(j17), F17{j17,r17} = p17{j17}*C17{j17,r17} + matVectProduct17(Ajr17{j17,r17}, (uj17{j17}-ur17{r17}));
ComputeAr17: ∀r17∈nodes17(), Ar17{r17} = ∑{j17∈cellsOfNode17(r17)}(Ajr17{j17,r17});
ComputeBr17: ∀r17∈nodes17(), b17{r17} = ∑{j17∈cellsOfNode17(r17)}(p17{j17}*C17{j17,r17} + matVectProduct17(Ajr17{j17,r17}, uj17{j17}));
ComputeMt17: ∀r17∈innerNodes17(), Mt17{r17} = Ar17{r17};
ComputeBt17: ∀r17∈innerNodes17(), bt17{r17} = b17{r17};

OuterFacesComputations17: ∀k17∈outerFaces17(), {
	const ℝ epsilon17 = 1.0e-10;
	ℝ²ˣ² I17 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN17 = 0.0;
	ℝ X_MAX17 = X_EDGE_ELEMS17 * LENGTH17;
	ℝ Y_MIN17 = 0.0; 
	ℝ Y_MAX17 = Y_EDGE_ELEMS17 * LENGTH17;
	ℝ² nY17 = {0.0,1.0};
	
	∀r17∈nodesOfFace17(k17), {
		// Y boundary conditions (must be done before X)
		if ((X17{r17}.y-Y_MIN17 < epsilon17) || (X17{r17}.y-Y_MAX17 < epsilon17)) {
			ℝ sign17 = 0.0;
			if (X17{r17}.y-Y_MIN17 < epsilon17) sign17 = -1.0;
			else sign17 = 1.0;
			ℝ² n17 = sign17 * nY17;
      		ℝ²ˣ² nxn17 = tensProduct17(n17,n17);
      		ℝ²ˣ² IcP17 = I17 - nxn17;
			bt1{r17} = matVectProduct17(IcP17, b17{r17});
			Mt1{r17} = IcP17 * (Ar17{r17} * IcP17) + nxn17*trace17(Ar17{r17});
		}

		// X boundary conditions
		if ((Math.fabs(X17{r17}.x-X_MIN17) < epsilon17) || ( (Math.fabs(X17{r17}.x-X_MAX17) < epsilon17) )) {
			Mt17{r17} = I17;
			bt17{r17} = {0.0, 0.0};
		}
	}
}


ComputeU17: ∀r17∈nodes17(), ur17{r17} = matVectProduct17(inverse17(Mt17{r17}), bt17{r17});
ComputeV17: ∀j17∈cells17(), V17{j17} = 0.5 * ∑{r17∈nodesOfCell17(j17)}(dot(C17{j17,r17},X17{r17}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn17: ∀n17∈ℕ, ∀r017∈nodes17(), X17{r017}^{n17=0}=coord17{r017}; , ∀r17∈nodes17(), X17{r17}^{n17+1}=X17{r17}^{n17}+δt17^{n17}*ur17{r17};
ComputeUn17: ∀n17∈ℕ, ∀j017∈cells17(), uj17{j017}^{n17=0}={0.0,0.0}; , ∀j17∈cells17(), uj17{j17}^{n17+1}=uj17{j17}^{n17}-(δt17^{n17}/m17{j17})*∑{r17∈nodesOfCell17(j17)}(F17{j17,r17});
ComputeEn17: ∀n17∈ℕ, ∀j017∈cells17(), E17{j017}^{n17=0}=p_ic17{j017}/((γ17-1.0)*ρ_ic17{j017}); , ∀j17∈cells17(), E17{j17}^{n17+1}=E17{j17}^{n17} - (δt17^{n17} / m17{j17}) * ∑{r17∈nodesOfCell17(j17)}(dot(F17{j17,r17},ur17{r17}));
ComputeDt17: ∀n17∈ℕ, δt17^{n17=0}=option_δt_ini17;, δt17^{n17+1}=option_δt_cfl17*reduceMin{j17∈cells17()}(δtj17{j17});
ComputeTn17: ∀n17∈ℕ, t17^{n17=0}=0.0; , t17^{n17+1}=t17^{n17}+δt17^{n17+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter18: ∀j18∈cells18(), center18{j18} = (1.0/4.0) * ∑{r18∈nodesOfCell18(j18)}(coord18{r18});
IniIc18: ∀j18∈cells18(), if (center18{j18}.x < option_x_interface18) {
  ρ_ic18{j18}=option_ρ_ini_zg18;
  p_ic18{j18}=option_p_ini_zg18;
} else {
  ρ_ic18{j18}=option_ρ_ini_zd18;
  p_ic18{j18}=option_p_ini_zd18;
}

ComputeCjrIc18: ∀j18∈cells18(), ∀r18∈nodesOfCell18(j18), 
	C_ic18{j18,r18} = 0.5 * perp18(coord18{►(r18)} - coord18{◄(r18)});
IniVIc18: ∀j18∈cells18(), V_ic18{j18} = 0.5 * ∑{r18∈nodesOfCell18(j18)}(dot(C_ic18{j18,r18}, coord18{r18}));
IniM18: ∀j18∈cells18(), m18{j18} = ρ_ic18{j18} * V_ic18{j18}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr18: ∀j18∈cells18(), ∀r18∈nodesOfCell18(j18), C18{j18,r18} = 0.5 * perp18(X18{►(r18)} - X18{◄(r18)});
ComputeLjr18: ∀j18∈cells18(), ∀r18∈nodesOfCell18(j18), l18{j18,r18} = norm(C18{j18,r18});
Computeδtj18: ∀j18∈cells18(), δtj18{j18} = 2.0 * V18{j18} / (c18{j18} * ∑{r18∈nodesOfCell18(j18)}(l18{j18,r18}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity18: ∀j18∈cells18(), ρ18{j18} = m18{j18} / V18{j18};
ComputeEOSp18: ∀j18∈cells18(), p18{j18} = (γ18-1.0) * ρ18{j18} * e18{j18};
ComputeInternalEngergy18: ∀j18∈cells18(), e18{j18} = E18{j18} - 0.5 * dot(uj18{j18}, uj18{j18});
ComputeEOSc18: ∀j18∈cells18(), c18{j18} = √(γ18*p18{j18}/ρ18{j18}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr18: ∀j18∈cells18(), ∀r18∈nodesOfCell18(j18), Ajr18{j18,r18} = ((ρ18{j18}*c18{j18})/l18{j18,r18}) * tensProduct18(C18{j18,r18}, C18{j18,r18});
ComputeFjr18: ∀j18∈cells18(), ∀r18∈nodesOfCell18(j18), F18{j18,r18} = p18{j18}*C18{j18,r18} + matVectProduct18(Ajr18{j18,r18}, (uj18{j18}-ur18{r18}));
ComputeAr18: ∀r18∈nodes18(), Ar18{r18} = ∑{j18∈cellsOfNode18(r18)}(Ajr18{j18,r18});
ComputeBr18: ∀r18∈nodes18(), b18{r18} = ∑{j18∈cellsOfNode18(r18)}(p18{j18}*C18{j18,r18} + matVectProduct18(Ajr18{j18,r18}, uj18{j18}));
ComputeMt18: ∀r18∈innerNodes18(), Mt18{r18} = Ar18{r18};
ComputeBt18: ∀r18∈innerNodes18(), bt18{r18} = b18{r18};

OuterFacesComputations18: ∀k18∈outerFaces18(), {
	const ℝ epsilon18 = 1.0e-10;
	ℝ²ˣ² I18 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN18 = 0.0;
	ℝ X_MAX18 = X_EDGE_ELEMS18 * LENGTH18;
	ℝ Y_MIN18 = 0.0; 
	ℝ Y_MAX18 = Y_EDGE_ELEMS18 * LENGTH18;
	ℝ² nY18 = {0.0,1.0};
	
	∀r18∈nodesOfFace18(k18), {
		// Y boundary conditions (must be done before X)
		if ((X18{r18}.y-Y_MIN18 < epsilon18) || (X18{r18}.y-Y_MAX18 < epsilon18)) {
			ℝ sign18 = 0.0;
			if (X18{r18}.y-Y_MIN18 < epsilon18) sign18 = -1.0;
			else sign18 = 1.0;
			ℝ² n18 = sign18 * nY18;
      		ℝ²ˣ² nxn18 = tensProduct18(n18,n18);
      		ℝ²ˣ² IcP18 = I18 - nxn18;
			bt1{r18} = matVectProduct18(IcP18, b18{r18});
			Mt1{r18} = IcP18 * (Ar18{r18} * IcP18) + nxn18*trace18(Ar18{r18});
		}

		// X boundary conditions
		if ((Math.fabs(X18{r18}.x-X_MIN18) < epsilon18) || ( (Math.fabs(X18{r18}.x-X_MAX18) < epsilon18) )) {
			Mt18{r18} = I18;
			bt18{r18} = {0.0, 0.0};
		}
	}
}


ComputeU18: ∀r18∈nodes18(), ur18{r18} = matVectProduct18(inverse18(Mt18{r18}), bt18{r18});
ComputeV18: ∀j18∈cells18(), V18{j18} = 0.5 * ∑{r18∈nodesOfCell18(j18)}(dot(C18{j18,r18},X18{r18}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn18: ∀n18∈ℕ, ∀r018∈nodes18(), X18{r018}^{n18=0}=coord18{r018}; , ∀r18∈nodes18(), X18{r18}^{n18+1}=X18{r18}^{n18}+δt18^{n18}*ur18{r18};
ComputeUn18: ∀n18∈ℕ, ∀j018∈cells18(), uj18{j018}^{n18=0}={0.0,0.0}; , ∀j18∈cells18(), uj18{j18}^{n18+1}=uj18{j18}^{n18}-(δt18^{n18}/m18{j18})*∑{r18∈nodesOfCell18(j18)}(F18{j18,r18});
ComputeEn18: ∀n18∈ℕ, ∀j018∈cells18(), E18{j018}^{n18=0}=p_ic18{j018}/((γ18-1.0)*ρ_ic18{j018}); , ∀j18∈cells18(), E18{j18}^{n18+1}=E18{j18}^{n18} - (δt18^{n18} / m18{j18}) * ∑{r18∈nodesOfCell18(j18)}(dot(F18{j18,r18},ur18{r18}));
ComputeDt18: ∀n18∈ℕ, δt18^{n18=0}=option_δt_ini18;, δt18^{n18+1}=option_δt_cfl18*reduceMin{j18∈cells18()}(δtj18{j18});
ComputeTn18: ∀n18∈ℕ, t18^{n18=0}=0.0; , t18^{n18+1}=t18^{n18}+δt18^{n18+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter19: ∀j19∈cells19(), center19{j19} = (1.0/4.0) * ∑{r19∈nodesOfCell19(j19)}(coord19{r19});
IniIc19: ∀j19∈cells19(), if (center19{j19}.x < option_x_interface19) {
  ρ_ic19{j19}=option_ρ_ini_zg19;
  p_ic19{j19}=option_p_ini_zg19;
} else {
  ρ_ic19{j19}=option_ρ_ini_zd19;
  p_ic19{j19}=option_p_ini_zd19;
}

ComputeCjrIc19: ∀j19∈cells19(), ∀r19∈nodesOfCell19(j19), 
	C_ic19{j19,r19} = 0.5 * perp19(coord19{►(r19)} - coord19{◄(r19)});
IniVIc19: ∀j19∈cells19(), V_ic19{j19} = 0.5 * ∑{r19∈nodesOfCell19(j19)}(dot(C_ic19{j19,r19}, coord19{r19}));
IniM19: ∀j19∈cells19(), m19{j19} = ρ_ic19{j19} * V_ic19{j19}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr19: ∀j19∈cells19(), ∀r19∈nodesOfCell19(j19), C19{j19,r19} = 0.5 * perp19(X19{►(r19)} - X19{◄(r19)});
ComputeLjr19: ∀j19∈cells19(), ∀r19∈nodesOfCell19(j19), l19{j19,r19} = norm(C19{j19,r19});
Computeδtj19: ∀j19∈cells19(), δtj19{j19} = 2.0 * V19{j19} / (c19{j19} * ∑{r19∈nodesOfCell19(j19)}(l19{j19,r19}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity19: ∀j19∈cells19(), ρ19{j19} = m19{j19} / V19{j19};
ComputeEOSp19: ∀j19∈cells19(), p19{j19} = (γ19-1.0) * ρ19{j19} * e19{j19};
ComputeInternalEngergy19: ∀j19∈cells19(), e19{j19} = E19{j19} - 0.5 * dot(uj19{j19}, uj19{j19});
ComputeEOSc19: ∀j19∈cells19(), c19{j19} = √(γ19*p19{j19}/ρ19{j19}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr19: ∀j19∈cells19(), ∀r19∈nodesOfCell19(j19), Ajr19{j19,r19} = ((ρ19{j19}*c19{j19})/l19{j19,r19}) * tensProduct19(C19{j19,r19}, C19{j19,r19});
ComputeFjr19: ∀j19∈cells19(), ∀r19∈nodesOfCell19(j19), F19{j19,r19} = p19{j19}*C19{j19,r19} + matVectProduct19(Ajr19{j19,r19}, (uj19{j19}-ur19{r19}));
ComputeAr19: ∀r19∈nodes19(), Ar19{r19} = ∑{j19∈cellsOfNode19(r19)}(Ajr19{j19,r19});
ComputeBr19: ∀r19∈nodes19(), b19{r19} = ∑{j19∈cellsOfNode19(r19)}(p19{j19}*C19{j19,r19} + matVectProduct19(Ajr19{j19,r19}, uj19{j19}));
ComputeMt19: ∀r19∈innerNodes19(), Mt19{r19} = Ar19{r19};
ComputeBt19: ∀r19∈innerNodes19(), bt19{r19} = b19{r19};

OuterFacesComputations19: ∀k19∈outerFaces19(), {
	const ℝ epsilon19 = 1.0e-10;
	ℝ²ˣ² I19 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN19 = 0.0;
	ℝ X_MAX19 = X_EDGE_ELEMS19 * LENGTH19;
	ℝ Y_MIN19 = 0.0; 
	ℝ Y_MAX19 = Y_EDGE_ELEMS19 * LENGTH19;
	ℝ² nY19 = {0.0,1.0};
	
	∀r19∈nodesOfFace19(k19), {
		// Y boundary conditions (must be done before X)
		if ((X19{r19}.y-Y_MIN19 < epsilon19) || (X19{r19}.y-Y_MAX19 < epsilon19)) {
			ℝ sign19 = 0.0;
			if (X19{r19}.y-Y_MIN19 < epsilon19) sign19 = -1.0;
			else sign19 = 1.0;
			ℝ² n19 = sign19 * nY19;
      		ℝ²ˣ² nxn19 = tensProduct19(n19,n19);
      		ℝ²ˣ² IcP19 = I19 - nxn19;
			bt1{r19} = matVectProduct19(IcP19, b19{r19});
			Mt1{r19} = IcP19 * (Ar19{r19} * IcP19) + nxn19*trace19(Ar19{r19});
		}

		// X boundary conditions
		if ((Math.fabs(X19{r19}.x-X_MIN19) < epsilon19) || ( (Math.fabs(X19{r19}.x-X_MAX19) < epsilon19) )) {
			Mt19{r19} = I19;
			bt19{r19} = {0.0, 0.0};
		}
	}
}


ComputeU19: ∀r19∈nodes19(), ur19{r19} = matVectProduct19(inverse19(Mt19{r19}), bt19{r19});
ComputeV19: ∀j19∈cells19(), V19{j19} = 0.5 * ∑{r19∈nodesOfCell19(j19)}(dot(C19{j19,r19},X19{r19}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn19: ∀n19∈ℕ, ∀r019∈nodes19(), X19{r019}^{n19=0}=coord19{r019}; , ∀r19∈nodes19(), X19{r19}^{n19+1}=X19{r19}^{n19}+δt19^{n19}*ur19{r19};
ComputeUn19: ∀n19∈ℕ, ∀j019∈cells19(), uj19{j019}^{n19=0}={0.0,0.0}; , ∀j19∈cells19(), uj19{j19}^{n19+1}=uj19{j19}^{n19}-(δt19^{n19}/m19{j19})*∑{r19∈nodesOfCell19(j19)}(F19{j19,r19});
ComputeEn19: ∀n19∈ℕ, ∀j019∈cells19(), E19{j019}^{n19=0}=p_ic19{j019}/((γ19-1.0)*ρ_ic19{j019}); , ∀j19∈cells19(), E19{j19}^{n19+1}=E19{j19}^{n19} - (δt19^{n19} / m19{j19}) * ∑{r19∈nodesOfCell19(j19)}(dot(F19{j19,r19},ur19{r19}));
ComputeDt19: ∀n19∈ℕ, δt19^{n19=0}=option_δt_ini19;, δt19^{n19+1}=option_δt_cfl19*reduceMin{j19∈cells19()}(δtj19{j19});
ComputeTn19: ∀n19∈ℕ, t19^{n19=0}=0.0; , t19^{n19+1}=t19^{n19}+δt19^{n19+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter20: ∀j20∈cells20(), center20{j20} = (1.0/4.0) * ∑{r20∈nodesOfCell20(j20)}(coord20{r20});
IniIc20: ∀j20∈cells20(), if (center20{j20}.x < option_x_interface20) {
  ρ_ic20{j20}=option_ρ_ini_zg20;
  p_ic20{j20}=option_p_ini_zg20;
} else {
  ρ_ic20{j20}=option_ρ_ini_zd20;
  p_ic20{j20}=option_p_ini_zd20;
}

ComputeCjrIc20: ∀j20∈cells20(), ∀r20∈nodesOfCell20(j20), 
	C_ic20{j20,r20} = 0.5 * perp20(coord20{►(r20)} - coord20{◄(r20)});
IniVIc20: ∀j20∈cells20(), V_ic20{j20} = 0.5 * ∑{r20∈nodesOfCell20(j20)}(dot(C_ic20{j20,r20}, coord20{r20}));
IniM20: ∀j20∈cells20(), m20{j20} = ρ_ic20{j20} * V_ic20{j20}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr20: ∀j20∈cells20(), ∀r20∈nodesOfCell20(j20), C20{j20,r20} = 0.5 * perp20(X20{►(r20)} - X20{◄(r20)});
ComputeLjr20: ∀j20∈cells20(), ∀r20∈nodesOfCell20(j20), l20{j20,r20} = norm(C20{j20,r20});
Computeδtj20: ∀j20∈cells20(), δtj20{j20} = 2.0 * V20{j20} / (c20{j20} * ∑{r20∈nodesOfCell20(j20)}(l20{j20,r20}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity20: ∀j20∈cells20(), ρ20{j20} = m20{j20} / V20{j20};
ComputeEOSp20: ∀j20∈cells20(), p20{j20} = (γ20-1.0) * ρ20{j20} * e20{j20};
ComputeInternalEngergy20: ∀j20∈cells20(), e20{j20} = E20{j20} - 0.5 * dot(uj20{j20}, uj20{j20});
ComputeEOSc20: ∀j20∈cells20(), c20{j20} = √(γ20*p20{j20}/ρ20{j20}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr20: ∀j20∈cells20(), ∀r20∈nodesOfCell20(j20), Ajr20{j20,r20} = ((ρ20{j20}*c20{j20})/l20{j20,r20}) * tensProduct20(C20{j20,r20}, C20{j20,r20});
ComputeFjr20: ∀j20∈cells20(), ∀r20∈nodesOfCell20(j20), F20{j20,r20} = p20{j20}*C20{j20,r20} + matVectProduct20(Ajr20{j20,r20}, (uj20{j20}-ur20{r20}));
ComputeAr20: ∀r20∈nodes20(), Ar20{r20} = ∑{j20∈cellsOfNode20(r20)}(Ajr20{j20,r20});
ComputeBr20: ∀r20∈nodes20(), b20{r20} = ∑{j20∈cellsOfNode20(r20)}(p20{j20}*C20{j20,r20} + matVectProduct20(Ajr20{j20,r20}, uj20{j20}));
ComputeMt20: ∀r20∈innerNodes20(), Mt20{r20} = Ar20{r20};
ComputeBt20: ∀r20∈innerNodes20(), bt20{r20} = b20{r20};

OuterFacesComputations20: ∀k20∈outerFaces20(), {
	const ℝ epsilon20 = 1.0e-10;
	ℝ²ˣ² I20 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN20 = 0.0;
	ℝ X_MAX20 = X_EDGE_ELEMS20 * LENGTH20;
	ℝ Y_MIN20 = 0.0; 
	ℝ Y_MAX20 = Y_EDGE_ELEMS20 * LENGTH20;
	ℝ² nY20 = {0.0,1.0};
	
	∀r20∈nodesOfFace20(k20), {
		// Y boundary conditions (must be done before X)
		if ((X20{r20}.y-Y_MIN20 < epsilon20) || (X20{r20}.y-Y_MAX20 < epsilon20)) {
			ℝ sign20 = 0.0;
			if (X20{r20}.y-Y_MIN20 < epsilon20) sign20 = -1.0;
			else sign20 = 1.0;
			ℝ² n20 = sign20 * nY20;
      		ℝ²ˣ² nxn20 = tensProduct20(n20,n20);
      		ℝ²ˣ² IcP20 = I20 - nxn20;
			bt1{r20} = matVectProduct20(IcP20, b20{r20});
			Mt1{r20} = IcP20 * (Ar20{r20} * IcP20) + nxn20*trace20(Ar20{r20});
		}

		// X boundary conditions
		if ((Math.fabs(X20{r20}.x-X_MIN20) < epsilon20) || ( (Math.fabs(X20{r20}.x-X_MAX20) < epsilon20) )) {
			Mt20{r20} = I20;
			bt20{r20} = {0.0, 0.0};
		}
	}
}


ComputeU20: ∀r20∈nodes20(), ur20{r20} = matVectProduct20(inverse20(Mt20{r20}), bt20{r20});
ComputeV20: ∀j20∈cells20(), V20{j20} = 0.5 * ∑{r20∈nodesOfCell20(j20)}(dot(C20{j20,r20},X20{r20}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn20: ∀n20∈ℕ, ∀r020∈nodes20(), X20{r020}^{n20=0}=coord20{r020}; , ∀r20∈nodes20(), X20{r20}^{n20+1}=X20{r20}^{n20}+δt20^{n20}*ur20{r20};
ComputeUn20: ∀n20∈ℕ, ∀j020∈cells20(), uj20{j020}^{n20=0}={0.0,0.0}; , ∀j20∈cells20(), uj20{j20}^{n20+1}=uj20{j20}^{n20}-(δt20^{n20}/m20{j20})*∑{r20∈nodesOfCell20(j20)}(F20{j20,r20});
ComputeEn20: ∀n20∈ℕ, ∀j020∈cells20(), E20{j020}^{n20=0}=p_ic20{j020}/((γ20-1.0)*ρ_ic20{j020}); , ∀j20∈cells20(), E20{j20}^{n20+1}=E20{j20}^{n20} - (δt20^{n20} / m20{j20}) * ∑{r20∈nodesOfCell20(j20)}(dot(F20{j20,r20},ur20{r20}));
ComputeDt20: ∀n20∈ℕ, δt20^{n20=0}=option_δt_ini20;, δt20^{n20+1}=option_δt_cfl20*reduceMin{j20∈cells20()}(δtj20{j20});
ComputeTn20: ∀n20∈ℕ, t20^{n20=0}=0.0; , t20^{n20+1}=t20^{n20}+δt20^{n20+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter21: ∀j21∈cells21(), center21{j21} = (1.0/4.0) * ∑{r21∈nodesOfCell21(j21)}(coord21{r21});
IniIc21: ∀j21∈cells21(), if (center21{j21}.x < option_x_interface21) {
  ρ_ic21{j21}=option_ρ_ini_zg21;
  p_ic21{j21}=option_p_ini_zg21;
} else {
  ρ_ic21{j21}=option_ρ_ini_zd21;
  p_ic21{j21}=option_p_ini_zd21;
}

ComputeCjrIc21: ∀j21∈cells21(), ∀r21∈nodesOfCell21(j21), 
	C_ic21{j21,r21} = 0.5 * perp21(coord21{►(r21)} - coord21{◄(r21)});
IniVIc21: ∀j21∈cells21(), V_ic21{j21} = 0.5 * ∑{r21∈nodesOfCell21(j21)}(dot(C_ic21{j21,r21}, coord21{r21}));
IniM21: ∀j21∈cells21(), m21{j21} = ρ_ic21{j21} * V_ic21{j21}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr21: ∀j21∈cells21(), ∀r21∈nodesOfCell21(j21), C21{j21,r21} = 0.5 * perp21(X21{►(r21)} - X21{◄(r21)});
ComputeLjr21: ∀j21∈cells21(), ∀r21∈nodesOfCell21(j21), l21{j21,r21} = norm(C21{j21,r21});
Computeδtj21: ∀j21∈cells21(), δtj21{j21} = 2.0 * V21{j21} / (c21{j21} * ∑{r21∈nodesOfCell21(j21)}(l21{j21,r21}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity21: ∀j21∈cells21(), ρ21{j21} = m21{j21} / V21{j21};
ComputeEOSp21: ∀j21∈cells21(), p21{j21} = (γ21-1.0) * ρ21{j21} * e21{j21};
ComputeInternalEngergy21: ∀j21∈cells21(), e21{j21} = E21{j21} - 0.5 * dot(uj21{j21}, uj21{j21});
ComputeEOSc21: ∀j21∈cells21(), c21{j21} = √(γ21*p21{j21}/ρ21{j21}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr21: ∀j21∈cells21(), ∀r21∈nodesOfCell21(j21), Ajr21{j21,r21} = ((ρ21{j21}*c21{j21})/l21{j21,r21}) * tensProduct21(C21{j21,r21}, C21{j21,r21});
ComputeFjr21: ∀j21∈cells21(), ∀r21∈nodesOfCell21(j21), F21{j21,r21} = p21{j21}*C21{j21,r21} + matVectProduct21(Ajr21{j21,r21}, (uj21{j21}-ur21{r21}));
ComputeAr21: ∀r21∈nodes21(), Ar21{r21} = ∑{j21∈cellsOfNode21(r21)}(Ajr21{j21,r21});
ComputeBr21: ∀r21∈nodes21(), b21{r21} = ∑{j21∈cellsOfNode21(r21)}(p21{j21}*C21{j21,r21} + matVectProduct21(Ajr21{j21,r21}, uj21{j21}));
ComputeMt21: ∀r21∈innerNodes21(), Mt21{r21} = Ar21{r21};
ComputeBt21: ∀r21∈innerNodes21(), bt21{r21} = b21{r21};

OuterFacesComputations21: ∀k21∈outerFaces21(), {
	const ℝ epsilon21 = 1.0e-10;
	ℝ²ˣ² I21 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN21 = 0.0;
	ℝ X_MAX21 = X_EDGE_ELEMS21 * LENGTH21;
	ℝ Y_MIN21 = 0.0; 
	ℝ Y_MAX21 = Y_EDGE_ELEMS21 * LENGTH21;
	ℝ² nY21 = {0.0,1.0};
	
	∀r21∈nodesOfFace21(k21), {
		// Y boundary conditions (must be done before X)
		if ((X21{r21}.y-Y_MIN21 < epsilon21) || (X21{r21}.y-Y_MAX21 < epsilon21)) {
			ℝ sign21 = 0.0;
			if (X21{r21}.y-Y_MIN21 < epsilon21) sign21 = -1.0;
			else sign21 = 1.0;
			ℝ² n21 = sign21 * nY21;
      		ℝ²ˣ² nxn21 = tensProduct21(n21,n21);
      		ℝ²ˣ² IcP21 = I21 - nxn21;
			bt1{r21} = matVectProduct21(IcP21, b21{r21});
			Mt1{r21} = IcP21 * (Ar21{r21} * IcP21) + nxn21*trace21(Ar21{r21});
		}

		// X boundary conditions
		if ((Math.fabs(X21{r21}.x-X_MIN21) < epsilon21) || ( (Math.fabs(X21{r21}.x-X_MAX21) < epsilon21) )) {
			Mt21{r21} = I21;
			bt21{r21} = {0.0, 0.0};
		}
	}
}


ComputeU21: ∀r21∈nodes21(), ur21{r21} = matVectProduct21(inverse21(Mt21{r21}), bt21{r21});
ComputeV21: ∀j21∈cells21(), V21{j21} = 0.5 * ∑{r21∈nodesOfCell21(j21)}(dot(C21{j21,r21},X21{r21}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn21: ∀n21∈ℕ, ∀r021∈nodes21(), X21{r021}^{n21=0}=coord21{r021}; , ∀r21∈nodes21(), X21{r21}^{n21+1}=X21{r21}^{n21}+δt21^{n21}*ur21{r21};
ComputeUn21: ∀n21∈ℕ, ∀j021∈cells21(), uj21{j021}^{n21=0}={0.0,0.0}; , ∀j21∈cells21(), uj21{j21}^{n21+1}=uj21{j21}^{n21}-(δt21^{n21}/m21{j21})*∑{r21∈nodesOfCell21(j21)}(F21{j21,r21});
ComputeEn21: ∀n21∈ℕ, ∀j021∈cells21(), E21{j021}^{n21=0}=p_ic21{j021}/((γ21-1.0)*ρ_ic21{j021}); , ∀j21∈cells21(), E21{j21}^{n21+1}=E21{j21}^{n21} - (δt21^{n21} / m21{j21}) * ∑{r21∈nodesOfCell21(j21)}(dot(F21{j21,r21},ur21{r21}));
ComputeDt21: ∀n21∈ℕ, δt21^{n21=0}=option_δt_ini21;, δt21^{n21+1}=option_δt_cfl21*reduceMin{j21∈cells21()}(δtj21{j21});
ComputeTn21: ∀n21∈ℕ, t21^{n21=0}=0.0; , t21^{n21+1}=t21^{n21}+δt21^{n21+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter22: ∀j22∈cells22(), center22{j22} = (1.0/4.0) * ∑{r22∈nodesOfCell22(j22)}(coord22{r22});
IniIc22: ∀j22∈cells22(), if (center22{j22}.x < option_x_interface22) {
  ρ_ic22{j22}=option_ρ_ini_zg22;
  p_ic22{j22}=option_p_ini_zg22;
} else {
  ρ_ic22{j22}=option_ρ_ini_zd22;
  p_ic22{j22}=option_p_ini_zd22;
}

ComputeCjrIc22: ∀j22∈cells22(), ∀r22∈nodesOfCell22(j22), 
	C_ic22{j22,r22} = 0.5 * perp22(coord22{►(r22)} - coord22{◄(r22)});
IniVIc22: ∀j22∈cells22(), V_ic22{j22} = 0.5 * ∑{r22∈nodesOfCell22(j22)}(dot(C_ic22{j22,r22}, coord22{r22}));
IniM22: ∀j22∈cells22(), m22{j22} = ρ_ic22{j22} * V_ic22{j22}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr22: ∀j22∈cells22(), ∀r22∈nodesOfCell22(j22), C22{j22,r22} = 0.5 * perp22(X22{►(r22)} - X22{◄(r22)});
ComputeLjr22: ∀j22∈cells22(), ∀r22∈nodesOfCell22(j22), l22{j22,r22} = norm(C22{j22,r22});
Computeδtj22: ∀j22∈cells22(), δtj22{j22} = 2.0 * V22{j22} / (c22{j22} * ∑{r22∈nodesOfCell22(j22)}(l22{j22,r22}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity22: ∀j22∈cells22(), ρ22{j22} = m22{j22} / V22{j22};
ComputeEOSp22: ∀j22∈cells22(), p22{j22} = (γ22-1.0) * ρ22{j22} * e22{j22};
ComputeInternalEngergy22: ∀j22∈cells22(), e22{j22} = E22{j22} - 0.5 * dot(uj22{j22}, uj22{j22});
ComputeEOSc22: ∀j22∈cells22(), c22{j22} = √(γ22*p22{j22}/ρ22{j22}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr22: ∀j22∈cells22(), ∀r22∈nodesOfCell22(j22), Ajr22{j22,r22} = ((ρ22{j22}*c22{j22})/l22{j22,r22}) * tensProduct22(C22{j22,r22}, C22{j22,r22});
ComputeFjr22: ∀j22∈cells22(), ∀r22∈nodesOfCell22(j22), F22{j22,r22} = p22{j22}*C22{j22,r22} + matVectProduct22(Ajr22{j22,r22}, (uj22{j22}-ur22{r22}));
ComputeAr22: ∀r22∈nodes22(), Ar22{r22} = ∑{j22∈cellsOfNode22(r22)}(Ajr22{j22,r22});
ComputeBr22: ∀r22∈nodes22(), b22{r22} = ∑{j22∈cellsOfNode22(r22)}(p22{j22}*C22{j22,r22} + matVectProduct22(Ajr22{j22,r22}, uj22{j22}));
ComputeMt22: ∀r22∈innerNodes22(), Mt22{r22} = Ar22{r22};
ComputeBt22: ∀r22∈innerNodes22(), bt22{r22} = b22{r22};

OuterFacesComputations22: ∀k22∈outerFaces22(), {
	const ℝ epsilon22 = 1.0e-10;
	ℝ²ˣ² I22 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN22 = 0.0;
	ℝ X_MAX22 = X_EDGE_ELEMS22 * LENGTH22;
	ℝ Y_MIN22 = 0.0; 
	ℝ Y_MAX22 = Y_EDGE_ELEMS22 * LENGTH22;
	ℝ² nY22 = {0.0,1.0};
	
	∀r22∈nodesOfFace22(k22), {
		// Y boundary conditions (must be done before X)
		if ((X22{r22}.y-Y_MIN22 < epsilon22) || (X22{r22}.y-Y_MAX22 < epsilon22)) {
			ℝ sign22 = 0.0;
			if (X22{r22}.y-Y_MIN22 < epsilon22) sign22 = -1.0;
			else sign22 = 1.0;
			ℝ² n22 = sign22 * nY22;
      		ℝ²ˣ² nxn22 = tensProduct22(n22,n22);
      		ℝ²ˣ² IcP22 = I22 - nxn22;
			bt1{r22} = matVectProduct22(IcP22, b22{r22});
			Mt1{r22} = IcP22 * (Ar22{r22} * IcP22) + nxn22*trace22(Ar22{r22});
		}

		// X boundary conditions
		if ((Math.fabs(X22{r22}.x-X_MIN22) < epsilon22) || ( (Math.fabs(X22{r22}.x-X_MAX22) < epsilon22) )) {
			Mt22{r22} = I22;
			bt22{r22} = {0.0, 0.0};
		}
	}
}


ComputeU22: ∀r22∈nodes22(), ur22{r22} = matVectProduct22(inverse22(Mt22{r22}), bt22{r22});
ComputeV22: ∀j22∈cells22(), V22{j22} = 0.5 * ∑{r22∈nodesOfCell22(j22)}(dot(C22{j22,r22},X22{r22}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn22: ∀n22∈ℕ, ∀r022∈nodes22(), X22{r022}^{n22=0}=coord22{r022}; , ∀r22∈nodes22(), X22{r22}^{n22+1}=X22{r22}^{n22}+δt22^{n22}*ur22{r22};
ComputeUn22: ∀n22∈ℕ, ∀j022∈cells22(), uj22{j022}^{n22=0}={0.0,0.0}; , ∀j22∈cells22(), uj22{j22}^{n22+1}=uj22{j22}^{n22}-(δt22^{n22}/m22{j22})*∑{r22∈nodesOfCell22(j22)}(F22{j22,r22});
ComputeEn22: ∀n22∈ℕ, ∀j022∈cells22(), E22{j022}^{n22=0}=p_ic22{j022}/((γ22-1.0)*ρ_ic22{j022}); , ∀j22∈cells22(), E22{j22}^{n22+1}=E22{j22}^{n22} - (δt22^{n22} / m22{j22}) * ∑{r22∈nodesOfCell22(j22)}(dot(F22{j22,r22},ur22{r22}));
ComputeDt22: ∀n22∈ℕ, δt22^{n22=0}=option_δt_ini22;, δt22^{n22+1}=option_δt_cfl22*reduceMin{j22∈cells22()}(δtj22{j22});
ComputeTn22: ∀n22∈ℕ, t22^{n22=0}=0.0; , t22^{n22+1}=t22^{n22}+δt22^{n22+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter23: ∀j23∈cells23(), center23{j23} = (1.0/4.0) * ∑{r23∈nodesOfCell23(j23)}(coord23{r23});
IniIc23: ∀j23∈cells23(), if (center23{j23}.x < option_x_interface23) {
  ρ_ic23{j23}=option_ρ_ini_zg23;
  p_ic23{j23}=option_p_ini_zg23;
} else {
  ρ_ic23{j23}=option_ρ_ini_zd23;
  p_ic23{j23}=option_p_ini_zd23;
}

ComputeCjrIc23: ∀j23∈cells23(), ∀r23∈nodesOfCell23(j23), 
	C_ic23{j23,r23} = 0.5 * perp23(coord23{►(r23)} - coord23{◄(r23)});
IniVIc23: ∀j23∈cells23(), V_ic23{j23} = 0.5 * ∑{r23∈nodesOfCell23(j23)}(dot(C_ic23{j23,r23}, coord23{r23}));
IniM23: ∀j23∈cells23(), m23{j23} = ρ_ic23{j23} * V_ic23{j23}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr23: ∀j23∈cells23(), ∀r23∈nodesOfCell23(j23), C23{j23,r23} = 0.5 * perp23(X23{►(r23)} - X23{◄(r23)});
ComputeLjr23: ∀j23∈cells23(), ∀r23∈nodesOfCell23(j23), l23{j23,r23} = norm(C23{j23,r23});
Computeδtj23: ∀j23∈cells23(), δtj23{j23} = 2.0 * V23{j23} / (c23{j23} * ∑{r23∈nodesOfCell23(j23)}(l23{j23,r23}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity23: ∀j23∈cells23(), ρ23{j23} = m23{j23} / V23{j23};
ComputeEOSp23: ∀j23∈cells23(), p23{j23} = (γ23-1.0) * ρ23{j23} * e23{j23};
ComputeInternalEngergy23: ∀j23∈cells23(), e23{j23} = E23{j23} - 0.5 * dot(uj23{j23}, uj23{j23});
ComputeEOSc23: ∀j23∈cells23(), c23{j23} = √(γ23*p23{j23}/ρ23{j23}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr23: ∀j23∈cells23(), ∀r23∈nodesOfCell23(j23), Ajr23{j23,r23} = ((ρ23{j23}*c23{j23})/l23{j23,r23}) * tensProduct23(C23{j23,r23}, C23{j23,r23});
ComputeFjr23: ∀j23∈cells23(), ∀r23∈nodesOfCell23(j23), F23{j23,r23} = p23{j23}*C23{j23,r23} + matVectProduct23(Ajr23{j23,r23}, (uj23{j23}-ur23{r23}));
ComputeAr23: ∀r23∈nodes23(), Ar23{r23} = ∑{j23∈cellsOfNode23(r23)}(Ajr23{j23,r23});
ComputeBr23: ∀r23∈nodes23(), b23{r23} = ∑{j23∈cellsOfNode23(r23)}(p23{j23}*C23{j23,r23} + matVectProduct23(Ajr23{j23,r23}, uj23{j23}));
ComputeMt23: ∀r23∈innerNodes23(), Mt23{r23} = Ar23{r23};
ComputeBt23: ∀r23∈innerNodes23(), bt23{r23} = b23{r23};

OuterFacesComputations23: ∀k23∈outerFaces23(), {
	const ℝ epsilon23 = 1.0e-10;
	ℝ²ˣ² I23 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN23 = 0.0;
	ℝ X_MAX23 = X_EDGE_ELEMS23 * LENGTH23;
	ℝ Y_MIN23 = 0.0; 
	ℝ Y_MAX23 = Y_EDGE_ELEMS23 * LENGTH23;
	ℝ² nY23 = {0.0,1.0};
	
	∀r23∈nodesOfFace23(k23), {
		// Y boundary conditions (must be done before X)
		if ((X23{r23}.y-Y_MIN23 < epsilon23) || (X23{r23}.y-Y_MAX23 < epsilon23)) {
			ℝ sign23 = 0.0;
			if (X23{r23}.y-Y_MIN23 < epsilon23) sign23 = -1.0;
			else sign23 = 1.0;
			ℝ² n23 = sign23 * nY23;
      		ℝ²ˣ² nxn23 = tensProduct23(n23,n23);
      		ℝ²ˣ² IcP23 = I23 - nxn23;
			bt1{r23} = matVectProduct23(IcP23, b23{r23});
			Mt1{r23} = IcP23 * (Ar23{r23} * IcP23) + nxn23*trace23(Ar23{r23});
		}

		// X boundary conditions
		if ((Math.fabs(X23{r23}.x-X_MIN23) < epsilon23) || ( (Math.fabs(X23{r23}.x-X_MAX23) < epsilon23) )) {
			Mt23{r23} = I23;
			bt23{r23} = {0.0, 0.0};
		}
	}
}


ComputeU23: ∀r23∈nodes23(), ur23{r23} = matVectProduct23(inverse23(Mt23{r23}), bt23{r23});
ComputeV23: ∀j23∈cells23(), V23{j23} = 0.5 * ∑{r23∈nodesOfCell23(j23)}(dot(C23{j23,r23},X23{r23}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn23: ∀n23∈ℕ, ∀r023∈nodes23(), X23{r023}^{n23=0}=coord23{r023}; , ∀r23∈nodes23(), X23{r23}^{n23+1}=X23{r23}^{n23}+δt23^{n23}*ur23{r23};
ComputeUn23: ∀n23∈ℕ, ∀j023∈cells23(), uj23{j023}^{n23=0}={0.0,0.0}; , ∀j23∈cells23(), uj23{j23}^{n23+1}=uj23{j23}^{n23}-(δt23^{n23}/m23{j23})*∑{r23∈nodesOfCell23(j23)}(F23{j23,r23});
ComputeEn23: ∀n23∈ℕ, ∀j023∈cells23(), E23{j023}^{n23=0}=p_ic23{j023}/((γ23-1.0)*ρ_ic23{j023}); , ∀j23∈cells23(), E23{j23}^{n23+1}=E23{j23}^{n23} - (δt23^{n23} / m23{j23}) * ∑{r23∈nodesOfCell23(j23)}(dot(F23{j23,r23},ur23{r23}));
ComputeDt23: ∀n23∈ℕ, δt23^{n23=0}=option_δt_ini23;, δt23^{n23+1}=option_δt_cfl23*reduceMin{j23∈cells23()}(δtj23{j23});
ComputeTn23: ∀n23∈ℕ, t23^{n23=0}=0.0; , t23^{n23+1}=t23^{n23}+δt23^{n23+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter24: ∀j24∈cells24(), center24{j24} = (1.0/4.0) * ∑{r24∈nodesOfCell24(j24)}(coord24{r24});
IniIc24: ∀j24∈cells24(), if (center24{j24}.x < option_x_interface24) {
  ρ_ic24{j24}=option_ρ_ini_zg24;
  p_ic24{j24}=option_p_ini_zg24;
} else {
  ρ_ic24{j24}=option_ρ_ini_zd24;
  p_ic24{j24}=option_p_ini_zd24;
}

ComputeCjrIc24: ∀j24∈cells24(), ∀r24∈nodesOfCell24(j24), 
	C_ic24{j24,r24} = 0.5 * perp24(coord24{►(r24)} - coord24{◄(r24)});
IniVIc24: ∀j24∈cells24(), V_ic24{j24} = 0.5 * ∑{r24∈nodesOfCell24(j24)}(dot(C_ic24{j24,r24}, coord24{r24}));
IniM24: ∀j24∈cells24(), m24{j24} = ρ_ic24{j24} * V_ic24{j24}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr24: ∀j24∈cells24(), ∀r24∈nodesOfCell24(j24), C24{j24,r24} = 0.5 * perp24(X24{►(r24)} - X24{◄(r24)});
ComputeLjr24: ∀j24∈cells24(), ∀r24∈nodesOfCell24(j24), l24{j24,r24} = norm(C24{j24,r24});
Computeδtj24: ∀j24∈cells24(), δtj24{j24} = 2.0 * V24{j24} / (c24{j24} * ∑{r24∈nodesOfCell24(j24)}(l24{j24,r24}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity24: ∀j24∈cells24(), ρ24{j24} = m24{j24} / V24{j24};
ComputeEOSp24: ∀j24∈cells24(), p24{j24} = (γ24-1.0) * ρ24{j24} * e24{j24};
ComputeInternalEngergy24: ∀j24∈cells24(), e24{j24} = E24{j24} - 0.5 * dot(uj24{j24}, uj24{j24});
ComputeEOSc24: ∀j24∈cells24(), c24{j24} = √(γ24*p24{j24}/ρ24{j24}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr24: ∀j24∈cells24(), ∀r24∈nodesOfCell24(j24), Ajr24{j24,r24} = ((ρ24{j24}*c24{j24})/l24{j24,r24}) * tensProduct24(C24{j24,r24}, C24{j24,r24});
ComputeFjr24: ∀j24∈cells24(), ∀r24∈nodesOfCell24(j24), F24{j24,r24} = p24{j24}*C24{j24,r24} + matVectProduct24(Ajr24{j24,r24}, (uj24{j24}-ur24{r24}));
ComputeAr24: ∀r24∈nodes24(), Ar24{r24} = ∑{j24∈cellsOfNode24(r24)}(Ajr24{j24,r24});
ComputeBr24: ∀r24∈nodes24(), b24{r24} = ∑{j24∈cellsOfNode24(r24)}(p24{j24}*C24{j24,r24} + matVectProduct24(Ajr24{j24,r24}, uj24{j24}));
ComputeMt24: ∀r24∈innerNodes24(), Mt24{r24} = Ar24{r24};
ComputeBt24: ∀r24∈innerNodes24(), bt24{r24} = b24{r24};

OuterFacesComputations24: ∀k24∈outerFaces24(), {
	const ℝ epsilon24 = 1.0e-10;
	ℝ²ˣ² I24 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN24 = 0.0;
	ℝ X_MAX24 = X_EDGE_ELEMS24 * LENGTH24;
	ℝ Y_MIN24 = 0.0; 
	ℝ Y_MAX24 = Y_EDGE_ELEMS24 * LENGTH24;
	ℝ² nY24 = {0.0,1.0};
	
	∀r24∈nodesOfFace24(k24), {
		// Y boundary conditions (must be done before X)
		if ((X24{r24}.y-Y_MIN24 < epsilon24) || (X24{r24}.y-Y_MAX24 < epsilon24)) {
			ℝ sign24 = 0.0;
			if (X24{r24}.y-Y_MIN24 < epsilon24) sign24 = -1.0;
			else sign24 = 1.0;
			ℝ² n24 = sign24 * nY24;
      		ℝ²ˣ² nxn24 = tensProduct24(n24,n24);
      		ℝ²ˣ² IcP24 = I24 - nxn24;
			bt1{r24} = matVectProduct24(IcP24, b24{r24});
			Mt1{r24} = IcP24 * (Ar24{r24} * IcP24) + nxn24*trace24(Ar24{r24});
		}

		// X boundary conditions
		if ((Math.fabs(X24{r24}.x-X_MIN24) < epsilon24) || ( (Math.fabs(X24{r24}.x-X_MAX24) < epsilon24) )) {
			Mt24{r24} = I24;
			bt24{r24} = {0.0, 0.0};
		}
	}
}


ComputeU24: ∀r24∈nodes24(), ur24{r24} = matVectProduct24(inverse24(Mt24{r24}), bt24{r24});
ComputeV24: ∀j24∈cells24(), V24{j24} = 0.5 * ∑{r24∈nodesOfCell24(j24)}(dot(C24{j24,r24},X24{r24}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn24: ∀n24∈ℕ, ∀r024∈nodes24(), X24{r024}^{n24=0}=coord24{r024}; , ∀r24∈nodes24(), X24{r24}^{n24+1}=X24{r24}^{n24}+δt24^{n24}*ur24{r24};
ComputeUn24: ∀n24∈ℕ, ∀j024∈cells24(), uj24{j024}^{n24=0}={0.0,0.0}; , ∀j24∈cells24(), uj24{j24}^{n24+1}=uj24{j24}^{n24}-(δt24^{n24}/m24{j24})*∑{r24∈nodesOfCell24(j24)}(F24{j24,r24});
ComputeEn24: ∀n24∈ℕ, ∀j024∈cells24(), E24{j024}^{n24=0}=p_ic24{j024}/((γ24-1.0)*ρ_ic24{j024}); , ∀j24∈cells24(), E24{j24}^{n24+1}=E24{j24}^{n24} - (δt24^{n24} / m24{j24}) * ∑{r24∈nodesOfCell24(j24)}(dot(F24{j24,r24},ur24{r24}));
ComputeDt24: ∀n24∈ℕ, δt24^{n24=0}=option_δt_ini24;, δt24^{n24+1}=option_δt_cfl24*reduceMin{j24∈cells24()}(δtj24{j24});
ComputeTn24: ∀n24∈ℕ, t24^{n24=0}=0.0; , t24^{n24+1}=t24^{n24}+δt24^{n24+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter25: ∀j25∈cells25(), center25{j25} = (1.0/4.0) * ∑{r25∈nodesOfCell25(j25)}(coord25{r25});
IniIc25: ∀j25∈cells25(), if (center25{j25}.x < option_x_interface25) {
  ρ_ic25{j25}=option_ρ_ini_zg25;
  p_ic25{j25}=option_p_ini_zg25;
} else {
  ρ_ic25{j25}=option_ρ_ini_zd25;
  p_ic25{j25}=option_p_ini_zd25;
}

ComputeCjrIc25: ∀j25∈cells25(), ∀r25∈nodesOfCell25(j25), 
	C_ic25{j25,r25} = 0.5 * perp25(coord25{►(r25)} - coord25{◄(r25)});
IniVIc25: ∀j25∈cells25(), V_ic25{j25} = 0.5 * ∑{r25∈nodesOfCell25(j25)}(dot(C_ic25{j25,r25}, coord25{r25}));
IniM25: ∀j25∈cells25(), m25{j25} = ρ_ic25{j25} * V_ic25{j25}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr25: ∀j25∈cells25(), ∀r25∈nodesOfCell25(j25), C25{j25,r25} = 0.5 * perp25(X25{►(r25)} - X25{◄(r25)});
ComputeLjr25: ∀j25∈cells25(), ∀r25∈nodesOfCell25(j25), l25{j25,r25} = norm(C25{j25,r25});
Computeδtj25: ∀j25∈cells25(), δtj25{j25} = 2.0 * V25{j25} / (c25{j25} * ∑{r25∈nodesOfCell25(j25)}(l25{j25,r25}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity25: ∀j25∈cells25(), ρ25{j25} = m25{j25} / V25{j25};
ComputeEOSp25: ∀j25∈cells25(), p25{j25} = (γ25-1.0) * ρ25{j25} * e25{j25};
ComputeInternalEngergy25: ∀j25∈cells25(), e25{j25} = E25{j25} - 0.5 * dot(uj25{j25}, uj25{j25});
ComputeEOSc25: ∀j25∈cells25(), c25{j25} = √(γ25*p25{j25}/ρ25{j25}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr25: ∀j25∈cells25(), ∀r25∈nodesOfCell25(j25), Ajr25{j25,r25} = ((ρ25{j25}*c25{j25})/l25{j25,r25}) * tensProduct25(C25{j25,r25}, C25{j25,r25});
ComputeFjr25: ∀j25∈cells25(), ∀r25∈nodesOfCell25(j25), F25{j25,r25} = p25{j25}*C25{j25,r25} + matVectProduct25(Ajr25{j25,r25}, (uj25{j25}-ur25{r25}));
ComputeAr25: ∀r25∈nodes25(), Ar25{r25} = ∑{j25∈cellsOfNode25(r25)}(Ajr25{j25,r25});
ComputeBr25: ∀r25∈nodes25(), b25{r25} = ∑{j25∈cellsOfNode25(r25)}(p25{j25}*C25{j25,r25} + matVectProduct25(Ajr25{j25,r25}, uj25{j25}));
ComputeMt25: ∀r25∈innerNodes25(), Mt25{r25} = Ar25{r25};
ComputeBt25: ∀r25∈innerNodes25(), bt25{r25} = b25{r25};

OuterFacesComputations25: ∀k25∈outerFaces25(), {
	const ℝ epsilon25 = 1.0e-10;
	ℝ²ˣ² I25 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN25 = 0.0;
	ℝ X_MAX25 = X_EDGE_ELEMS25 * LENGTH25;
	ℝ Y_MIN25 = 0.0; 
	ℝ Y_MAX25 = Y_EDGE_ELEMS25 * LENGTH25;
	ℝ² nY25 = {0.0,1.0};
	
	∀r25∈nodesOfFace25(k25), {
		// Y boundary conditions (must be done before X)
		if ((X25{r25}.y-Y_MIN25 < epsilon25) || (X25{r25}.y-Y_MAX25 < epsilon25)) {
			ℝ sign25 = 0.0;
			if (X25{r25}.y-Y_MIN25 < epsilon25) sign25 = -1.0;
			else sign25 = 1.0;
			ℝ² n25 = sign25 * nY25;
      		ℝ²ˣ² nxn25 = tensProduct25(n25,n25);
      		ℝ²ˣ² IcP25 = I25 - nxn25;
			bt1{r25} = matVectProduct25(IcP25, b25{r25});
			Mt1{r25} = IcP25 * (Ar25{r25} * IcP25) + nxn25*trace25(Ar25{r25});
		}

		// X boundary conditions
		if ((Math.fabs(X25{r25}.x-X_MIN25) < epsilon25) || ( (Math.fabs(X25{r25}.x-X_MAX25) < epsilon25) )) {
			Mt25{r25} = I25;
			bt25{r25} = {0.0, 0.0};
		}
	}
}


ComputeU25: ∀r25∈nodes25(), ur25{r25} = matVectProduct25(inverse25(Mt25{r25}), bt25{r25});
ComputeV25: ∀j25∈cells25(), V25{j25} = 0.5 * ∑{r25∈nodesOfCell25(j25)}(dot(C25{j25,r25},X25{r25}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn25: ∀n25∈ℕ, ∀r025∈nodes25(), X25{r025}^{n25=0}=coord25{r025}; , ∀r25∈nodes25(), X25{r25}^{n25+1}=X25{r25}^{n25}+δt25^{n25}*ur25{r25};
ComputeUn25: ∀n25∈ℕ, ∀j025∈cells25(), uj25{j025}^{n25=0}={0.0,0.0}; , ∀j25∈cells25(), uj25{j25}^{n25+1}=uj25{j25}^{n25}-(δt25^{n25}/m25{j25})*∑{r25∈nodesOfCell25(j25)}(F25{j25,r25});
ComputeEn25: ∀n25∈ℕ, ∀j025∈cells25(), E25{j025}^{n25=0}=p_ic25{j025}/((γ25-1.0)*ρ_ic25{j025}); , ∀j25∈cells25(), E25{j25}^{n25+1}=E25{j25}^{n25} - (δt25^{n25} / m25{j25}) * ∑{r25∈nodesOfCell25(j25)}(dot(F25{j25,r25},ur25{r25}));
ComputeDt25: ∀n25∈ℕ, δt25^{n25=0}=option_δt_ini25;, δt25^{n25+1}=option_δt_cfl25*reduceMin{j25∈cells25()}(δtj25{j25});
ComputeTn25: ∀n25∈ℕ, t25^{n25=0}=0.0; , t25^{n25+1}=t25^{n25}+δt25^{n25+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter26: ∀j26∈cells26(), center26{j26} = (1.0/4.0) * ∑{r26∈nodesOfCell26(j26)}(coord26{r26});
IniIc26: ∀j26∈cells26(), if (center26{j26}.x < option_x_interface26) {
  ρ_ic26{j26}=option_ρ_ini_zg26;
  p_ic26{j26}=option_p_ini_zg26;
} else {
  ρ_ic26{j26}=option_ρ_ini_zd26;
  p_ic26{j26}=option_p_ini_zd26;
}

ComputeCjrIc26: ∀j26∈cells26(), ∀r26∈nodesOfCell26(j26), 
	C_ic26{j26,r26} = 0.5 * perp26(coord26{►(r26)} - coord26{◄(r26)});
IniVIc26: ∀j26∈cells26(), V_ic26{j26} = 0.5 * ∑{r26∈nodesOfCell26(j26)}(dot(C_ic26{j26,r26}, coord26{r26}));
IniM26: ∀j26∈cells26(), m26{j26} = ρ_ic26{j26} * V_ic26{j26}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr26: ∀j26∈cells26(), ∀r26∈nodesOfCell26(j26), C26{j26,r26} = 0.5 * perp26(X26{►(r26)} - X26{◄(r26)});
ComputeLjr26: ∀j26∈cells26(), ∀r26∈nodesOfCell26(j26), l26{j26,r26} = norm(C26{j26,r26});
Computeδtj26: ∀j26∈cells26(), δtj26{j26} = 2.0 * V26{j26} / (c26{j26} * ∑{r26∈nodesOfCell26(j26)}(l26{j26,r26}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity26: ∀j26∈cells26(), ρ26{j26} = m26{j26} / V26{j26};
ComputeEOSp26: ∀j26∈cells26(), p26{j26} = (γ26-1.0) * ρ26{j26} * e26{j26};
ComputeInternalEngergy26: ∀j26∈cells26(), e26{j26} = E26{j26} - 0.5 * dot(uj26{j26}, uj26{j26});
ComputeEOSc26: ∀j26∈cells26(), c26{j26} = √(γ26*p26{j26}/ρ26{j26}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr26: ∀j26∈cells26(), ∀r26∈nodesOfCell26(j26), Ajr26{j26,r26} = ((ρ26{j26}*c26{j26})/l26{j26,r26}) * tensProduct26(C26{j26,r26}, C26{j26,r26});
ComputeFjr26: ∀j26∈cells26(), ∀r26∈nodesOfCell26(j26), F26{j26,r26} = p26{j26}*C26{j26,r26} + matVectProduct26(Ajr26{j26,r26}, (uj26{j26}-ur26{r26}));
ComputeAr26: ∀r26∈nodes26(), Ar26{r26} = ∑{j26∈cellsOfNode26(r26)}(Ajr26{j26,r26});
ComputeBr26: ∀r26∈nodes26(), b26{r26} = ∑{j26∈cellsOfNode26(r26)}(p26{j26}*C26{j26,r26} + matVectProduct26(Ajr26{j26,r26}, uj26{j26}));
ComputeMt26: ∀r26∈innerNodes26(), Mt26{r26} = Ar26{r26};
ComputeBt26: ∀r26∈innerNodes26(), bt26{r26} = b26{r26};

OuterFacesComputations26: ∀k26∈outerFaces26(), {
	const ℝ epsilon26 = 1.0e-10;
	ℝ²ˣ² I26 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN26 = 0.0;
	ℝ X_MAX26 = X_EDGE_ELEMS26 * LENGTH26;
	ℝ Y_MIN26 = 0.0; 
	ℝ Y_MAX26 = Y_EDGE_ELEMS26 * LENGTH26;
	ℝ² nY26 = {0.0,1.0};
	
	∀r26∈nodesOfFace26(k26), {
		// Y boundary conditions (must be done before X)
		if ((X26{r26}.y-Y_MIN26 < epsilon26) || (X26{r26}.y-Y_MAX26 < epsilon26)) {
			ℝ sign26 = 0.0;
			if (X26{r26}.y-Y_MIN26 < epsilon26) sign26 = -1.0;
			else sign26 = 1.0;
			ℝ² n26 = sign26 * nY26;
      		ℝ²ˣ² nxn26 = tensProduct26(n26,n26);
      		ℝ²ˣ² IcP26 = I26 - nxn26;
			bt1{r26} = matVectProduct26(IcP26, b26{r26});
			Mt1{r26} = IcP26 * (Ar26{r26} * IcP26) + nxn26*trace26(Ar26{r26});
		}

		// X boundary conditions
		if ((Math.fabs(X26{r26}.x-X_MIN26) < epsilon26) || ( (Math.fabs(X26{r26}.x-X_MAX26) < epsilon26) )) {
			Mt26{r26} = I26;
			bt26{r26} = {0.0, 0.0};
		}
	}
}


ComputeU26: ∀r26∈nodes26(), ur26{r26} = matVectProduct26(inverse26(Mt26{r26}), bt26{r26});
ComputeV26: ∀j26∈cells26(), V26{j26} = 0.5 * ∑{r26∈nodesOfCell26(j26)}(dot(C26{j26,r26},X26{r26}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn26: ∀n26∈ℕ, ∀r026∈nodes26(), X26{r026}^{n26=0}=coord26{r026}; , ∀r26∈nodes26(), X26{r26}^{n26+1}=X26{r26}^{n26}+δt26^{n26}*ur26{r26};
ComputeUn26: ∀n26∈ℕ, ∀j026∈cells26(), uj26{j026}^{n26=0}={0.0,0.0}; , ∀j26∈cells26(), uj26{j26}^{n26+1}=uj26{j26}^{n26}-(δt26^{n26}/m26{j26})*∑{r26∈nodesOfCell26(j26)}(F26{j26,r26});
ComputeEn26: ∀n26∈ℕ, ∀j026∈cells26(), E26{j026}^{n26=0}=p_ic26{j026}/((γ26-1.0)*ρ_ic26{j026}); , ∀j26∈cells26(), E26{j26}^{n26+1}=E26{j26}^{n26} - (δt26^{n26} / m26{j26}) * ∑{r26∈nodesOfCell26(j26)}(dot(F26{j26,r26},ur26{r26}));
ComputeDt26: ∀n26∈ℕ, δt26^{n26=0}=option_δt_ini26;, δt26^{n26+1}=option_δt_cfl26*reduceMin{j26∈cells26()}(δtj26{j26});
ComputeTn26: ∀n26∈ℕ, t26^{n26=0}=0.0; , t26^{n26+1}=t26^{n26}+δt26^{n26+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter27: ∀j27∈cells27(), center27{j27} = (1.0/4.0) * ∑{r27∈nodesOfCell27(j27)}(coord27{r27});
IniIc27: ∀j27∈cells27(), if (center27{j27}.x < option_x_interface27) {
  ρ_ic27{j27}=option_ρ_ini_zg27;
  p_ic27{j27}=option_p_ini_zg27;
} else {
  ρ_ic27{j27}=option_ρ_ini_zd27;
  p_ic27{j27}=option_p_ini_zd27;
}

ComputeCjrIc27: ∀j27∈cells27(), ∀r27∈nodesOfCell27(j27), 
	C_ic27{j27,r27} = 0.5 * perp27(coord27{►(r27)} - coord27{◄(r27)});
IniVIc27: ∀j27∈cells27(), V_ic27{j27} = 0.5 * ∑{r27∈nodesOfCell27(j27)}(dot(C_ic27{j27,r27}, coord27{r27}));
IniM27: ∀j27∈cells27(), m27{j27} = ρ_ic27{j27} * V_ic27{j27}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr27: ∀j27∈cells27(), ∀r27∈nodesOfCell27(j27), C27{j27,r27} = 0.5 * perp27(X27{►(r27)} - X27{◄(r27)});
ComputeLjr27: ∀j27∈cells27(), ∀r27∈nodesOfCell27(j27), l27{j27,r27} = norm(C27{j27,r27});
Computeδtj27: ∀j27∈cells27(), δtj27{j27} = 2.0 * V27{j27} / (c27{j27} * ∑{r27∈nodesOfCell27(j27)}(l27{j27,r27}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity27: ∀j27∈cells27(), ρ27{j27} = m27{j27} / V27{j27};
ComputeEOSp27: ∀j27∈cells27(), p27{j27} = (γ27-1.0) * ρ27{j27} * e27{j27};
ComputeInternalEngergy27: ∀j27∈cells27(), e27{j27} = E27{j27} - 0.5 * dot(uj27{j27}, uj27{j27});
ComputeEOSc27: ∀j27∈cells27(), c27{j27} = √(γ27*p27{j27}/ρ27{j27}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr27: ∀j27∈cells27(), ∀r27∈nodesOfCell27(j27), Ajr27{j27,r27} = ((ρ27{j27}*c27{j27})/l27{j27,r27}) * tensProduct27(C27{j27,r27}, C27{j27,r27});
ComputeFjr27: ∀j27∈cells27(), ∀r27∈nodesOfCell27(j27), F27{j27,r27} = p27{j27}*C27{j27,r27} + matVectProduct27(Ajr27{j27,r27}, (uj27{j27}-ur27{r27}));
ComputeAr27: ∀r27∈nodes27(), Ar27{r27} = ∑{j27∈cellsOfNode27(r27)}(Ajr27{j27,r27});
ComputeBr27: ∀r27∈nodes27(), b27{r27} = ∑{j27∈cellsOfNode27(r27)}(p27{j27}*C27{j27,r27} + matVectProduct27(Ajr27{j27,r27}, uj27{j27}));
ComputeMt27: ∀r27∈innerNodes27(), Mt27{r27} = Ar27{r27};
ComputeBt27: ∀r27∈innerNodes27(), bt27{r27} = b27{r27};

OuterFacesComputations27: ∀k27∈outerFaces27(), {
	const ℝ epsilon27 = 1.0e-10;
	ℝ²ˣ² I27 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN27 = 0.0;
	ℝ X_MAX27 = X_EDGE_ELEMS27 * LENGTH27;
	ℝ Y_MIN27 = 0.0; 
	ℝ Y_MAX27 = Y_EDGE_ELEMS27 * LENGTH27;
	ℝ² nY27 = {0.0,1.0};
	
	∀r27∈nodesOfFace27(k27), {
		// Y boundary conditions (must be done before X)
		if ((X27{r27}.y-Y_MIN27 < epsilon27) || (X27{r27}.y-Y_MAX27 < epsilon27)) {
			ℝ sign27 = 0.0;
			if (X27{r27}.y-Y_MIN27 < epsilon27) sign27 = -1.0;
			else sign27 = 1.0;
			ℝ² n27 = sign27 * nY27;
      		ℝ²ˣ² nxn27 = tensProduct27(n27,n27);
      		ℝ²ˣ² IcP27 = I27 - nxn27;
			bt1{r27} = matVectProduct27(IcP27, b27{r27});
			Mt1{r27} = IcP27 * (Ar27{r27} * IcP27) + nxn27*trace27(Ar27{r27});
		}

		// X boundary conditions
		if ((Math.fabs(X27{r27}.x-X_MIN27) < epsilon27) || ( (Math.fabs(X27{r27}.x-X_MAX27) < epsilon27) )) {
			Mt27{r27} = I27;
			bt27{r27} = {0.0, 0.0};
		}
	}
}


ComputeU27: ∀r27∈nodes27(), ur27{r27} = matVectProduct27(inverse27(Mt27{r27}), bt27{r27});
ComputeV27: ∀j27∈cells27(), V27{j27} = 0.5 * ∑{r27∈nodesOfCell27(j27)}(dot(C27{j27,r27},X27{r27}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn27: ∀n27∈ℕ, ∀r027∈nodes27(), X27{r027}^{n27=0}=coord27{r027}; , ∀r27∈nodes27(), X27{r27}^{n27+1}=X27{r27}^{n27}+δt27^{n27}*ur27{r27};
ComputeUn27: ∀n27∈ℕ, ∀j027∈cells27(), uj27{j027}^{n27=0}={0.0,0.0}; , ∀j27∈cells27(), uj27{j27}^{n27+1}=uj27{j27}^{n27}-(δt27^{n27}/m27{j27})*∑{r27∈nodesOfCell27(j27)}(F27{j27,r27});
ComputeEn27: ∀n27∈ℕ, ∀j027∈cells27(), E27{j027}^{n27=0}=p_ic27{j027}/((γ27-1.0)*ρ_ic27{j027}); , ∀j27∈cells27(), E27{j27}^{n27+1}=E27{j27}^{n27} - (δt27^{n27} / m27{j27}) * ∑{r27∈nodesOfCell27(j27)}(dot(F27{j27,r27},ur27{r27}));
ComputeDt27: ∀n27∈ℕ, δt27^{n27=0}=option_δt_ini27;, δt27^{n27+1}=option_δt_cfl27*reduceMin{j27∈cells27()}(δtj27{j27});
ComputeTn27: ∀n27∈ℕ, t27^{n27=0}=0.0; , t27^{n27+1}=t27^{n27}+δt27^{n27+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter28: ∀j28∈cells28(), center28{j28} = (1.0/4.0) * ∑{r28∈nodesOfCell28(j28)}(coord28{r28});
IniIc28: ∀j28∈cells28(), if (center28{j28}.x < option_x_interface28) {
  ρ_ic28{j28}=option_ρ_ini_zg28;
  p_ic28{j28}=option_p_ini_zg28;
} else {
  ρ_ic28{j28}=option_ρ_ini_zd28;
  p_ic28{j28}=option_p_ini_zd28;
}

ComputeCjrIc28: ∀j28∈cells28(), ∀r28∈nodesOfCell28(j28), 
	C_ic28{j28,r28} = 0.5 * perp28(coord28{►(r28)} - coord28{◄(r28)});
IniVIc28: ∀j28∈cells28(), V_ic28{j28} = 0.5 * ∑{r28∈nodesOfCell28(j28)}(dot(C_ic28{j28,r28}, coord28{r28}));
IniM28: ∀j28∈cells28(), m28{j28} = ρ_ic28{j28} * V_ic28{j28}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr28: ∀j28∈cells28(), ∀r28∈nodesOfCell28(j28), C28{j28,r28} = 0.5 * perp28(X28{►(r28)} - X28{◄(r28)});
ComputeLjr28: ∀j28∈cells28(), ∀r28∈nodesOfCell28(j28), l28{j28,r28} = norm(C28{j28,r28});
Computeδtj28: ∀j28∈cells28(), δtj28{j28} = 2.0 * V28{j28} / (c28{j28} * ∑{r28∈nodesOfCell28(j28)}(l28{j28,r28}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity28: ∀j28∈cells28(), ρ28{j28} = m28{j28} / V28{j28};
ComputeEOSp28: ∀j28∈cells28(), p28{j28} = (γ28-1.0) * ρ28{j28} * e28{j28};
ComputeInternalEngergy28: ∀j28∈cells28(), e28{j28} = E28{j28} - 0.5 * dot(uj28{j28}, uj28{j28});
ComputeEOSc28: ∀j28∈cells28(), c28{j28} = √(γ28*p28{j28}/ρ28{j28}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr28: ∀j28∈cells28(), ∀r28∈nodesOfCell28(j28), Ajr28{j28,r28} = ((ρ28{j28}*c28{j28})/l28{j28,r28}) * tensProduct28(C28{j28,r28}, C28{j28,r28});
ComputeFjr28: ∀j28∈cells28(), ∀r28∈nodesOfCell28(j28), F28{j28,r28} = p28{j28}*C28{j28,r28} + matVectProduct28(Ajr28{j28,r28}, (uj28{j28}-ur28{r28}));
ComputeAr28: ∀r28∈nodes28(), Ar28{r28} = ∑{j28∈cellsOfNode28(r28)}(Ajr28{j28,r28});
ComputeBr28: ∀r28∈nodes28(), b28{r28} = ∑{j28∈cellsOfNode28(r28)}(p28{j28}*C28{j28,r28} + matVectProduct28(Ajr28{j28,r28}, uj28{j28}));
ComputeMt28: ∀r28∈innerNodes28(), Mt28{r28} = Ar28{r28};
ComputeBt28: ∀r28∈innerNodes28(), bt28{r28} = b28{r28};

OuterFacesComputations28: ∀k28∈outerFaces28(), {
	const ℝ epsilon28 = 1.0e-10;
	ℝ²ˣ² I28 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN28 = 0.0;
	ℝ X_MAX28 = X_EDGE_ELEMS28 * LENGTH28;
	ℝ Y_MIN28 = 0.0; 
	ℝ Y_MAX28 = Y_EDGE_ELEMS28 * LENGTH28;
	ℝ² nY28 = {0.0,1.0};
	
	∀r28∈nodesOfFace28(k28), {
		// Y boundary conditions (must be done before X)
		if ((X28{r28}.y-Y_MIN28 < epsilon28) || (X28{r28}.y-Y_MAX28 < epsilon28)) {
			ℝ sign28 = 0.0;
			if (X28{r28}.y-Y_MIN28 < epsilon28) sign28 = -1.0;
			else sign28 = 1.0;
			ℝ² n28 = sign28 * nY28;
      		ℝ²ˣ² nxn28 = tensProduct28(n28,n28);
      		ℝ²ˣ² IcP28 = I28 - nxn28;
			bt1{r28} = matVectProduct28(IcP28, b28{r28});
			Mt1{r28} = IcP28 * (Ar28{r28} * IcP28) + nxn28*trace28(Ar28{r28});
		}

		// X boundary conditions
		if ((Math.fabs(X28{r28}.x-X_MIN28) < epsilon28) || ( (Math.fabs(X28{r28}.x-X_MAX28) < epsilon28) )) {
			Mt28{r28} = I28;
			bt28{r28} = {0.0, 0.0};
		}
	}
}


ComputeU28: ∀r28∈nodes28(), ur28{r28} = matVectProduct28(inverse28(Mt28{r28}), bt28{r28});
ComputeV28: ∀j28∈cells28(), V28{j28} = 0.5 * ∑{r28∈nodesOfCell28(j28)}(dot(C28{j28,r28},X28{r28}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn28: ∀n28∈ℕ, ∀r028∈nodes28(), X28{r028}^{n28=0}=coord28{r028}; , ∀r28∈nodes28(), X28{r28}^{n28+1}=X28{r28}^{n28}+δt28^{n28}*ur28{r28};
ComputeUn28: ∀n28∈ℕ, ∀j028∈cells28(), uj28{j028}^{n28=0}={0.0,0.0}; , ∀j28∈cells28(), uj28{j28}^{n28+1}=uj28{j28}^{n28}-(δt28^{n28}/m28{j28})*∑{r28∈nodesOfCell28(j28)}(F28{j28,r28});
ComputeEn28: ∀n28∈ℕ, ∀j028∈cells28(), E28{j028}^{n28=0}=p_ic28{j028}/((γ28-1.0)*ρ_ic28{j028}); , ∀j28∈cells28(), E28{j28}^{n28+1}=E28{j28}^{n28} - (δt28^{n28} / m28{j28}) * ∑{r28∈nodesOfCell28(j28)}(dot(F28{j28,r28},ur28{r28}));
ComputeDt28: ∀n28∈ℕ, δt28^{n28=0}=option_δt_ini28;, δt28^{n28+1}=option_δt_cfl28*reduceMin{j28∈cells28()}(δtj28{j28});
ComputeTn28: ∀n28∈ℕ, t28^{n28=0}=0.0; , t28^{n28+1}=t28^{n28}+δt28^{n28+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter29: ∀j29∈cells29(), center29{j29} = (1.0/4.0) * ∑{r29∈nodesOfCell29(j29)}(coord29{r29});
IniIc29: ∀j29∈cells29(), if (center29{j29}.x < option_x_interface29) {
  ρ_ic29{j29}=option_ρ_ini_zg29;
  p_ic29{j29}=option_p_ini_zg29;
} else {
  ρ_ic29{j29}=option_ρ_ini_zd29;
  p_ic29{j29}=option_p_ini_zd29;
}

ComputeCjrIc29: ∀j29∈cells29(), ∀r29∈nodesOfCell29(j29), 
	C_ic29{j29,r29} = 0.5 * perp29(coord29{►(r29)} - coord29{◄(r29)});
IniVIc29: ∀j29∈cells29(), V_ic29{j29} = 0.5 * ∑{r29∈nodesOfCell29(j29)}(dot(C_ic29{j29,r29}, coord29{r29}));
IniM29: ∀j29∈cells29(), m29{j29} = ρ_ic29{j29} * V_ic29{j29}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr29: ∀j29∈cells29(), ∀r29∈nodesOfCell29(j29), C29{j29,r29} = 0.5 * perp29(X29{►(r29)} - X29{◄(r29)});
ComputeLjr29: ∀j29∈cells29(), ∀r29∈nodesOfCell29(j29), l29{j29,r29} = norm(C29{j29,r29});
Computeδtj29: ∀j29∈cells29(), δtj29{j29} = 2.0 * V29{j29} / (c29{j29} * ∑{r29∈nodesOfCell29(j29)}(l29{j29,r29}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity29: ∀j29∈cells29(), ρ29{j29} = m29{j29} / V29{j29};
ComputeEOSp29: ∀j29∈cells29(), p29{j29} = (γ29-1.0) * ρ29{j29} * e29{j29};
ComputeInternalEngergy29: ∀j29∈cells29(), e29{j29} = E29{j29} - 0.5 * dot(uj29{j29}, uj29{j29});
ComputeEOSc29: ∀j29∈cells29(), c29{j29} = √(γ29*p29{j29}/ρ29{j29}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr29: ∀j29∈cells29(), ∀r29∈nodesOfCell29(j29), Ajr29{j29,r29} = ((ρ29{j29}*c29{j29})/l29{j29,r29}) * tensProduct29(C29{j29,r29}, C29{j29,r29});
ComputeFjr29: ∀j29∈cells29(), ∀r29∈nodesOfCell29(j29), F29{j29,r29} = p29{j29}*C29{j29,r29} + matVectProduct29(Ajr29{j29,r29}, (uj29{j29}-ur29{r29}));
ComputeAr29: ∀r29∈nodes29(), Ar29{r29} = ∑{j29∈cellsOfNode29(r29)}(Ajr29{j29,r29});
ComputeBr29: ∀r29∈nodes29(), b29{r29} = ∑{j29∈cellsOfNode29(r29)}(p29{j29}*C29{j29,r29} + matVectProduct29(Ajr29{j29,r29}, uj29{j29}));
ComputeMt29: ∀r29∈innerNodes29(), Mt29{r29} = Ar29{r29};
ComputeBt29: ∀r29∈innerNodes29(), bt29{r29} = b29{r29};

OuterFacesComputations29: ∀k29∈outerFaces29(), {
	const ℝ epsilon29 = 1.0e-10;
	ℝ²ˣ² I29 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN29 = 0.0;
	ℝ X_MAX29 = X_EDGE_ELEMS29 * LENGTH29;
	ℝ Y_MIN29 = 0.0; 
	ℝ Y_MAX29 = Y_EDGE_ELEMS29 * LENGTH29;
	ℝ² nY29 = {0.0,1.0};
	
	∀r29∈nodesOfFace29(k29), {
		// Y boundary conditions (must be done before X)
		if ((X29{r29}.y-Y_MIN29 < epsilon29) || (X29{r29}.y-Y_MAX29 < epsilon29)) {
			ℝ sign29 = 0.0;
			if (X29{r29}.y-Y_MIN29 < epsilon29) sign29 = -1.0;
			else sign29 = 1.0;
			ℝ² n29 = sign29 * nY29;
      		ℝ²ˣ² nxn29 = tensProduct29(n29,n29);
      		ℝ²ˣ² IcP29 = I29 - nxn29;
			bt1{r29} = matVectProduct29(IcP29, b29{r29});
			Mt1{r29} = IcP29 * (Ar29{r29} * IcP29) + nxn29*trace29(Ar29{r29});
		}

		// X boundary conditions
		if ((Math.fabs(X29{r29}.x-X_MIN29) < epsilon29) || ( (Math.fabs(X29{r29}.x-X_MAX29) < epsilon29) )) {
			Mt29{r29} = I29;
			bt29{r29} = {0.0, 0.0};
		}
	}
}


ComputeU29: ∀r29∈nodes29(), ur29{r29} = matVectProduct29(inverse29(Mt29{r29}), bt29{r29});
ComputeV29: ∀j29∈cells29(), V29{j29} = 0.5 * ∑{r29∈nodesOfCell29(j29)}(dot(C29{j29,r29},X29{r29}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn29: ∀n29∈ℕ, ∀r029∈nodes29(), X29{r029}^{n29=0}=coord29{r029}; , ∀r29∈nodes29(), X29{r29}^{n29+1}=X29{r29}^{n29}+δt29^{n29}*ur29{r29};
ComputeUn29: ∀n29∈ℕ, ∀j029∈cells29(), uj29{j029}^{n29=0}={0.0,0.0}; , ∀j29∈cells29(), uj29{j29}^{n29+1}=uj29{j29}^{n29}-(δt29^{n29}/m29{j29})*∑{r29∈nodesOfCell29(j29)}(F29{j29,r29});
ComputeEn29: ∀n29∈ℕ, ∀j029∈cells29(), E29{j029}^{n29=0}=p_ic29{j029}/((γ29-1.0)*ρ_ic29{j029}); , ∀j29∈cells29(), E29{j29}^{n29+1}=E29{j29}^{n29} - (δt29^{n29} / m29{j29}) * ∑{r29∈nodesOfCell29(j29)}(dot(F29{j29,r29},ur29{r29}));
ComputeDt29: ∀n29∈ℕ, δt29^{n29=0}=option_δt_ini29;, δt29^{n29+1}=option_δt_cfl29*reduceMin{j29∈cells29()}(δtj29{j29});
ComputeTn29: ∀n29∈ℕ, t29^{n29=0}=0.0; , t29^{n29+1}=t29^{n29}+δt29^{n29+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter30: ∀j30∈cells30(), center30{j30} = (1.0/4.0) * ∑{r30∈nodesOfCell30(j30)}(coord30{r30});
IniIc30: ∀j30∈cells30(), if (center30{j30}.x < option_x_interface30) {
  ρ_ic30{j30}=option_ρ_ini_zg30;
  p_ic30{j30}=option_p_ini_zg30;
} else {
  ρ_ic30{j30}=option_ρ_ini_zd30;
  p_ic30{j30}=option_p_ini_zd30;
}

ComputeCjrIc30: ∀j30∈cells30(), ∀r30∈nodesOfCell30(j30), 
	C_ic30{j30,r30} = 0.5 * perp30(coord30{►(r30)} - coord30{◄(r30)});
IniVIc30: ∀j30∈cells30(), V_ic30{j30} = 0.5 * ∑{r30∈nodesOfCell30(j30)}(dot(C_ic30{j30,r30}, coord30{r30}));
IniM30: ∀j30∈cells30(), m30{j30} = ρ_ic30{j30} * V_ic30{j30}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr30: ∀j30∈cells30(), ∀r30∈nodesOfCell30(j30), C30{j30,r30} = 0.5 * perp30(X30{►(r30)} - X30{◄(r30)});
ComputeLjr30: ∀j30∈cells30(), ∀r30∈nodesOfCell30(j30), l30{j30,r30} = norm(C30{j30,r30});
Computeδtj30: ∀j30∈cells30(), δtj30{j30} = 2.0 * V30{j30} / (c30{j30} * ∑{r30∈nodesOfCell30(j30)}(l30{j30,r30}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity30: ∀j30∈cells30(), ρ30{j30} = m30{j30} / V30{j30};
ComputeEOSp30: ∀j30∈cells30(), p30{j30} = (γ30-1.0) * ρ30{j30} * e30{j30};
ComputeInternalEngergy30: ∀j30∈cells30(), e30{j30} = E30{j30} - 0.5 * dot(uj30{j30}, uj30{j30});
ComputeEOSc30: ∀j30∈cells30(), c30{j30} = √(γ30*p30{j30}/ρ30{j30}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr30: ∀j30∈cells30(), ∀r30∈nodesOfCell30(j30), Ajr30{j30,r30} = ((ρ30{j30}*c30{j30})/l30{j30,r30}) * tensProduct30(C30{j30,r30}, C30{j30,r30});
ComputeFjr30: ∀j30∈cells30(), ∀r30∈nodesOfCell30(j30), F30{j30,r30} = p30{j30}*C30{j30,r30} + matVectProduct30(Ajr30{j30,r30}, (uj30{j30}-ur30{r30}));
ComputeAr30: ∀r30∈nodes30(), Ar30{r30} = ∑{j30∈cellsOfNode30(r30)}(Ajr30{j30,r30});
ComputeBr30: ∀r30∈nodes30(), b30{r30} = ∑{j30∈cellsOfNode30(r30)}(p30{j30}*C30{j30,r30} + matVectProduct30(Ajr30{j30,r30}, uj30{j30}));
ComputeMt30: ∀r30∈innerNodes30(), Mt30{r30} = Ar30{r30};
ComputeBt30: ∀r30∈innerNodes30(), bt30{r30} = b30{r30};

OuterFacesComputations30: ∀k30∈outerFaces30(), {
	const ℝ epsilon30 = 1.0e-10;
	ℝ²ˣ² I30 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN30 = 0.0;
	ℝ X_MAX30 = X_EDGE_ELEMS30 * LENGTH30;
	ℝ Y_MIN30 = 0.0; 
	ℝ Y_MAX30 = Y_EDGE_ELEMS30 * LENGTH30;
	ℝ² nY30 = {0.0,1.0};
	
	∀r30∈nodesOfFace30(k30), {
		// Y boundary conditions (must be done before X)
		if ((X30{r30}.y-Y_MIN30 < epsilon30) || (X30{r30}.y-Y_MAX30 < epsilon30)) {
			ℝ sign30 = 0.0;
			if (X30{r30}.y-Y_MIN30 < epsilon30) sign30 = -1.0;
			else sign30 = 1.0;
			ℝ² n30 = sign30 * nY30;
      		ℝ²ˣ² nxn30 = tensProduct30(n30,n30);
      		ℝ²ˣ² IcP30 = I30 - nxn30;
			bt1{r30} = matVectProduct30(IcP30, b30{r30});
			Mt1{r30} = IcP30 * (Ar30{r30} * IcP30) + nxn30*trace30(Ar30{r30});
		}

		// X boundary conditions
		if ((Math.fabs(X30{r30}.x-X_MIN30) < epsilon30) || ( (Math.fabs(X30{r30}.x-X_MAX30) < epsilon30) )) {
			Mt30{r30} = I30;
			bt30{r30} = {0.0, 0.0};
		}
	}
}


ComputeU30: ∀r30∈nodes30(), ur30{r30} = matVectProduct30(inverse30(Mt30{r30}), bt30{r30});
ComputeV30: ∀j30∈cells30(), V30{j30} = 0.5 * ∑{r30∈nodesOfCell30(j30)}(dot(C30{j30,r30},X30{r30}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn30: ∀n30∈ℕ, ∀r030∈nodes30(), X30{r030}^{n30=0}=coord30{r030}; , ∀r30∈nodes30(), X30{r30}^{n30+1}=X30{r30}^{n30}+δt30^{n30}*ur30{r30};
ComputeUn30: ∀n30∈ℕ, ∀j030∈cells30(), uj30{j030}^{n30=0}={0.0,0.0}; , ∀j30∈cells30(), uj30{j30}^{n30+1}=uj30{j30}^{n30}-(δt30^{n30}/m30{j30})*∑{r30∈nodesOfCell30(j30)}(F30{j30,r30});
ComputeEn30: ∀n30∈ℕ, ∀j030∈cells30(), E30{j030}^{n30=0}=p_ic30{j030}/((γ30-1.0)*ρ_ic30{j030}); , ∀j30∈cells30(), E30{j30}^{n30+1}=E30{j30}^{n30} - (δt30^{n30} / m30{j30}) * ∑{r30∈nodesOfCell30(j30)}(dot(F30{j30,r30},ur30{r30}));
ComputeDt30: ∀n30∈ℕ, δt30^{n30=0}=option_δt_ini30;, δt30^{n30+1}=option_δt_cfl30*reduceMin{j30∈cells30()}(δtj30{j30});
ComputeTn30: ∀n30∈ℕ, t30^{n30=0}=0.0; , t30^{n30+1}=t30^{n30}+δt30^{n30+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter31: ∀j31∈cells31(), center31{j31} = (1.0/4.0) * ∑{r31∈nodesOfCell31(j31)}(coord31{r31});
IniIc31: ∀j31∈cells31(), if (center31{j31}.x < option_x_interface31) {
  ρ_ic31{j31}=option_ρ_ini_zg31;
  p_ic31{j31}=option_p_ini_zg31;
} else {
  ρ_ic31{j31}=option_ρ_ini_zd31;
  p_ic31{j31}=option_p_ini_zd31;
}

ComputeCjrIc31: ∀j31∈cells31(), ∀r31∈nodesOfCell31(j31), 
	C_ic31{j31,r31} = 0.5 * perp31(coord31{►(r31)} - coord31{◄(r31)});
IniVIc31: ∀j31∈cells31(), V_ic31{j31} = 0.5 * ∑{r31∈nodesOfCell31(j31)}(dot(C_ic31{j31,r31}, coord31{r31}));
IniM31: ∀j31∈cells31(), m31{j31} = ρ_ic31{j31} * V_ic31{j31}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr31: ∀j31∈cells31(), ∀r31∈nodesOfCell31(j31), C31{j31,r31} = 0.5 * perp31(X31{►(r31)} - X31{◄(r31)});
ComputeLjr31: ∀j31∈cells31(), ∀r31∈nodesOfCell31(j31), l31{j31,r31} = norm(C31{j31,r31});
Computeδtj31: ∀j31∈cells31(), δtj31{j31} = 2.0 * V31{j31} / (c31{j31} * ∑{r31∈nodesOfCell31(j31)}(l31{j31,r31}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity31: ∀j31∈cells31(), ρ31{j31} = m31{j31} / V31{j31};
ComputeEOSp31: ∀j31∈cells31(), p31{j31} = (γ31-1.0) * ρ31{j31} * e31{j31};
ComputeInternalEngergy31: ∀j31∈cells31(), e31{j31} = E31{j31} - 0.5 * dot(uj31{j31}, uj31{j31});
ComputeEOSc31: ∀j31∈cells31(), c31{j31} = √(γ31*p31{j31}/ρ31{j31}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr31: ∀j31∈cells31(), ∀r31∈nodesOfCell31(j31), Ajr31{j31,r31} = ((ρ31{j31}*c31{j31})/l31{j31,r31}) * tensProduct31(C31{j31,r31}, C31{j31,r31});
ComputeFjr31: ∀j31∈cells31(), ∀r31∈nodesOfCell31(j31), F31{j31,r31} = p31{j31}*C31{j31,r31} + matVectProduct31(Ajr31{j31,r31}, (uj31{j31}-ur31{r31}));
ComputeAr31: ∀r31∈nodes31(), Ar31{r31} = ∑{j31∈cellsOfNode31(r31)}(Ajr31{j31,r31});
ComputeBr31: ∀r31∈nodes31(), b31{r31} = ∑{j31∈cellsOfNode31(r31)}(p31{j31}*C31{j31,r31} + matVectProduct31(Ajr31{j31,r31}, uj31{j31}));
ComputeMt31: ∀r31∈innerNodes31(), Mt31{r31} = Ar31{r31};
ComputeBt31: ∀r31∈innerNodes31(), bt31{r31} = b31{r31};

OuterFacesComputations31: ∀k31∈outerFaces31(), {
	const ℝ epsilon31 = 1.0e-10;
	ℝ²ˣ² I31 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN31 = 0.0;
	ℝ X_MAX31 = X_EDGE_ELEMS31 * LENGTH31;
	ℝ Y_MIN31 = 0.0; 
	ℝ Y_MAX31 = Y_EDGE_ELEMS31 * LENGTH31;
	ℝ² nY31 = {0.0,1.0};
	
	∀r31∈nodesOfFace31(k31), {
		// Y boundary conditions (must be done before X)
		if ((X31{r31}.y-Y_MIN31 < epsilon31) || (X31{r31}.y-Y_MAX31 < epsilon31)) {
			ℝ sign31 = 0.0;
			if (X31{r31}.y-Y_MIN31 < epsilon31) sign31 = -1.0;
			else sign31 = 1.0;
			ℝ² n31 = sign31 * nY31;
      		ℝ²ˣ² nxn31 = tensProduct31(n31,n31);
      		ℝ²ˣ² IcP31 = I31 - nxn31;
			bt1{r31} = matVectProduct31(IcP31, b31{r31});
			Mt1{r31} = IcP31 * (Ar31{r31} * IcP31) + nxn31*trace31(Ar31{r31});
		}

		// X boundary conditions
		if ((Math.fabs(X31{r31}.x-X_MIN31) < epsilon31) || ( (Math.fabs(X31{r31}.x-X_MAX31) < epsilon31) )) {
			Mt31{r31} = I31;
			bt31{r31} = {0.0, 0.0};
		}
	}
}


ComputeU31: ∀r31∈nodes31(), ur31{r31} = matVectProduct31(inverse31(Mt31{r31}), bt31{r31});
ComputeV31: ∀j31∈cells31(), V31{j31} = 0.5 * ∑{r31∈nodesOfCell31(j31)}(dot(C31{j31,r31},X31{r31}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn31: ∀n31∈ℕ, ∀r031∈nodes31(), X31{r031}^{n31=0}=coord31{r031}; , ∀r31∈nodes31(), X31{r31}^{n31+1}=X31{r31}^{n31}+δt31^{n31}*ur31{r31};
ComputeUn31: ∀n31∈ℕ, ∀j031∈cells31(), uj31{j031}^{n31=0}={0.0,0.0}; , ∀j31∈cells31(), uj31{j31}^{n31+1}=uj31{j31}^{n31}-(δt31^{n31}/m31{j31})*∑{r31∈nodesOfCell31(j31)}(F31{j31,r31});
ComputeEn31: ∀n31∈ℕ, ∀j031∈cells31(), E31{j031}^{n31=0}=p_ic31{j031}/((γ31-1.0)*ρ_ic31{j031}); , ∀j31∈cells31(), E31{j31}^{n31+1}=E31{j31}^{n31} - (δt31^{n31} / m31{j31}) * ∑{r31∈nodesOfCell31(j31)}(dot(F31{j31,r31},ur31{r31}));
ComputeDt31: ∀n31∈ℕ, δt31^{n31=0}=option_δt_ini31;, δt31^{n31+1}=option_δt_cfl31*reduceMin{j31∈cells31()}(δtj31{j31});
ComputeTn31: ∀n31∈ℕ, t31^{n31=0}=0.0; , t31^{n31+1}=t31^{n31}+δt31^{n31+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter32: ∀j32∈cells32(), center32{j32} = (1.0/4.0) * ∑{r32∈nodesOfCell32(j32)}(coord32{r32});
IniIc32: ∀j32∈cells32(), if (center32{j32}.x < option_x_interface32) {
  ρ_ic32{j32}=option_ρ_ini_zg32;
  p_ic32{j32}=option_p_ini_zg32;
} else {
  ρ_ic32{j32}=option_ρ_ini_zd32;
  p_ic32{j32}=option_p_ini_zd32;
}

ComputeCjrIc32: ∀j32∈cells32(), ∀r32∈nodesOfCell32(j32), 
	C_ic32{j32,r32} = 0.5 * perp32(coord32{►(r32)} - coord32{◄(r32)});
IniVIc32: ∀j32∈cells32(), V_ic32{j32} = 0.5 * ∑{r32∈nodesOfCell32(j32)}(dot(C_ic32{j32,r32}, coord32{r32}));
IniM32: ∀j32∈cells32(), m32{j32} = ρ_ic32{j32} * V_ic32{j32}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr32: ∀j32∈cells32(), ∀r32∈nodesOfCell32(j32), C32{j32,r32} = 0.5 * perp32(X32{►(r32)} - X32{◄(r32)});
ComputeLjr32: ∀j32∈cells32(), ∀r32∈nodesOfCell32(j32), l32{j32,r32} = norm(C32{j32,r32});
Computeδtj32: ∀j32∈cells32(), δtj32{j32} = 2.0 * V32{j32} / (c32{j32} * ∑{r32∈nodesOfCell32(j32)}(l32{j32,r32}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity32: ∀j32∈cells32(), ρ32{j32} = m32{j32} / V32{j32};
ComputeEOSp32: ∀j32∈cells32(), p32{j32} = (γ32-1.0) * ρ32{j32} * e32{j32};
ComputeInternalEngergy32: ∀j32∈cells32(), e32{j32} = E32{j32} - 0.5 * dot(uj32{j32}, uj32{j32});
ComputeEOSc32: ∀j32∈cells32(), c32{j32} = √(γ32*p32{j32}/ρ32{j32}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr32: ∀j32∈cells32(), ∀r32∈nodesOfCell32(j32), Ajr32{j32,r32} = ((ρ32{j32}*c32{j32})/l32{j32,r32}) * tensProduct32(C32{j32,r32}, C32{j32,r32});
ComputeFjr32: ∀j32∈cells32(), ∀r32∈nodesOfCell32(j32), F32{j32,r32} = p32{j32}*C32{j32,r32} + matVectProduct32(Ajr32{j32,r32}, (uj32{j32}-ur32{r32}));
ComputeAr32: ∀r32∈nodes32(), Ar32{r32} = ∑{j32∈cellsOfNode32(r32)}(Ajr32{j32,r32});
ComputeBr32: ∀r32∈nodes32(), b32{r32} = ∑{j32∈cellsOfNode32(r32)}(p32{j32}*C32{j32,r32} + matVectProduct32(Ajr32{j32,r32}, uj32{j32}));
ComputeMt32: ∀r32∈innerNodes32(), Mt32{r32} = Ar32{r32};
ComputeBt32: ∀r32∈innerNodes32(), bt32{r32} = b32{r32};

OuterFacesComputations32: ∀k32∈outerFaces32(), {
	const ℝ epsilon32 = 1.0e-10;
	ℝ²ˣ² I32 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN32 = 0.0;
	ℝ X_MAX32 = X_EDGE_ELEMS32 * LENGTH32;
	ℝ Y_MIN32 = 0.0; 
	ℝ Y_MAX32 = Y_EDGE_ELEMS32 * LENGTH32;
	ℝ² nY32 = {0.0,1.0};
	
	∀r32∈nodesOfFace32(k32), {
		// Y boundary conditions (must be done before X)
		if ((X32{r32}.y-Y_MIN32 < epsilon32) || (X32{r32}.y-Y_MAX32 < epsilon32)) {
			ℝ sign32 = 0.0;
			if (X32{r32}.y-Y_MIN32 < epsilon32) sign32 = -1.0;
			else sign32 = 1.0;
			ℝ² n32 = sign32 * nY32;
      		ℝ²ˣ² nxn32 = tensProduct32(n32,n32);
      		ℝ²ˣ² IcP32 = I32 - nxn32;
			bt1{r32} = matVectProduct32(IcP32, b32{r32});
			Mt1{r32} = IcP32 * (Ar32{r32} * IcP32) + nxn32*trace32(Ar32{r32});
		}

		// X boundary conditions
		if ((Math.fabs(X32{r32}.x-X_MIN32) < epsilon32) || ( (Math.fabs(X32{r32}.x-X_MAX32) < epsilon32) )) {
			Mt32{r32} = I32;
			bt32{r32} = {0.0, 0.0};
		}
	}
}


ComputeU32: ∀r32∈nodes32(), ur32{r32} = matVectProduct32(inverse32(Mt32{r32}), bt32{r32});
ComputeV32: ∀j32∈cells32(), V32{j32} = 0.5 * ∑{r32∈nodesOfCell32(j32)}(dot(C32{j32,r32},X32{r32}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn32: ∀n32∈ℕ, ∀r032∈nodes32(), X32{r032}^{n32=0}=coord32{r032}; , ∀r32∈nodes32(), X32{r32}^{n32+1}=X32{r32}^{n32}+δt32^{n32}*ur32{r32};
ComputeUn32: ∀n32∈ℕ, ∀j032∈cells32(), uj32{j032}^{n32=0}={0.0,0.0}; , ∀j32∈cells32(), uj32{j32}^{n32+1}=uj32{j32}^{n32}-(δt32^{n32}/m32{j32})*∑{r32∈nodesOfCell32(j32)}(F32{j32,r32});
ComputeEn32: ∀n32∈ℕ, ∀j032∈cells32(), E32{j032}^{n32=0}=p_ic32{j032}/((γ32-1.0)*ρ_ic32{j032}); , ∀j32∈cells32(), E32{j32}^{n32+1}=E32{j32}^{n32} - (δt32^{n32} / m32{j32}) * ∑{r32∈nodesOfCell32(j32)}(dot(F32{j32,r32},ur32{r32}));
ComputeDt32: ∀n32∈ℕ, δt32^{n32=0}=option_δt_ini32;, δt32^{n32+1}=option_δt_cfl32*reduceMin{j32∈cells32()}(δtj32{j32});
ComputeTn32: ∀n32∈ℕ, t32^{n32=0}=0.0; , t32^{n32+1}=t32^{n32}+δt32^{n32+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter33: ∀j33∈cells33(), center33{j33} = (1.0/4.0) * ∑{r33∈nodesOfCell33(j33)}(coord33{r33});
IniIc33: ∀j33∈cells33(), if (center33{j33}.x < option_x_interface33) {
  ρ_ic33{j33}=option_ρ_ini_zg33;
  p_ic33{j33}=option_p_ini_zg33;
} else {
  ρ_ic33{j33}=option_ρ_ini_zd33;
  p_ic33{j33}=option_p_ini_zd33;
}

ComputeCjrIc33: ∀j33∈cells33(), ∀r33∈nodesOfCell33(j33), 
	C_ic33{j33,r33} = 0.5 * perp33(coord33{►(r33)} - coord33{◄(r33)});
IniVIc33: ∀j33∈cells33(), V_ic33{j33} = 0.5 * ∑{r33∈nodesOfCell33(j33)}(dot(C_ic33{j33,r33}, coord33{r33}));
IniM33: ∀j33∈cells33(), m33{j33} = ρ_ic33{j33} * V_ic33{j33}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr33: ∀j33∈cells33(), ∀r33∈nodesOfCell33(j33), C33{j33,r33} = 0.5 * perp33(X33{►(r33)} - X33{◄(r33)});
ComputeLjr33: ∀j33∈cells33(), ∀r33∈nodesOfCell33(j33), l33{j33,r33} = norm(C33{j33,r33});
Computeδtj33: ∀j33∈cells33(), δtj33{j33} = 2.0 * V33{j33} / (c33{j33} * ∑{r33∈nodesOfCell33(j33)}(l33{j33,r33}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity33: ∀j33∈cells33(), ρ33{j33} = m33{j33} / V33{j33};
ComputeEOSp33: ∀j33∈cells33(), p33{j33} = (γ33-1.0) * ρ33{j33} * e33{j33};
ComputeInternalEngergy33: ∀j33∈cells33(), e33{j33} = E33{j33} - 0.5 * dot(uj33{j33}, uj33{j33});
ComputeEOSc33: ∀j33∈cells33(), c33{j33} = √(γ33*p33{j33}/ρ33{j33}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr33: ∀j33∈cells33(), ∀r33∈nodesOfCell33(j33), Ajr33{j33,r33} = ((ρ33{j33}*c33{j33})/l33{j33,r33}) * tensProduct33(C33{j33,r33}, C33{j33,r33});
ComputeFjr33: ∀j33∈cells33(), ∀r33∈nodesOfCell33(j33), F33{j33,r33} = p33{j33}*C33{j33,r33} + matVectProduct33(Ajr33{j33,r33}, (uj33{j33}-ur33{r33}));
ComputeAr33: ∀r33∈nodes33(), Ar33{r33} = ∑{j33∈cellsOfNode33(r33)}(Ajr33{j33,r33});
ComputeBr33: ∀r33∈nodes33(), b33{r33} = ∑{j33∈cellsOfNode33(r33)}(p33{j33}*C33{j33,r33} + matVectProduct33(Ajr33{j33,r33}, uj33{j33}));
ComputeMt33: ∀r33∈innerNodes33(), Mt33{r33} = Ar33{r33};
ComputeBt33: ∀r33∈innerNodes33(), bt33{r33} = b33{r33};

OuterFacesComputations33: ∀k33∈outerFaces33(), {
	const ℝ epsilon33 = 1.0e-10;
	ℝ²ˣ² I33 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN33 = 0.0;
	ℝ X_MAX33 = X_EDGE_ELEMS33 * LENGTH33;
	ℝ Y_MIN33 = 0.0; 
	ℝ Y_MAX33 = Y_EDGE_ELEMS33 * LENGTH33;
	ℝ² nY33 = {0.0,1.0};
	
	∀r33∈nodesOfFace33(k33), {
		// Y boundary conditions (must be done before X)
		if ((X33{r33}.y-Y_MIN33 < epsilon33) || (X33{r33}.y-Y_MAX33 < epsilon33)) {
			ℝ sign33 = 0.0;
			if (X33{r33}.y-Y_MIN33 < epsilon33) sign33 = -1.0;
			else sign33 = 1.0;
			ℝ² n33 = sign33 * nY33;
      		ℝ²ˣ² nxn33 = tensProduct33(n33,n33);
      		ℝ²ˣ² IcP33 = I33 - nxn33;
			bt1{r33} = matVectProduct33(IcP33, b33{r33});
			Mt1{r33} = IcP33 * (Ar33{r33} * IcP33) + nxn33*trace33(Ar33{r33});
		}

		// X boundary conditions
		if ((Math.fabs(X33{r33}.x-X_MIN33) < epsilon33) || ( (Math.fabs(X33{r33}.x-X_MAX33) < epsilon33) )) {
			Mt33{r33} = I33;
			bt33{r33} = {0.0, 0.0};
		}
	}
}


ComputeU33: ∀r33∈nodes33(), ur33{r33} = matVectProduct33(inverse33(Mt33{r33}), bt33{r33});
ComputeV33: ∀j33∈cells33(), V33{j33} = 0.5 * ∑{r33∈nodesOfCell33(j33)}(dot(C33{j33,r33},X33{r33}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn33: ∀n33∈ℕ, ∀r033∈nodes33(), X33{r033}^{n33=0}=coord33{r033}; , ∀r33∈nodes33(), X33{r33}^{n33+1}=X33{r33}^{n33}+δt33^{n33}*ur33{r33};
ComputeUn33: ∀n33∈ℕ, ∀j033∈cells33(), uj33{j033}^{n33=0}={0.0,0.0}; , ∀j33∈cells33(), uj33{j33}^{n33+1}=uj33{j33}^{n33}-(δt33^{n33}/m33{j33})*∑{r33∈nodesOfCell33(j33)}(F33{j33,r33});
ComputeEn33: ∀n33∈ℕ, ∀j033∈cells33(), E33{j033}^{n33=0}=p_ic33{j033}/((γ33-1.0)*ρ_ic33{j033}); , ∀j33∈cells33(), E33{j33}^{n33+1}=E33{j33}^{n33} - (δt33^{n33} / m33{j33}) * ∑{r33∈nodesOfCell33(j33)}(dot(F33{j33,r33},ur33{r33}));
ComputeDt33: ∀n33∈ℕ, δt33^{n33=0}=option_δt_ini33;, δt33^{n33+1}=option_δt_cfl33*reduceMin{j33∈cells33()}(δtj33{j33});
ComputeTn33: ∀n33∈ℕ, t33^{n33=0}=0.0; , t33^{n33+1}=t33^{n33}+δt33^{n33+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter34: ∀j34∈cells34(), center34{j34} = (1.0/4.0) * ∑{r34∈nodesOfCell34(j34)}(coord34{r34});
IniIc34: ∀j34∈cells34(), if (center34{j34}.x < option_x_interface34) {
  ρ_ic34{j34}=option_ρ_ini_zg34;
  p_ic34{j34}=option_p_ini_zg34;
} else {
  ρ_ic34{j34}=option_ρ_ini_zd34;
  p_ic34{j34}=option_p_ini_zd34;
}

ComputeCjrIc34: ∀j34∈cells34(), ∀r34∈nodesOfCell34(j34), 
	C_ic34{j34,r34} = 0.5 * perp34(coord34{►(r34)} - coord34{◄(r34)});
IniVIc34: ∀j34∈cells34(), V_ic34{j34} = 0.5 * ∑{r34∈nodesOfCell34(j34)}(dot(C_ic34{j34,r34}, coord34{r34}));
IniM34: ∀j34∈cells34(), m34{j34} = ρ_ic34{j34} * V_ic34{j34}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr34: ∀j34∈cells34(), ∀r34∈nodesOfCell34(j34), C34{j34,r34} = 0.5 * perp34(X34{►(r34)} - X34{◄(r34)});
ComputeLjr34: ∀j34∈cells34(), ∀r34∈nodesOfCell34(j34), l34{j34,r34} = norm(C34{j34,r34});
Computeδtj34: ∀j34∈cells34(), δtj34{j34} = 2.0 * V34{j34} / (c34{j34} * ∑{r34∈nodesOfCell34(j34)}(l34{j34,r34}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity34: ∀j34∈cells34(), ρ34{j34} = m34{j34} / V34{j34};
ComputeEOSp34: ∀j34∈cells34(), p34{j34} = (γ34-1.0) * ρ34{j34} * e34{j34};
ComputeInternalEngergy34: ∀j34∈cells34(), e34{j34} = E34{j34} - 0.5 * dot(uj34{j34}, uj34{j34});
ComputeEOSc34: ∀j34∈cells34(), c34{j34} = √(γ34*p34{j34}/ρ34{j34}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr34: ∀j34∈cells34(), ∀r34∈nodesOfCell34(j34), Ajr34{j34,r34} = ((ρ34{j34}*c34{j34})/l34{j34,r34}) * tensProduct34(C34{j34,r34}, C34{j34,r34});
ComputeFjr34: ∀j34∈cells34(), ∀r34∈nodesOfCell34(j34), F34{j34,r34} = p34{j34}*C34{j34,r34} + matVectProduct34(Ajr34{j34,r34}, (uj34{j34}-ur34{r34}));
ComputeAr34: ∀r34∈nodes34(), Ar34{r34} = ∑{j34∈cellsOfNode34(r34)}(Ajr34{j34,r34});
ComputeBr34: ∀r34∈nodes34(), b34{r34} = ∑{j34∈cellsOfNode34(r34)}(p34{j34}*C34{j34,r34} + matVectProduct34(Ajr34{j34,r34}, uj34{j34}));
ComputeMt34: ∀r34∈innerNodes34(), Mt34{r34} = Ar34{r34};
ComputeBt34: ∀r34∈innerNodes34(), bt34{r34} = b34{r34};

OuterFacesComputations34: ∀k34∈outerFaces34(), {
	const ℝ epsilon34 = 1.0e-10;
	ℝ²ˣ² I34 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN34 = 0.0;
	ℝ X_MAX34 = X_EDGE_ELEMS34 * LENGTH34;
	ℝ Y_MIN34 = 0.0; 
	ℝ Y_MAX34 = Y_EDGE_ELEMS34 * LENGTH34;
	ℝ² nY34 = {0.0,1.0};
	
	∀r34∈nodesOfFace34(k34), {
		// Y boundary conditions (must be done before X)
		if ((X34{r34}.y-Y_MIN34 < epsilon34) || (X34{r34}.y-Y_MAX34 < epsilon34)) {
			ℝ sign34 = 0.0;
			if (X34{r34}.y-Y_MIN34 < epsilon34) sign34 = -1.0;
			else sign34 = 1.0;
			ℝ² n34 = sign34 * nY34;
      		ℝ²ˣ² nxn34 = tensProduct34(n34,n34);
      		ℝ²ˣ² IcP34 = I34 - nxn34;
			bt1{r34} = matVectProduct34(IcP34, b34{r34});
			Mt1{r34} = IcP34 * (Ar34{r34} * IcP34) + nxn34*trace34(Ar34{r34});
		}

		// X boundary conditions
		if ((Math.fabs(X34{r34}.x-X_MIN34) < epsilon34) || ( (Math.fabs(X34{r34}.x-X_MAX34) < epsilon34) )) {
			Mt34{r34} = I34;
			bt34{r34} = {0.0, 0.0};
		}
	}
}


ComputeU34: ∀r34∈nodes34(), ur34{r34} = matVectProduct34(inverse34(Mt34{r34}), bt34{r34});
ComputeV34: ∀j34∈cells34(), V34{j34} = 0.5 * ∑{r34∈nodesOfCell34(j34)}(dot(C34{j34,r34},X34{r34}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn34: ∀n34∈ℕ, ∀r034∈nodes34(), X34{r034}^{n34=0}=coord34{r034}; , ∀r34∈nodes34(), X34{r34}^{n34+1}=X34{r34}^{n34}+δt34^{n34}*ur34{r34};
ComputeUn34: ∀n34∈ℕ, ∀j034∈cells34(), uj34{j034}^{n34=0}={0.0,0.0}; , ∀j34∈cells34(), uj34{j34}^{n34+1}=uj34{j34}^{n34}-(δt34^{n34}/m34{j34})*∑{r34∈nodesOfCell34(j34)}(F34{j34,r34});
ComputeEn34: ∀n34∈ℕ, ∀j034∈cells34(), E34{j034}^{n34=0}=p_ic34{j034}/((γ34-1.0)*ρ_ic34{j034}); , ∀j34∈cells34(), E34{j34}^{n34+1}=E34{j34}^{n34} - (δt34^{n34} / m34{j34}) * ∑{r34∈nodesOfCell34(j34)}(dot(F34{j34,r34},ur34{r34}));
ComputeDt34: ∀n34∈ℕ, δt34^{n34=0}=option_δt_ini34;, δt34^{n34+1}=option_δt_cfl34*reduceMin{j34∈cells34()}(δtj34{j34});
ComputeTn34: ∀n34∈ℕ, t34^{n34=0}=0.0; , t34^{n34+1}=t34^{n34}+δt34^{n34+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter35: ∀j35∈cells35(), center35{j35} = (1.0/4.0) * ∑{r35∈nodesOfCell35(j35)}(coord35{r35});
IniIc35: ∀j35∈cells35(), if (center35{j35}.x < option_x_interface35) {
  ρ_ic35{j35}=option_ρ_ini_zg35;
  p_ic35{j35}=option_p_ini_zg35;
} else {
  ρ_ic35{j35}=option_ρ_ini_zd35;
  p_ic35{j35}=option_p_ini_zd35;
}

ComputeCjrIc35: ∀j35∈cells35(), ∀r35∈nodesOfCell35(j35), 
	C_ic35{j35,r35} = 0.5 * perp35(coord35{►(r35)} - coord35{◄(r35)});
IniVIc35: ∀j35∈cells35(), V_ic35{j35} = 0.5 * ∑{r35∈nodesOfCell35(j35)}(dot(C_ic35{j35,r35}, coord35{r35}));
IniM35: ∀j35∈cells35(), m35{j35} = ρ_ic35{j35} * V_ic35{j35}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr35: ∀j35∈cells35(), ∀r35∈nodesOfCell35(j35), C35{j35,r35} = 0.5 * perp35(X35{►(r35)} - X35{◄(r35)});
ComputeLjr35: ∀j35∈cells35(), ∀r35∈nodesOfCell35(j35), l35{j35,r35} = norm(C35{j35,r35});
Computeδtj35: ∀j35∈cells35(), δtj35{j35} = 2.0 * V35{j35} / (c35{j35} * ∑{r35∈nodesOfCell35(j35)}(l35{j35,r35}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity35: ∀j35∈cells35(), ρ35{j35} = m35{j35} / V35{j35};
ComputeEOSp35: ∀j35∈cells35(), p35{j35} = (γ35-1.0) * ρ35{j35} * e35{j35};
ComputeInternalEngergy35: ∀j35∈cells35(), e35{j35} = E35{j35} - 0.5 * dot(uj35{j35}, uj35{j35});
ComputeEOSc35: ∀j35∈cells35(), c35{j35} = √(γ35*p35{j35}/ρ35{j35}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr35: ∀j35∈cells35(), ∀r35∈nodesOfCell35(j35), Ajr35{j35,r35} = ((ρ35{j35}*c35{j35})/l35{j35,r35}) * tensProduct35(C35{j35,r35}, C35{j35,r35});
ComputeFjr35: ∀j35∈cells35(), ∀r35∈nodesOfCell35(j35), F35{j35,r35} = p35{j35}*C35{j35,r35} + matVectProduct35(Ajr35{j35,r35}, (uj35{j35}-ur35{r35}));
ComputeAr35: ∀r35∈nodes35(), Ar35{r35} = ∑{j35∈cellsOfNode35(r35)}(Ajr35{j35,r35});
ComputeBr35: ∀r35∈nodes35(), b35{r35} = ∑{j35∈cellsOfNode35(r35)}(p35{j35}*C35{j35,r35} + matVectProduct35(Ajr35{j35,r35}, uj35{j35}));
ComputeMt35: ∀r35∈innerNodes35(), Mt35{r35} = Ar35{r35};
ComputeBt35: ∀r35∈innerNodes35(), bt35{r35} = b35{r35};

OuterFacesComputations35: ∀k35∈outerFaces35(), {
	const ℝ epsilon35 = 1.0e-10;
	ℝ²ˣ² I35 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN35 = 0.0;
	ℝ X_MAX35 = X_EDGE_ELEMS35 * LENGTH35;
	ℝ Y_MIN35 = 0.0; 
	ℝ Y_MAX35 = Y_EDGE_ELEMS35 * LENGTH35;
	ℝ² nY35 = {0.0,1.0};
	
	∀r35∈nodesOfFace35(k35), {
		// Y boundary conditions (must be done before X)
		if ((X35{r35}.y-Y_MIN35 < epsilon35) || (X35{r35}.y-Y_MAX35 < epsilon35)) {
			ℝ sign35 = 0.0;
			if (X35{r35}.y-Y_MIN35 < epsilon35) sign35 = -1.0;
			else sign35 = 1.0;
			ℝ² n35 = sign35 * nY35;
      		ℝ²ˣ² nxn35 = tensProduct35(n35,n35);
      		ℝ²ˣ² IcP35 = I35 - nxn35;
			bt1{r35} = matVectProduct35(IcP35, b35{r35});
			Mt1{r35} = IcP35 * (Ar35{r35} * IcP35) + nxn35*trace35(Ar35{r35});
		}

		// X boundary conditions
		if ((Math.fabs(X35{r35}.x-X_MIN35) < epsilon35) || ( (Math.fabs(X35{r35}.x-X_MAX35) < epsilon35) )) {
			Mt35{r35} = I35;
			bt35{r35} = {0.0, 0.0};
		}
	}
}


ComputeU35: ∀r35∈nodes35(), ur35{r35} = matVectProduct35(inverse35(Mt35{r35}), bt35{r35});
ComputeV35: ∀j35∈cells35(), V35{j35} = 0.5 * ∑{r35∈nodesOfCell35(j35)}(dot(C35{j35,r35},X35{r35}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn35: ∀n35∈ℕ, ∀r035∈nodes35(), X35{r035}^{n35=0}=coord35{r035}; , ∀r35∈nodes35(), X35{r35}^{n35+1}=X35{r35}^{n35}+δt35^{n35}*ur35{r35};
ComputeUn35: ∀n35∈ℕ, ∀j035∈cells35(), uj35{j035}^{n35=0}={0.0,0.0}; , ∀j35∈cells35(), uj35{j35}^{n35+1}=uj35{j35}^{n35}-(δt35^{n35}/m35{j35})*∑{r35∈nodesOfCell35(j35)}(F35{j35,r35});
ComputeEn35: ∀n35∈ℕ, ∀j035∈cells35(), E35{j035}^{n35=0}=p_ic35{j035}/((γ35-1.0)*ρ_ic35{j035}); , ∀j35∈cells35(), E35{j35}^{n35+1}=E35{j35}^{n35} - (δt35^{n35} / m35{j35}) * ∑{r35∈nodesOfCell35(j35)}(dot(F35{j35,r35},ur35{r35}));
ComputeDt35: ∀n35∈ℕ, δt35^{n35=0}=option_δt_ini35;, δt35^{n35+1}=option_δt_cfl35*reduceMin{j35∈cells35()}(δtj35{j35});
ComputeTn35: ∀n35∈ℕ, t35^{n35=0}=0.0; , t35^{n35+1}=t35^{n35}+δt35^{n35+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter36: ∀j36∈cells36(), center36{j36} = (1.0/4.0) * ∑{r36∈nodesOfCell36(j36)}(coord36{r36});
IniIc36: ∀j36∈cells36(), if (center36{j36}.x < option_x_interface36) {
  ρ_ic36{j36}=option_ρ_ini_zg36;
  p_ic36{j36}=option_p_ini_zg36;
} else {
  ρ_ic36{j36}=option_ρ_ini_zd36;
  p_ic36{j36}=option_p_ini_zd36;
}

ComputeCjrIc36: ∀j36∈cells36(), ∀r36∈nodesOfCell36(j36), 
	C_ic36{j36,r36} = 0.5 * perp36(coord36{►(r36)} - coord36{◄(r36)});
IniVIc36: ∀j36∈cells36(), V_ic36{j36} = 0.5 * ∑{r36∈nodesOfCell36(j36)}(dot(C_ic36{j36,r36}, coord36{r36}));
IniM36: ∀j36∈cells36(), m36{j36} = ρ_ic36{j36} * V_ic36{j36}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr36: ∀j36∈cells36(), ∀r36∈nodesOfCell36(j36), C36{j36,r36} = 0.5 * perp36(X36{►(r36)} - X36{◄(r36)});
ComputeLjr36: ∀j36∈cells36(), ∀r36∈nodesOfCell36(j36), l36{j36,r36} = norm(C36{j36,r36});
Computeδtj36: ∀j36∈cells36(), δtj36{j36} = 2.0 * V36{j36} / (c36{j36} * ∑{r36∈nodesOfCell36(j36)}(l36{j36,r36}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity36: ∀j36∈cells36(), ρ36{j36} = m36{j36} / V36{j36};
ComputeEOSp36: ∀j36∈cells36(), p36{j36} = (γ36-1.0) * ρ36{j36} * e36{j36};
ComputeInternalEngergy36: ∀j36∈cells36(), e36{j36} = E36{j36} - 0.5 * dot(uj36{j36}, uj36{j36});
ComputeEOSc36: ∀j36∈cells36(), c36{j36} = √(γ36*p36{j36}/ρ36{j36}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr36: ∀j36∈cells36(), ∀r36∈nodesOfCell36(j36), Ajr36{j36,r36} = ((ρ36{j36}*c36{j36})/l36{j36,r36}) * tensProduct36(C36{j36,r36}, C36{j36,r36});
ComputeFjr36: ∀j36∈cells36(), ∀r36∈nodesOfCell36(j36), F36{j36,r36} = p36{j36}*C36{j36,r36} + matVectProduct36(Ajr36{j36,r36}, (uj36{j36}-ur36{r36}));
ComputeAr36: ∀r36∈nodes36(), Ar36{r36} = ∑{j36∈cellsOfNode36(r36)}(Ajr36{j36,r36});
ComputeBr36: ∀r36∈nodes36(), b36{r36} = ∑{j36∈cellsOfNode36(r36)}(p36{j36}*C36{j36,r36} + matVectProduct36(Ajr36{j36,r36}, uj36{j36}));
ComputeMt36: ∀r36∈innerNodes36(), Mt36{r36} = Ar36{r36};
ComputeBt36: ∀r36∈innerNodes36(), bt36{r36} = b36{r36};

OuterFacesComputations36: ∀k36∈outerFaces36(), {
	const ℝ epsilon36 = 1.0e-10;
	ℝ²ˣ² I36 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN36 = 0.0;
	ℝ X_MAX36 = X_EDGE_ELEMS36 * LENGTH36;
	ℝ Y_MIN36 = 0.0; 
	ℝ Y_MAX36 = Y_EDGE_ELEMS36 * LENGTH36;
	ℝ² nY36 = {0.0,1.0};
	
	∀r36∈nodesOfFace36(k36), {
		// Y boundary conditions (must be done before X)
		if ((X36{r36}.y-Y_MIN36 < epsilon36) || (X36{r36}.y-Y_MAX36 < epsilon36)) {
			ℝ sign36 = 0.0;
			if (X36{r36}.y-Y_MIN36 < epsilon36) sign36 = -1.0;
			else sign36 = 1.0;
			ℝ² n36 = sign36 * nY36;
      		ℝ²ˣ² nxn36 = tensProduct36(n36,n36);
      		ℝ²ˣ² IcP36 = I36 - nxn36;
			bt1{r36} = matVectProduct36(IcP36, b36{r36});
			Mt1{r36} = IcP36 * (Ar36{r36} * IcP36) + nxn36*trace36(Ar36{r36});
		}

		// X boundary conditions
		if ((Math.fabs(X36{r36}.x-X_MIN36) < epsilon36) || ( (Math.fabs(X36{r36}.x-X_MAX36) < epsilon36) )) {
			Mt36{r36} = I36;
			bt36{r36} = {0.0, 0.0};
		}
	}
}


ComputeU36: ∀r36∈nodes36(), ur36{r36} = matVectProduct36(inverse36(Mt36{r36}), bt36{r36});
ComputeV36: ∀j36∈cells36(), V36{j36} = 0.5 * ∑{r36∈nodesOfCell36(j36)}(dot(C36{j36,r36},X36{r36}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn36: ∀n36∈ℕ, ∀r036∈nodes36(), X36{r036}^{n36=0}=coord36{r036}; , ∀r36∈nodes36(), X36{r36}^{n36+1}=X36{r36}^{n36}+δt36^{n36}*ur36{r36};
ComputeUn36: ∀n36∈ℕ, ∀j036∈cells36(), uj36{j036}^{n36=0}={0.0,0.0}; , ∀j36∈cells36(), uj36{j36}^{n36+1}=uj36{j36}^{n36}-(δt36^{n36}/m36{j36})*∑{r36∈nodesOfCell36(j36)}(F36{j36,r36});
ComputeEn36: ∀n36∈ℕ, ∀j036∈cells36(), E36{j036}^{n36=0}=p_ic36{j036}/((γ36-1.0)*ρ_ic36{j036}); , ∀j36∈cells36(), E36{j36}^{n36+1}=E36{j36}^{n36} - (δt36^{n36} / m36{j36}) * ∑{r36∈nodesOfCell36(j36)}(dot(F36{j36,r36},ur36{r36}));
ComputeDt36: ∀n36∈ℕ, δt36^{n36=0}=option_δt_ini36;, δt36^{n36+1}=option_δt_cfl36*reduceMin{j36∈cells36()}(δtj36{j36});
ComputeTn36: ∀n36∈ℕ, t36^{n36=0}=0.0; , t36^{n36+1}=t36^{n36}+δt36^{n36+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter37: ∀j37∈cells37(), center37{j37} = (1.0/4.0) * ∑{r37∈nodesOfCell37(j37)}(coord37{r37});
IniIc37: ∀j37∈cells37(), if (center37{j37}.x < option_x_interface37) {
  ρ_ic37{j37}=option_ρ_ini_zg37;
  p_ic37{j37}=option_p_ini_zg37;
} else {
  ρ_ic37{j37}=option_ρ_ini_zd37;
  p_ic37{j37}=option_p_ini_zd37;
}

ComputeCjrIc37: ∀j37∈cells37(), ∀r37∈nodesOfCell37(j37), 
	C_ic37{j37,r37} = 0.5 * perp37(coord37{►(r37)} - coord37{◄(r37)});
IniVIc37: ∀j37∈cells37(), V_ic37{j37} = 0.5 * ∑{r37∈nodesOfCell37(j37)}(dot(C_ic37{j37,r37}, coord37{r37}));
IniM37: ∀j37∈cells37(), m37{j37} = ρ_ic37{j37} * V_ic37{j37}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr37: ∀j37∈cells37(), ∀r37∈nodesOfCell37(j37), C37{j37,r37} = 0.5 * perp37(X37{►(r37)} - X37{◄(r37)});
ComputeLjr37: ∀j37∈cells37(), ∀r37∈nodesOfCell37(j37), l37{j37,r37} = norm(C37{j37,r37});
Computeδtj37: ∀j37∈cells37(), δtj37{j37} = 2.0 * V37{j37} / (c37{j37} * ∑{r37∈nodesOfCell37(j37)}(l37{j37,r37}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity37: ∀j37∈cells37(), ρ37{j37} = m37{j37} / V37{j37};
ComputeEOSp37: ∀j37∈cells37(), p37{j37} = (γ37-1.0) * ρ37{j37} * e37{j37};
ComputeInternalEngergy37: ∀j37∈cells37(), e37{j37} = E37{j37} - 0.5 * dot(uj37{j37}, uj37{j37});
ComputeEOSc37: ∀j37∈cells37(), c37{j37} = √(γ37*p37{j37}/ρ37{j37}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr37: ∀j37∈cells37(), ∀r37∈nodesOfCell37(j37), Ajr37{j37,r37} = ((ρ37{j37}*c37{j37})/l37{j37,r37}) * tensProduct37(C37{j37,r37}, C37{j37,r37});
ComputeFjr37: ∀j37∈cells37(), ∀r37∈nodesOfCell37(j37), F37{j37,r37} = p37{j37}*C37{j37,r37} + matVectProduct37(Ajr37{j37,r37}, (uj37{j37}-ur37{r37}));
ComputeAr37: ∀r37∈nodes37(), Ar37{r37} = ∑{j37∈cellsOfNode37(r37)}(Ajr37{j37,r37});
ComputeBr37: ∀r37∈nodes37(), b37{r37} = ∑{j37∈cellsOfNode37(r37)}(p37{j37}*C37{j37,r37} + matVectProduct37(Ajr37{j37,r37}, uj37{j37}));
ComputeMt37: ∀r37∈innerNodes37(), Mt37{r37} = Ar37{r37};
ComputeBt37: ∀r37∈innerNodes37(), bt37{r37} = b37{r37};

OuterFacesComputations37: ∀k37∈outerFaces37(), {
	const ℝ epsilon37 = 1.0e-10;
	ℝ²ˣ² I37 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN37 = 0.0;
	ℝ X_MAX37 = X_EDGE_ELEMS37 * LENGTH37;
	ℝ Y_MIN37 = 0.0; 
	ℝ Y_MAX37 = Y_EDGE_ELEMS37 * LENGTH37;
	ℝ² nY37 = {0.0,1.0};
	
	∀r37∈nodesOfFace37(k37), {
		// Y boundary conditions (must be done before X)
		if ((X37{r37}.y-Y_MIN37 < epsilon37) || (X37{r37}.y-Y_MAX37 < epsilon37)) {
			ℝ sign37 = 0.0;
			if (X37{r37}.y-Y_MIN37 < epsilon37) sign37 = -1.0;
			else sign37 = 1.0;
			ℝ² n37 = sign37 * nY37;
      		ℝ²ˣ² nxn37 = tensProduct37(n37,n37);
      		ℝ²ˣ² IcP37 = I37 - nxn37;
			bt1{r37} = matVectProduct37(IcP37, b37{r37});
			Mt1{r37} = IcP37 * (Ar37{r37} * IcP37) + nxn37*trace37(Ar37{r37});
		}

		// X boundary conditions
		if ((Math.fabs(X37{r37}.x-X_MIN37) < epsilon37) || ( (Math.fabs(X37{r37}.x-X_MAX37) < epsilon37) )) {
			Mt37{r37} = I37;
			bt37{r37} = {0.0, 0.0};
		}
	}
}


ComputeU37: ∀r37∈nodes37(), ur37{r37} = matVectProduct37(inverse37(Mt37{r37}), bt37{r37});
ComputeV37: ∀j37∈cells37(), V37{j37} = 0.5 * ∑{r37∈nodesOfCell37(j37)}(dot(C37{j37,r37},X37{r37}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn37: ∀n37∈ℕ, ∀r037∈nodes37(), X37{r037}^{n37=0}=coord37{r037}; , ∀r37∈nodes37(), X37{r37}^{n37+1}=X37{r37}^{n37}+δt37^{n37}*ur37{r37};
ComputeUn37: ∀n37∈ℕ, ∀j037∈cells37(), uj37{j037}^{n37=0}={0.0,0.0}; , ∀j37∈cells37(), uj37{j37}^{n37+1}=uj37{j37}^{n37}-(δt37^{n37}/m37{j37})*∑{r37∈nodesOfCell37(j37)}(F37{j37,r37});
ComputeEn37: ∀n37∈ℕ, ∀j037∈cells37(), E37{j037}^{n37=0}=p_ic37{j037}/((γ37-1.0)*ρ_ic37{j037}); , ∀j37∈cells37(), E37{j37}^{n37+1}=E37{j37}^{n37} - (δt37^{n37} / m37{j37}) * ∑{r37∈nodesOfCell37(j37)}(dot(F37{j37,r37},ur37{r37}));
ComputeDt37: ∀n37∈ℕ, δt37^{n37=0}=option_δt_ini37;, δt37^{n37+1}=option_δt_cfl37*reduceMin{j37∈cells37()}(δtj37{j37});
ComputeTn37: ∀n37∈ℕ, t37^{n37=0}=0.0; , t37^{n37+1}=t37^{n37}+δt37^{n37+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter38: ∀j38∈cells38(), center38{j38} = (1.0/4.0) * ∑{r38∈nodesOfCell38(j38)}(coord38{r38});
IniIc38: ∀j38∈cells38(), if (center38{j38}.x < option_x_interface38) {
  ρ_ic38{j38}=option_ρ_ini_zg38;
  p_ic38{j38}=option_p_ini_zg38;
} else {
  ρ_ic38{j38}=option_ρ_ini_zd38;
  p_ic38{j38}=option_p_ini_zd38;
}

ComputeCjrIc38: ∀j38∈cells38(), ∀r38∈nodesOfCell38(j38), 
	C_ic38{j38,r38} = 0.5 * perp38(coord38{►(r38)} - coord38{◄(r38)});
IniVIc38: ∀j38∈cells38(), V_ic38{j38} = 0.5 * ∑{r38∈nodesOfCell38(j38)}(dot(C_ic38{j38,r38}, coord38{r38}));
IniM38: ∀j38∈cells38(), m38{j38} = ρ_ic38{j38} * V_ic38{j38}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr38: ∀j38∈cells38(), ∀r38∈nodesOfCell38(j38), C38{j38,r38} = 0.5 * perp38(X38{►(r38)} - X38{◄(r38)});
ComputeLjr38: ∀j38∈cells38(), ∀r38∈nodesOfCell38(j38), l38{j38,r38} = norm(C38{j38,r38});
Computeδtj38: ∀j38∈cells38(), δtj38{j38} = 2.0 * V38{j38} / (c38{j38} * ∑{r38∈nodesOfCell38(j38)}(l38{j38,r38}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity38: ∀j38∈cells38(), ρ38{j38} = m38{j38} / V38{j38};
ComputeEOSp38: ∀j38∈cells38(), p38{j38} = (γ38-1.0) * ρ38{j38} * e38{j38};
ComputeInternalEngergy38: ∀j38∈cells38(), e38{j38} = E38{j38} - 0.5 * dot(uj38{j38}, uj38{j38});
ComputeEOSc38: ∀j38∈cells38(), c38{j38} = √(γ38*p38{j38}/ρ38{j38}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr38: ∀j38∈cells38(), ∀r38∈nodesOfCell38(j38), Ajr38{j38,r38} = ((ρ38{j38}*c38{j38})/l38{j38,r38}) * tensProduct38(C38{j38,r38}, C38{j38,r38});
ComputeFjr38: ∀j38∈cells38(), ∀r38∈nodesOfCell38(j38), F38{j38,r38} = p38{j38}*C38{j38,r38} + matVectProduct38(Ajr38{j38,r38}, (uj38{j38}-ur38{r38}));
ComputeAr38: ∀r38∈nodes38(), Ar38{r38} = ∑{j38∈cellsOfNode38(r38)}(Ajr38{j38,r38});
ComputeBr38: ∀r38∈nodes38(), b38{r38} = ∑{j38∈cellsOfNode38(r38)}(p38{j38}*C38{j38,r38} + matVectProduct38(Ajr38{j38,r38}, uj38{j38}));
ComputeMt38: ∀r38∈innerNodes38(), Mt38{r38} = Ar38{r38};
ComputeBt38: ∀r38∈innerNodes38(), bt38{r38} = b38{r38};

OuterFacesComputations38: ∀k38∈outerFaces38(), {
	const ℝ epsilon38 = 1.0e-10;
	ℝ²ˣ² I38 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN38 = 0.0;
	ℝ X_MAX38 = X_EDGE_ELEMS38 * LENGTH38;
	ℝ Y_MIN38 = 0.0; 
	ℝ Y_MAX38 = Y_EDGE_ELEMS38 * LENGTH38;
	ℝ² nY38 = {0.0,1.0};
	
	∀r38∈nodesOfFace38(k38), {
		// Y boundary conditions (must be done before X)
		if ((X38{r38}.y-Y_MIN38 < epsilon38) || (X38{r38}.y-Y_MAX38 < epsilon38)) {
			ℝ sign38 = 0.0;
			if (X38{r38}.y-Y_MIN38 < epsilon38) sign38 = -1.0;
			else sign38 = 1.0;
			ℝ² n38 = sign38 * nY38;
      		ℝ²ˣ² nxn38 = tensProduct38(n38,n38);
      		ℝ²ˣ² IcP38 = I38 - nxn38;
			bt1{r38} = matVectProduct38(IcP38, b38{r38});
			Mt1{r38} = IcP38 * (Ar38{r38} * IcP38) + nxn38*trace38(Ar38{r38});
		}

		// X boundary conditions
		if ((Math.fabs(X38{r38}.x-X_MIN38) < epsilon38) || ( (Math.fabs(X38{r38}.x-X_MAX38) < epsilon38) )) {
			Mt38{r38} = I38;
			bt38{r38} = {0.0, 0.0};
		}
	}
}


ComputeU38: ∀r38∈nodes38(), ur38{r38} = matVectProduct38(inverse38(Mt38{r38}), bt38{r38});
ComputeV38: ∀j38∈cells38(), V38{j38} = 0.5 * ∑{r38∈nodesOfCell38(j38)}(dot(C38{j38,r38},X38{r38}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn38: ∀n38∈ℕ, ∀r038∈nodes38(), X38{r038}^{n38=0}=coord38{r038}; , ∀r38∈nodes38(), X38{r38}^{n38+1}=X38{r38}^{n38}+δt38^{n38}*ur38{r38};
ComputeUn38: ∀n38∈ℕ, ∀j038∈cells38(), uj38{j038}^{n38=0}={0.0,0.0}; , ∀j38∈cells38(), uj38{j38}^{n38+1}=uj38{j38}^{n38}-(δt38^{n38}/m38{j38})*∑{r38∈nodesOfCell38(j38)}(F38{j38,r38});
ComputeEn38: ∀n38∈ℕ, ∀j038∈cells38(), E38{j038}^{n38=0}=p_ic38{j038}/((γ38-1.0)*ρ_ic38{j038}); , ∀j38∈cells38(), E38{j38}^{n38+1}=E38{j38}^{n38} - (δt38^{n38} / m38{j38}) * ∑{r38∈nodesOfCell38(j38)}(dot(F38{j38,r38},ur38{r38}));
ComputeDt38: ∀n38∈ℕ, δt38^{n38=0}=option_δt_ini38;, δt38^{n38+1}=option_δt_cfl38*reduceMin{j38∈cells38()}(δtj38{j38});
ComputeTn38: ∀n38∈ℕ, t38^{n38=0}=0.0; , t38^{n38+1}=t38^{n38}+δt38^{n38+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter39: ∀j39∈cells39(), center39{j39} = (1.0/4.0) * ∑{r39∈nodesOfCell39(j39)}(coord39{r39});
IniIc39: ∀j39∈cells39(), if (center39{j39}.x < option_x_interface39) {
  ρ_ic39{j39}=option_ρ_ini_zg39;
  p_ic39{j39}=option_p_ini_zg39;
} else {
  ρ_ic39{j39}=option_ρ_ini_zd39;
  p_ic39{j39}=option_p_ini_zd39;
}

ComputeCjrIc39: ∀j39∈cells39(), ∀r39∈nodesOfCell39(j39), 
	C_ic39{j39,r39} = 0.5 * perp39(coord39{►(r39)} - coord39{◄(r39)});
IniVIc39: ∀j39∈cells39(), V_ic39{j39} = 0.5 * ∑{r39∈nodesOfCell39(j39)}(dot(C_ic39{j39,r39}, coord39{r39}));
IniM39: ∀j39∈cells39(), m39{j39} = ρ_ic39{j39} * V_ic39{j39}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr39: ∀j39∈cells39(), ∀r39∈nodesOfCell39(j39), C39{j39,r39} = 0.5 * perp39(X39{►(r39)} - X39{◄(r39)});
ComputeLjr39: ∀j39∈cells39(), ∀r39∈nodesOfCell39(j39), l39{j39,r39} = norm(C39{j39,r39});
Computeδtj39: ∀j39∈cells39(), δtj39{j39} = 2.0 * V39{j39} / (c39{j39} * ∑{r39∈nodesOfCell39(j39)}(l39{j39,r39}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity39: ∀j39∈cells39(), ρ39{j39} = m39{j39} / V39{j39};
ComputeEOSp39: ∀j39∈cells39(), p39{j39} = (γ39-1.0) * ρ39{j39} * e39{j39};
ComputeInternalEngergy39: ∀j39∈cells39(), e39{j39} = E39{j39} - 0.5 * dot(uj39{j39}, uj39{j39});
ComputeEOSc39: ∀j39∈cells39(), c39{j39} = √(γ39*p39{j39}/ρ39{j39}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr39: ∀j39∈cells39(), ∀r39∈nodesOfCell39(j39), Ajr39{j39,r39} = ((ρ39{j39}*c39{j39})/l39{j39,r39}) * tensProduct39(C39{j39,r39}, C39{j39,r39});
ComputeFjr39: ∀j39∈cells39(), ∀r39∈nodesOfCell39(j39), F39{j39,r39} = p39{j39}*C39{j39,r39} + matVectProduct39(Ajr39{j39,r39}, (uj39{j39}-ur39{r39}));
ComputeAr39: ∀r39∈nodes39(), Ar39{r39} = ∑{j39∈cellsOfNode39(r39)}(Ajr39{j39,r39});
ComputeBr39: ∀r39∈nodes39(), b39{r39} = ∑{j39∈cellsOfNode39(r39)}(p39{j39}*C39{j39,r39} + matVectProduct39(Ajr39{j39,r39}, uj39{j39}));
ComputeMt39: ∀r39∈innerNodes39(), Mt39{r39} = Ar39{r39};
ComputeBt39: ∀r39∈innerNodes39(), bt39{r39} = b39{r39};

OuterFacesComputations39: ∀k39∈outerFaces39(), {
	const ℝ epsilon39 = 1.0e-10;
	ℝ²ˣ² I39 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN39 = 0.0;
	ℝ X_MAX39 = X_EDGE_ELEMS39 * LENGTH39;
	ℝ Y_MIN39 = 0.0; 
	ℝ Y_MAX39 = Y_EDGE_ELEMS39 * LENGTH39;
	ℝ² nY39 = {0.0,1.0};
	
	∀r39∈nodesOfFace39(k39), {
		// Y boundary conditions (must be done before X)
		if ((X39{r39}.y-Y_MIN39 < epsilon39) || (X39{r39}.y-Y_MAX39 < epsilon39)) {
			ℝ sign39 = 0.0;
			if (X39{r39}.y-Y_MIN39 < epsilon39) sign39 = -1.0;
			else sign39 = 1.0;
			ℝ² n39 = sign39 * nY39;
      		ℝ²ˣ² nxn39 = tensProduct39(n39,n39);
      		ℝ²ˣ² IcP39 = I39 - nxn39;
			bt1{r39} = matVectProduct39(IcP39, b39{r39});
			Mt1{r39} = IcP39 * (Ar39{r39} * IcP39) + nxn39*trace39(Ar39{r39});
		}

		// X boundary conditions
		if ((Math.fabs(X39{r39}.x-X_MIN39) < epsilon39) || ( (Math.fabs(X39{r39}.x-X_MAX39) < epsilon39) )) {
			Mt39{r39} = I39;
			bt39{r39} = {0.0, 0.0};
		}
	}
}


ComputeU39: ∀r39∈nodes39(), ur39{r39} = matVectProduct39(inverse39(Mt39{r39}), bt39{r39});
ComputeV39: ∀j39∈cells39(), V39{j39} = 0.5 * ∑{r39∈nodesOfCell39(j39)}(dot(C39{j39,r39},X39{r39}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn39: ∀n39∈ℕ, ∀r039∈nodes39(), X39{r039}^{n39=0}=coord39{r039}; , ∀r39∈nodes39(), X39{r39}^{n39+1}=X39{r39}^{n39}+δt39^{n39}*ur39{r39};
ComputeUn39: ∀n39∈ℕ, ∀j039∈cells39(), uj39{j039}^{n39=0}={0.0,0.0}; , ∀j39∈cells39(), uj39{j39}^{n39+1}=uj39{j39}^{n39}-(δt39^{n39}/m39{j39})*∑{r39∈nodesOfCell39(j39)}(F39{j39,r39});
ComputeEn39: ∀n39∈ℕ, ∀j039∈cells39(), E39{j039}^{n39=0}=p_ic39{j039}/((γ39-1.0)*ρ_ic39{j039}); , ∀j39∈cells39(), E39{j39}^{n39+1}=E39{j39}^{n39} - (δt39^{n39} / m39{j39}) * ∑{r39∈nodesOfCell39(j39)}(dot(F39{j39,r39},ur39{r39}));
ComputeDt39: ∀n39∈ℕ, δt39^{n39=0}=option_δt_ini39;, δt39^{n39+1}=option_δt_cfl39*reduceMin{j39∈cells39()}(δtj39{j39});
ComputeTn39: ∀n39∈ℕ, t39^{n39=0}=0.0; , t39^{n39+1}=t39^{n39}+δt39^{n39+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter40: ∀j40∈cells40(), center40{j40} = (1.0/4.0) * ∑{r40∈nodesOfCell40(j40)}(coord40{r40});
IniIc40: ∀j40∈cells40(), if (center40{j40}.x < option_x_interface40) {
  ρ_ic40{j40}=option_ρ_ini_zg40;
  p_ic40{j40}=option_p_ini_zg40;
} else {
  ρ_ic40{j40}=option_ρ_ini_zd40;
  p_ic40{j40}=option_p_ini_zd40;
}

ComputeCjrIc40: ∀j40∈cells40(), ∀r40∈nodesOfCell40(j40), 
	C_ic40{j40,r40} = 0.5 * perp40(coord40{►(r40)} - coord40{◄(r40)});
IniVIc40: ∀j40∈cells40(), V_ic40{j40} = 0.5 * ∑{r40∈nodesOfCell40(j40)}(dot(C_ic40{j40,r40}, coord40{r40}));
IniM40: ∀j40∈cells40(), m40{j40} = ρ_ic40{j40} * V_ic40{j40}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr40: ∀j40∈cells40(), ∀r40∈nodesOfCell40(j40), C40{j40,r40} = 0.5 * perp40(X40{►(r40)} - X40{◄(r40)});
ComputeLjr40: ∀j40∈cells40(), ∀r40∈nodesOfCell40(j40), l40{j40,r40} = norm(C40{j40,r40});
Computeδtj40: ∀j40∈cells40(), δtj40{j40} = 2.0 * V40{j40} / (c40{j40} * ∑{r40∈nodesOfCell40(j40)}(l40{j40,r40}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity40: ∀j40∈cells40(), ρ40{j40} = m40{j40} / V40{j40};
ComputeEOSp40: ∀j40∈cells40(), p40{j40} = (γ40-1.0) * ρ40{j40} * e40{j40};
ComputeInternalEngergy40: ∀j40∈cells40(), e40{j40} = E40{j40} - 0.5 * dot(uj40{j40}, uj40{j40});
ComputeEOSc40: ∀j40∈cells40(), c40{j40} = √(γ40*p40{j40}/ρ40{j40}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr40: ∀j40∈cells40(), ∀r40∈nodesOfCell40(j40), Ajr40{j40,r40} = ((ρ40{j40}*c40{j40})/l40{j40,r40}) * tensProduct40(C40{j40,r40}, C40{j40,r40});
ComputeFjr40: ∀j40∈cells40(), ∀r40∈nodesOfCell40(j40), F40{j40,r40} = p40{j40}*C40{j40,r40} + matVectProduct40(Ajr40{j40,r40}, (uj40{j40}-ur40{r40}));
ComputeAr40: ∀r40∈nodes40(), Ar40{r40} = ∑{j40∈cellsOfNode40(r40)}(Ajr40{j40,r40});
ComputeBr40: ∀r40∈nodes40(), b40{r40} = ∑{j40∈cellsOfNode40(r40)}(p40{j40}*C40{j40,r40} + matVectProduct40(Ajr40{j40,r40}, uj40{j40}));
ComputeMt40: ∀r40∈innerNodes40(), Mt40{r40} = Ar40{r40};
ComputeBt40: ∀r40∈innerNodes40(), bt40{r40} = b40{r40};

OuterFacesComputations40: ∀k40∈outerFaces40(), {
	const ℝ epsilon40 = 1.0e-10;
	ℝ²ˣ² I40 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN40 = 0.0;
	ℝ X_MAX40 = X_EDGE_ELEMS40 * LENGTH40;
	ℝ Y_MIN40 = 0.0; 
	ℝ Y_MAX40 = Y_EDGE_ELEMS40 * LENGTH40;
	ℝ² nY40 = {0.0,1.0};
	
	∀r40∈nodesOfFace40(k40), {
		// Y boundary conditions (must be done before X)
		if ((X40{r40}.y-Y_MIN40 < epsilon40) || (X40{r40}.y-Y_MAX40 < epsilon40)) {
			ℝ sign40 = 0.0;
			if (X40{r40}.y-Y_MIN40 < epsilon40) sign40 = -1.0;
			else sign40 = 1.0;
			ℝ² n40 = sign40 * nY40;
      		ℝ²ˣ² nxn40 = tensProduct40(n40,n40);
      		ℝ²ˣ² IcP40 = I40 - nxn40;
			bt1{r40} = matVectProduct40(IcP40, b40{r40});
			Mt1{r40} = IcP40 * (Ar40{r40} * IcP40) + nxn40*trace40(Ar40{r40});
		}

		// X boundary conditions
		if ((Math.fabs(X40{r40}.x-X_MIN40) < epsilon40) || ( (Math.fabs(X40{r40}.x-X_MAX40) < epsilon40) )) {
			Mt40{r40} = I40;
			bt40{r40} = {0.0, 0.0};
		}
	}
}


ComputeU40: ∀r40∈nodes40(), ur40{r40} = matVectProduct40(inverse40(Mt40{r40}), bt40{r40});
ComputeV40: ∀j40∈cells40(), V40{j40} = 0.5 * ∑{r40∈nodesOfCell40(j40)}(dot(C40{j40,r40},X40{r40}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn40: ∀n40∈ℕ, ∀r040∈nodes40(), X40{r040}^{n40=0}=coord40{r040}; , ∀r40∈nodes40(), X40{r40}^{n40+1}=X40{r40}^{n40}+δt40^{n40}*ur40{r40};
ComputeUn40: ∀n40∈ℕ, ∀j040∈cells40(), uj40{j040}^{n40=0}={0.0,0.0}; , ∀j40∈cells40(), uj40{j40}^{n40+1}=uj40{j40}^{n40}-(δt40^{n40}/m40{j40})*∑{r40∈nodesOfCell40(j40)}(F40{j40,r40});
ComputeEn40: ∀n40∈ℕ, ∀j040∈cells40(), E40{j040}^{n40=0}=p_ic40{j040}/((γ40-1.0)*ρ_ic40{j040}); , ∀j40∈cells40(), E40{j40}^{n40+1}=E40{j40}^{n40} - (δt40^{n40} / m40{j40}) * ∑{r40∈nodesOfCell40(j40)}(dot(F40{j40,r40},ur40{r40}));
ComputeDt40: ∀n40∈ℕ, δt40^{n40=0}=option_δt_ini40;, δt40^{n40+1}=option_δt_cfl40*reduceMin{j40∈cells40()}(δtj40{j40});
ComputeTn40: ∀n40∈ℕ, t40^{n40=0}=0.0; , t40^{n40+1}=t40^{n40}+δt40^{n40+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter41: ∀j41∈cells41(), center41{j41} = (1.0/4.0) * ∑{r41∈nodesOfCell41(j41)}(coord41{r41});
IniIc41: ∀j41∈cells41(), if (center41{j41}.x < option_x_interface41) {
  ρ_ic41{j41}=option_ρ_ini_zg41;
  p_ic41{j41}=option_p_ini_zg41;
} else {
  ρ_ic41{j41}=option_ρ_ini_zd41;
  p_ic41{j41}=option_p_ini_zd41;
}

ComputeCjrIc41: ∀j41∈cells41(), ∀r41∈nodesOfCell41(j41), 
	C_ic41{j41,r41} = 0.5 * perp41(coord41{►(r41)} - coord41{◄(r41)});
IniVIc41: ∀j41∈cells41(), V_ic41{j41} = 0.5 * ∑{r41∈nodesOfCell41(j41)}(dot(C_ic41{j41,r41}, coord41{r41}));
IniM41: ∀j41∈cells41(), m41{j41} = ρ_ic41{j41} * V_ic41{j41}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr41: ∀j41∈cells41(), ∀r41∈nodesOfCell41(j41), C41{j41,r41} = 0.5 * perp41(X41{►(r41)} - X41{◄(r41)});
ComputeLjr41: ∀j41∈cells41(), ∀r41∈nodesOfCell41(j41), l41{j41,r41} = norm(C41{j41,r41});
Computeδtj41: ∀j41∈cells41(), δtj41{j41} = 2.0 * V41{j41} / (c41{j41} * ∑{r41∈nodesOfCell41(j41)}(l41{j41,r41}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity41: ∀j41∈cells41(), ρ41{j41} = m41{j41} / V41{j41};
ComputeEOSp41: ∀j41∈cells41(), p41{j41} = (γ41-1.0) * ρ41{j41} * e41{j41};
ComputeInternalEngergy41: ∀j41∈cells41(), e41{j41} = E41{j41} - 0.5 * dot(uj41{j41}, uj41{j41});
ComputeEOSc41: ∀j41∈cells41(), c41{j41} = √(γ41*p41{j41}/ρ41{j41}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr41: ∀j41∈cells41(), ∀r41∈nodesOfCell41(j41), Ajr41{j41,r41} = ((ρ41{j41}*c41{j41})/l41{j41,r41}) * tensProduct41(C41{j41,r41}, C41{j41,r41});
ComputeFjr41: ∀j41∈cells41(), ∀r41∈nodesOfCell41(j41), F41{j41,r41} = p41{j41}*C41{j41,r41} + matVectProduct41(Ajr41{j41,r41}, (uj41{j41}-ur41{r41}));
ComputeAr41: ∀r41∈nodes41(), Ar41{r41} = ∑{j41∈cellsOfNode41(r41)}(Ajr41{j41,r41});
ComputeBr41: ∀r41∈nodes41(), b41{r41} = ∑{j41∈cellsOfNode41(r41)}(p41{j41}*C41{j41,r41} + matVectProduct41(Ajr41{j41,r41}, uj41{j41}));
ComputeMt41: ∀r41∈innerNodes41(), Mt41{r41} = Ar41{r41};
ComputeBt41: ∀r41∈innerNodes41(), bt41{r41} = b41{r41};

OuterFacesComputations41: ∀k41∈outerFaces41(), {
	const ℝ epsilon41 = 1.0e-10;
	ℝ²ˣ² I41 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN41 = 0.0;
	ℝ X_MAX41 = X_EDGE_ELEMS41 * LENGTH41;
	ℝ Y_MIN41 = 0.0; 
	ℝ Y_MAX41 = Y_EDGE_ELEMS41 * LENGTH41;
	ℝ² nY41 = {0.0,1.0};
	
	∀r41∈nodesOfFace41(k41), {
		// Y boundary conditions (must be done before X)
		if ((X41{r41}.y-Y_MIN41 < epsilon41) || (X41{r41}.y-Y_MAX41 < epsilon41)) {
			ℝ sign41 = 0.0;
			if (X41{r41}.y-Y_MIN41 < epsilon41) sign41 = -1.0;
			else sign41 = 1.0;
			ℝ² n41 = sign41 * nY41;
      		ℝ²ˣ² nxn41 = tensProduct41(n41,n41);
      		ℝ²ˣ² IcP41 = I41 - nxn41;
			bt1{r41} = matVectProduct41(IcP41, b41{r41});
			Mt1{r41} = IcP41 * (Ar41{r41} * IcP41) + nxn41*trace41(Ar41{r41});
		}

		// X boundary conditions
		if ((Math.fabs(X41{r41}.x-X_MIN41) < epsilon41) || ( (Math.fabs(X41{r41}.x-X_MAX41) < epsilon41) )) {
			Mt41{r41} = I41;
			bt41{r41} = {0.0, 0.0};
		}
	}
}


ComputeU41: ∀r41∈nodes41(), ur41{r41} = matVectProduct41(inverse41(Mt41{r41}), bt41{r41});
ComputeV41: ∀j41∈cells41(), V41{j41} = 0.5 * ∑{r41∈nodesOfCell41(j41)}(dot(C41{j41,r41},X41{r41}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn41: ∀n41∈ℕ, ∀r041∈nodes41(), X41{r041}^{n41=0}=coord41{r041}; , ∀r41∈nodes41(), X41{r41}^{n41+1}=X41{r41}^{n41}+δt41^{n41}*ur41{r41};
ComputeUn41: ∀n41∈ℕ, ∀j041∈cells41(), uj41{j041}^{n41=0}={0.0,0.0}; , ∀j41∈cells41(), uj41{j41}^{n41+1}=uj41{j41}^{n41}-(δt41^{n41}/m41{j41})*∑{r41∈nodesOfCell41(j41)}(F41{j41,r41});
ComputeEn41: ∀n41∈ℕ, ∀j041∈cells41(), E41{j041}^{n41=0}=p_ic41{j041}/((γ41-1.0)*ρ_ic41{j041}); , ∀j41∈cells41(), E41{j41}^{n41+1}=E41{j41}^{n41} - (δt41^{n41} / m41{j41}) * ∑{r41∈nodesOfCell41(j41)}(dot(F41{j41,r41},ur41{r41}));
ComputeDt41: ∀n41∈ℕ, δt41^{n41=0}=option_δt_ini41;, δt41^{n41+1}=option_δt_cfl41*reduceMin{j41∈cells41()}(δtj41{j41});
ComputeTn41: ∀n41∈ℕ, t41^{n41=0}=0.0; , t41^{n41+1}=t41^{n41}+δt41^{n41+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter42: ∀j42∈cells42(), center42{j42} = (1.0/4.0) * ∑{r42∈nodesOfCell42(j42)}(coord42{r42});
IniIc42: ∀j42∈cells42(), if (center42{j42}.x < option_x_interface42) {
  ρ_ic42{j42}=option_ρ_ini_zg42;
  p_ic42{j42}=option_p_ini_zg42;
} else {
  ρ_ic42{j42}=option_ρ_ini_zd42;
  p_ic42{j42}=option_p_ini_zd42;
}

ComputeCjrIc42: ∀j42∈cells42(), ∀r42∈nodesOfCell42(j42), 
	C_ic42{j42,r42} = 0.5 * perp42(coord42{►(r42)} - coord42{◄(r42)});
IniVIc42: ∀j42∈cells42(), V_ic42{j42} = 0.5 * ∑{r42∈nodesOfCell42(j42)}(dot(C_ic42{j42,r42}, coord42{r42}));
IniM42: ∀j42∈cells42(), m42{j42} = ρ_ic42{j42} * V_ic42{j42}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr42: ∀j42∈cells42(), ∀r42∈nodesOfCell42(j42), C42{j42,r42} = 0.5 * perp42(X42{►(r42)} - X42{◄(r42)});
ComputeLjr42: ∀j42∈cells42(), ∀r42∈nodesOfCell42(j42), l42{j42,r42} = norm(C42{j42,r42});
Computeδtj42: ∀j42∈cells42(), δtj42{j42} = 2.0 * V42{j42} / (c42{j42} * ∑{r42∈nodesOfCell42(j42)}(l42{j42,r42}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity42: ∀j42∈cells42(), ρ42{j42} = m42{j42} / V42{j42};
ComputeEOSp42: ∀j42∈cells42(), p42{j42} = (γ42-1.0) * ρ42{j42} * e42{j42};
ComputeInternalEngergy42: ∀j42∈cells42(), e42{j42} = E42{j42} - 0.5 * dot(uj42{j42}, uj42{j42});
ComputeEOSc42: ∀j42∈cells42(), c42{j42} = √(γ42*p42{j42}/ρ42{j42}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr42: ∀j42∈cells42(), ∀r42∈nodesOfCell42(j42), Ajr42{j42,r42} = ((ρ42{j42}*c42{j42})/l42{j42,r42}) * tensProduct42(C42{j42,r42}, C42{j42,r42});
ComputeFjr42: ∀j42∈cells42(), ∀r42∈nodesOfCell42(j42), F42{j42,r42} = p42{j42}*C42{j42,r42} + matVectProduct42(Ajr42{j42,r42}, (uj42{j42}-ur42{r42}));
ComputeAr42: ∀r42∈nodes42(), Ar42{r42} = ∑{j42∈cellsOfNode42(r42)}(Ajr42{j42,r42});
ComputeBr42: ∀r42∈nodes42(), b42{r42} = ∑{j42∈cellsOfNode42(r42)}(p42{j42}*C42{j42,r42} + matVectProduct42(Ajr42{j42,r42}, uj42{j42}));
ComputeMt42: ∀r42∈innerNodes42(), Mt42{r42} = Ar42{r42};
ComputeBt42: ∀r42∈innerNodes42(), bt42{r42} = b42{r42};

OuterFacesComputations42: ∀k42∈outerFaces42(), {
	const ℝ epsilon42 = 1.0e-10;
	ℝ²ˣ² I42 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN42 = 0.0;
	ℝ X_MAX42 = X_EDGE_ELEMS42 * LENGTH42;
	ℝ Y_MIN42 = 0.0; 
	ℝ Y_MAX42 = Y_EDGE_ELEMS42 * LENGTH42;
	ℝ² nY42 = {0.0,1.0};
	
	∀r42∈nodesOfFace42(k42), {
		// Y boundary conditions (must be done before X)
		if ((X42{r42}.y-Y_MIN42 < epsilon42) || (X42{r42}.y-Y_MAX42 < epsilon42)) {
			ℝ sign42 = 0.0;
			if (X42{r42}.y-Y_MIN42 < epsilon42) sign42 = -1.0;
			else sign42 = 1.0;
			ℝ² n42 = sign42 * nY42;
      		ℝ²ˣ² nxn42 = tensProduct42(n42,n42);
      		ℝ²ˣ² IcP42 = I42 - nxn42;
			bt1{r42} = matVectProduct42(IcP42, b42{r42});
			Mt1{r42} = IcP42 * (Ar42{r42} * IcP42) + nxn42*trace42(Ar42{r42});
		}

		// X boundary conditions
		if ((Math.fabs(X42{r42}.x-X_MIN42) < epsilon42) || ( (Math.fabs(X42{r42}.x-X_MAX42) < epsilon42) )) {
			Mt42{r42} = I42;
			bt42{r42} = {0.0, 0.0};
		}
	}
}


ComputeU42: ∀r42∈nodes42(), ur42{r42} = matVectProduct42(inverse42(Mt42{r42}), bt42{r42});
ComputeV42: ∀j42∈cells42(), V42{j42} = 0.5 * ∑{r42∈nodesOfCell42(j42)}(dot(C42{j42,r42},X42{r42}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn42: ∀n42∈ℕ, ∀r042∈nodes42(), X42{r042}^{n42=0}=coord42{r042}; , ∀r42∈nodes42(), X42{r42}^{n42+1}=X42{r42}^{n42}+δt42^{n42}*ur42{r42};
ComputeUn42: ∀n42∈ℕ, ∀j042∈cells42(), uj42{j042}^{n42=0}={0.0,0.0}; , ∀j42∈cells42(), uj42{j42}^{n42+1}=uj42{j42}^{n42}-(δt42^{n42}/m42{j42})*∑{r42∈nodesOfCell42(j42)}(F42{j42,r42});
ComputeEn42: ∀n42∈ℕ, ∀j042∈cells42(), E42{j042}^{n42=0}=p_ic42{j042}/((γ42-1.0)*ρ_ic42{j042}); , ∀j42∈cells42(), E42{j42}^{n42+1}=E42{j42}^{n42} - (δt42^{n42} / m42{j42}) * ∑{r42∈nodesOfCell42(j42)}(dot(F42{j42,r42},ur42{r42}));
ComputeDt42: ∀n42∈ℕ, δt42^{n42=0}=option_δt_ini42;, δt42^{n42+1}=option_δt_cfl42*reduceMin{j42∈cells42()}(δtj42{j42});
ComputeTn42: ∀n42∈ℕ, t42^{n42=0}=0.0; , t42^{n42+1}=t42^{n42}+δt42^{n42+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter43: ∀j43∈cells43(), center43{j43} = (1.0/4.0) * ∑{r43∈nodesOfCell43(j43)}(coord43{r43});
IniIc43: ∀j43∈cells43(), if (center43{j43}.x < option_x_interface43) {
  ρ_ic43{j43}=option_ρ_ini_zg43;
  p_ic43{j43}=option_p_ini_zg43;
} else {
  ρ_ic43{j43}=option_ρ_ini_zd43;
  p_ic43{j43}=option_p_ini_zd43;
}

ComputeCjrIc43: ∀j43∈cells43(), ∀r43∈nodesOfCell43(j43), 
	C_ic43{j43,r43} = 0.5 * perp43(coord43{►(r43)} - coord43{◄(r43)});
IniVIc43: ∀j43∈cells43(), V_ic43{j43} = 0.5 * ∑{r43∈nodesOfCell43(j43)}(dot(C_ic43{j43,r43}, coord43{r43}));
IniM43: ∀j43∈cells43(), m43{j43} = ρ_ic43{j43} * V_ic43{j43}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr43: ∀j43∈cells43(), ∀r43∈nodesOfCell43(j43), C43{j43,r43} = 0.5 * perp43(X43{►(r43)} - X43{◄(r43)});
ComputeLjr43: ∀j43∈cells43(), ∀r43∈nodesOfCell43(j43), l43{j43,r43} = norm(C43{j43,r43});
Computeδtj43: ∀j43∈cells43(), δtj43{j43} = 2.0 * V43{j43} / (c43{j43} * ∑{r43∈nodesOfCell43(j43)}(l43{j43,r43}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity43: ∀j43∈cells43(), ρ43{j43} = m43{j43} / V43{j43};
ComputeEOSp43: ∀j43∈cells43(), p43{j43} = (γ43-1.0) * ρ43{j43} * e43{j43};
ComputeInternalEngergy43: ∀j43∈cells43(), e43{j43} = E43{j43} - 0.5 * dot(uj43{j43}, uj43{j43});
ComputeEOSc43: ∀j43∈cells43(), c43{j43} = √(γ43*p43{j43}/ρ43{j43}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr43: ∀j43∈cells43(), ∀r43∈nodesOfCell43(j43), Ajr43{j43,r43} = ((ρ43{j43}*c43{j43})/l43{j43,r43}) * tensProduct43(C43{j43,r43}, C43{j43,r43});
ComputeFjr43: ∀j43∈cells43(), ∀r43∈nodesOfCell43(j43), F43{j43,r43} = p43{j43}*C43{j43,r43} + matVectProduct43(Ajr43{j43,r43}, (uj43{j43}-ur43{r43}));
ComputeAr43: ∀r43∈nodes43(), Ar43{r43} = ∑{j43∈cellsOfNode43(r43)}(Ajr43{j43,r43});
ComputeBr43: ∀r43∈nodes43(), b43{r43} = ∑{j43∈cellsOfNode43(r43)}(p43{j43}*C43{j43,r43} + matVectProduct43(Ajr43{j43,r43}, uj43{j43}));
ComputeMt43: ∀r43∈innerNodes43(), Mt43{r43} = Ar43{r43};
ComputeBt43: ∀r43∈innerNodes43(), bt43{r43} = b43{r43};

OuterFacesComputations43: ∀k43∈outerFaces43(), {
	const ℝ epsilon43 = 1.0e-10;
	ℝ²ˣ² I43 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN43 = 0.0;
	ℝ X_MAX43 = X_EDGE_ELEMS43 * LENGTH43;
	ℝ Y_MIN43 = 0.0; 
	ℝ Y_MAX43 = Y_EDGE_ELEMS43 * LENGTH43;
	ℝ² nY43 = {0.0,1.0};
	
	∀r43∈nodesOfFace43(k43), {
		// Y boundary conditions (must be done before X)
		if ((X43{r43}.y-Y_MIN43 < epsilon43) || (X43{r43}.y-Y_MAX43 < epsilon43)) {
			ℝ sign43 = 0.0;
			if (X43{r43}.y-Y_MIN43 < epsilon43) sign43 = -1.0;
			else sign43 = 1.0;
			ℝ² n43 = sign43 * nY43;
      		ℝ²ˣ² nxn43 = tensProduct43(n43,n43);
      		ℝ²ˣ² IcP43 = I43 - nxn43;
			bt1{r43} = matVectProduct43(IcP43, b43{r43});
			Mt1{r43} = IcP43 * (Ar43{r43} * IcP43) + nxn43*trace43(Ar43{r43});
		}

		// X boundary conditions
		if ((Math.fabs(X43{r43}.x-X_MIN43) < epsilon43) || ( (Math.fabs(X43{r43}.x-X_MAX43) < epsilon43) )) {
			Mt43{r43} = I43;
			bt43{r43} = {0.0, 0.0};
		}
	}
}


ComputeU43: ∀r43∈nodes43(), ur43{r43} = matVectProduct43(inverse43(Mt43{r43}), bt43{r43});
ComputeV43: ∀j43∈cells43(), V43{j43} = 0.5 * ∑{r43∈nodesOfCell43(j43)}(dot(C43{j43,r43},X43{r43}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn43: ∀n43∈ℕ, ∀r043∈nodes43(), X43{r043}^{n43=0}=coord43{r043}; , ∀r43∈nodes43(), X43{r43}^{n43+1}=X43{r43}^{n43}+δt43^{n43}*ur43{r43};
ComputeUn43: ∀n43∈ℕ, ∀j043∈cells43(), uj43{j043}^{n43=0}={0.0,0.0}; , ∀j43∈cells43(), uj43{j43}^{n43+1}=uj43{j43}^{n43}-(δt43^{n43}/m43{j43})*∑{r43∈nodesOfCell43(j43)}(F43{j43,r43});
ComputeEn43: ∀n43∈ℕ, ∀j043∈cells43(), E43{j043}^{n43=0}=p_ic43{j043}/((γ43-1.0)*ρ_ic43{j043}); , ∀j43∈cells43(), E43{j43}^{n43+1}=E43{j43}^{n43} - (δt43^{n43} / m43{j43}) * ∑{r43∈nodesOfCell43(j43)}(dot(F43{j43,r43},ur43{r43}));
ComputeDt43: ∀n43∈ℕ, δt43^{n43=0}=option_δt_ini43;, δt43^{n43+1}=option_δt_cfl43*reduceMin{j43∈cells43()}(δtj43{j43});
ComputeTn43: ∀n43∈ℕ, t43^{n43=0}=0.0; , t43^{n43+1}=t43^{n43}+δt43^{n43+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter44: ∀j44∈cells44(), center44{j44} = (1.0/4.0) * ∑{r44∈nodesOfCell44(j44)}(coord44{r44});
IniIc44: ∀j44∈cells44(), if (center44{j44}.x < option_x_interface44) {
  ρ_ic44{j44}=option_ρ_ini_zg44;
  p_ic44{j44}=option_p_ini_zg44;
} else {
  ρ_ic44{j44}=option_ρ_ini_zd44;
  p_ic44{j44}=option_p_ini_zd44;
}

ComputeCjrIc44: ∀j44∈cells44(), ∀r44∈nodesOfCell44(j44), 
	C_ic44{j44,r44} = 0.5 * perp44(coord44{►(r44)} - coord44{◄(r44)});
IniVIc44: ∀j44∈cells44(), V_ic44{j44} = 0.5 * ∑{r44∈nodesOfCell44(j44)}(dot(C_ic44{j44,r44}, coord44{r44}));
IniM44: ∀j44∈cells44(), m44{j44} = ρ_ic44{j44} * V_ic44{j44}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr44: ∀j44∈cells44(), ∀r44∈nodesOfCell44(j44), C44{j44,r44} = 0.5 * perp44(X44{►(r44)} - X44{◄(r44)});
ComputeLjr44: ∀j44∈cells44(), ∀r44∈nodesOfCell44(j44), l44{j44,r44} = norm(C44{j44,r44});
Computeδtj44: ∀j44∈cells44(), δtj44{j44} = 2.0 * V44{j44} / (c44{j44} * ∑{r44∈nodesOfCell44(j44)}(l44{j44,r44}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity44: ∀j44∈cells44(), ρ44{j44} = m44{j44} / V44{j44};
ComputeEOSp44: ∀j44∈cells44(), p44{j44} = (γ44-1.0) * ρ44{j44} * e44{j44};
ComputeInternalEngergy44: ∀j44∈cells44(), e44{j44} = E44{j44} - 0.5 * dot(uj44{j44}, uj44{j44});
ComputeEOSc44: ∀j44∈cells44(), c44{j44} = √(γ44*p44{j44}/ρ44{j44}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr44: ∀j44∈cells44(), ∀r44∈nodesOfCell44(j44), Ajr44{j44,r44} = ((ρ44{j44}*c44{j44})/l44{j44,r44}) * tensProduct44(C44{j44,r44}, C44{j44,r44});
ComputeFjr44: ∀j44∈cells44(), ∀r44∈nodesOfCell44(j44), F44{j44,r44} = p44{j44}*C44{j44,r44} + matVectProduct44(Ajr44{j44,r44}, (uj44{j44}-ur44{r44}));
ComputeAr44: ∀r44∈nodes44(), Ar44{r44} = ∑{j44∈cellsOfNode44(r44)}(Ajr44{j44,r44});
ComputeBr44: ∀r44∈nodes44(), b44{r44} = ∑{j44∈cellsOfNode44(r44)}(p44{j44}*C44{j44,r44} + matVectProduct44(Ajr44{j44,r44}, uj44{j44}));
ComputeMt44: ∀r44∈innerNodes44(), Mt44{r44} = Ar44{r44};
ComputeBt44: ∀r44∈innerNodes44(), bt44{r44} = b44{r44};

OuterFacesComputations44: ∀k44∈outerFaces44(), {
	const ℝ epsilon44 = 1.0e-10;
	ℝ²ˣ² I44 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN44 = 0.0;
	ℝ X_MAX44 = X_EDGE_ELEMS44 * LENGTH44;
	ℝ Y_MIN44 = 0.0; 
	ℝ Y_MAX44 = Y_EDGE_ELEMS44 * LENGTH44;
	ℝ² nY44 = {0.0,1.0};
	
	∀r44∈nodesOfFace44(k44), {
		// Y boundary conditions (must be done before X)
		if ((X44{r44}.y-Y_MIN44 < epsilon44) || (X44{r44}.y-Y_MAX44 < epsilon44)) {
			ℝ sign44 = 0.0;
			if (X44{r44}.y-Y_MIN44 < epsilon44) sign44 = -1.0;
			else sign44 = 1.0;
			ℝ² n44 = sign44 * nY44;
      		ℝ²ˣ² nxn44 = tensProduct44(n44,n44);
      		ℝ²ˣ² IcP44 = I44 - nxn44;
			bt1{r44} = matVectProduct44(IcP44, b44{r44});
			Mt1{r44} = IcP44 * (Ar44{r44} * IcP44) + nxn44*trace44(Ar44{r44});
		}

		// X boundary conditions
		if ((Math.fabs(X44{r44}.x-X_MIN44) < epsilon44) || ( (Math.fabs(X44{r44}.x-X_MAX44) < epsilon44) )) {
			Mt44{r44} = I44;
			bt44{r44} = {0.0, 0.0};
		}
	}
}


ComputeU44: ∀r44∈nodes44(), ur44{r44} = matVectProduct44(inverse44(Mt44{r44}), bt44{r44});
ComputeV44: ∀j44∈cells44(), V44{j44} = 0.5 * ∑{r44∈nodesOfCell44(j44)}(dot(C44{j44,r44},X44{r44}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn44: ∀n44∈ℕ, ∀r044∈nodes44(), X44{r044}^{n44=0}=coord44{r044}; , ∀r44∈nodes44(), X44{r44}^{n44+1}=X44{r44}^{n44}+δt44^{n44}*ur44{r44};
ComputeUn44: ∀n44∈ℕ, ∀j044∈cells44(), uj44{j044}^{n44=0}={0.0,0.0}; , ∀j44∈cells44(), uj44{j44}^{n44+1}=uj44{j44}^{n44}-(δt44^{n44}/m44{j44})*∑{r44∈nodesOfCell44(j44)}(F44{j44,r44});
ComputeEn44: ∀n44∈ℕ, ∀j044∈cells44(), E44{j044}^{n44=0}=p_ic44{j044}/((γ44-1.0)*ρ_ic44{j044}); , ∀j44∈cells44(), E44{j44}^{n44+1}=E44{j44}^{n44} - (δt44^{n44} / m44{j44}) * ∑{r44∈nodesOfCell44(j44)}(dot(F44{j44,r44},ur44{r44}));
ComputeDt44: ∀n44∈ℕ, δt44^{n44=0}=option_δt_ini44;, δt44^{n44+1}=option_δt_cfl44*reduceMin{j44∈cells44()}(δtj44{j44});
ComputeTn44: ∀n44∈ℕ, t44^{n44=0}=0.0; , t44^{n44+1}=t44^{n44}+δt44^{n44+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter45: ∀j45∈cells45(), center45{j45} = (1.0/4.0) * ∑{r45∈nodesOfCell45(j45)}(coord45{r45});
IniIc45: ∀j45∈cells45(), if (center45{j45}.x < option_x_interface45) {
  ρ_ic45{j45}=option_ρ_ini_zg45;
  p_ic45{j45}=option_p_ini_zg45;
} else {
  ρ_ic45{j45}=option_ρ_ini_zd45;
  p_ic45{j45}=option_p_ini_zd45;
}

ComputeCjrIc45: ∀j45∈cells45(), ∀r45∈nodesOfCell45(j45), 
	C_ic45{j45,r45} = 0.5 * perp45(coord45{►(r45)} - coord45{◄(r45)});
IniVIc45: ∀j45∈cells45(), V_ic45{j45} = 0.5 * ∑{r45∈nodesOfCell45(j45)}(dot(C_ic45{j45,r45}, coord45{r45}));
IniM45: ∀j45∈cells45(), m45{j45} = ρ_ic45{j45} * V_ic45{j45}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr45: ∀j45∈cells45(), ∀r45∈nodesOfCell45(j45), C45{j45,r45} = 0.5 * perp45(X45{►(r45)} - X45{◄(r45)});
ComputeLjr45: ∀j45∈cells45(), ∀r45∈nodesOfCell45(j45), l45{j45,r45} = norm(C45{j45,r45});
Computeδtj45: ∀j45∈cells45(), δtj45{j45} = 2.0 * V45{j45} / (c45{j45} * ∑{r45∈nodesOfCell45(j45)}(l45{j45,r45}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity45: ∀j45∈cells45(), ρ45{j45} = m45{j45} / V45{j45};
ComputeEOSp45: ∀j45∈cells45(), p45{j45} = (γ45-1.0) * ρ45{j45} * e45{j45};
ComputeInternalEngergy45: ∀j45∈cells45(), e45{j45} = E45{j45} - 0.5 * dot(uj45{j45}, uj45{j45});
ComputeEOSc45: ∀j45∈cells45(), c45{j45} = √(γ45*p45{j45}/ρ45{j45}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr45: ∀j45∈cells45(), ∀r45∈nodesOfCell45(j45), Ajr45{j45,r45} = ((ρ45{j45}*c45{j45})/l45{j45,r45}) * tensProduct45(C45{j45,r45}, C45{j45,r45});
ComputeFjr45: ∀j45∈cells45(), ∀r45∈nodesOfCell45(j45), F45{j45,r45} = p45{j45}*C45{j45,r45} + matVectProduct45(Ajr45{j45,r45}, (uj45{j45}-ur45{r45}));
ComputeAr45: ∀r45∈nodes45(), Ar45{r45} = ∑{j45∈cellsOfNode45(r45)}(Ajr45{j45,r45});
ComputeBr45: ∀r45∈nodes45(), b45{r45} = ∑{j45∈cellsOfNode45(r45)}(p45{j45}*C45{j45,r45} + matVectProduct45(Ajr45{j45,r45}, uj45{j45}));
ComputeMt45: ∀r45∈innerNodes45(), Mt45{r45} = Ar45{r45};
ComputeBt45: ∀r45∈innerNodes45(), bt45{r45} = b45{r45};

OuterFacesComputations45: ∀k45∈outerFaces45(), {
	const ℝ epsilon45 = 1.0e-10;
	ℝ²ˣ² I45 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN45 = 0.0;
	ℝ X_MAX45 = X_EDGE_ELEMS45 * LENGTH45;
	ℝ Y_MIN45 = 0.0; 
	ℝ Y_MAX45 = Y_EDGE_ELEMS45 * LENGTH45;
	ℝ² nY45 = {0.0,1.0};
	
	∀r45∈nodesOfFace45(k45), {
		// Y boundary conditions (must be done before X)
		if ((X45{r45}.y-Y_MIN45 < epsilon45) || (X45{r45}.y-Y_MAX45 < epsilon45)) {
			ℝ sign45 = 0.0;
			if (X45{r45}.y-Y_MIN45 < epsilon45) sign45 = -1.0;
			else sign45 = 1.0;
			ℝ² n45 = sign45 * nY45;
      		ℝ²ˣ² nxn45 = tensProduct45(n45,n45);
      		ℝ²ˣ² IcP45 = I45 - nxn45;
			bt1{r45} = matVectProduct45(IcP45, b45{r45});
			Mt1{r45} = IcP45 * (Ar45{r45} * IcP45) + nxn45*trace45(Ar45{r45});
		}

		// X boundary conditions
		if ((Math.fabs(X45{r45}.x-X_MIN45) < epsilon45) || ( (Math.fabs(X45{r45}.x-X_MAX45) < epsilon45) )) {
			Mt45{r45} = I45;
			bt45{r45} = {0.0, 0.0};
		}
	}
}


ComputeU45: ∀r45∈nodes45(), ur45{r45} = matVectProduct45(inverse45(Mt45{r45}), bt45{r45});
ComputeV45: ∀j45∈cells45(), V45{j45} = 0.5 * ∑{r45∈nodesOfCell45(j45)}(dot(C45{j45,r45},X45{r45}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn45: ∀n45∈ℕ, ∀r045∈nodes45(), X45{r045}^{n45=0}=coord45{r045}; , ∀r45∈nodes45(), X45{r45}^{n45+1}=X45{r45}^{n45}+δt45^{n45}*ur45{r45};
ComputeUn45: ∀n45∈ℕ, ∀j045∈cells45(), uj45{j045}^{n45=0}={0.0,0.0}; , ∀j45∈cells45(), uj45{j45}^{n45+1}=uj45{j45}^{n45}-(δt45^{n45}/m45{j45})*∑{r45∈nodesOfCell45(j45)}(F45{j45,r45});
ComputeEn45: ∀n45∈ℕ, ∀j045∈cells45(), E45{j045}^{n45=0}=p_ic45{j045}/((γ45-1.0)*ρ_ic45{j045}); , ∀j45∈cells45(), E45{j45}^{n45+1}=E45{j45}^{n45} - (δt45^{n45} / m45{j45}) * ∑{r45∈nodesOfCell45(j45)}(dot(F45{j45,r45},ur45{r45}));
ComputeDt45: ∀n45∈ℕ, δt45^{n45=0}=option_δt_ini45;, δt45^{n45+1}=option_δt_cfl45*reduceMin{j45∈cells45()}(δtj45{j45});
ComputeTn45: ∀n45∈ℕ, t45^{n45=0}=0.0; , t45^{n45+1}=t45^{n45}+δt45^{n45+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter46: ∀j46∈cells46(), center46{j46} = (1.0/4.0) * ∑{r46∈nodesOfCell46(j46)}(coord46{r46});
IniIc46: ∀j46∈cells46(), if (center46{j46}.x < option_x_interface46) {
  ρ_ic46{j46}=option_ρ_ini_zg46;
  p_ic46{j46}=option_p_ini_zg46;
} else {
  ρ_ic46{j46}=option_ρ_ini_zd46;
  p_ic46{j46}=option_p_ini_zd46;
}

ComputeCjrIc46: ∀j46∈cells46(), ∀r46∈nodesOfCell46(j46), 
	C_ic46{j46,r46} = 0.5 * perp46(coord46{►(r46)} - coord46{◄(r46)});
IniVIc46: ∀j46∈cells46(), V_ic46{j46} = 0.5 * ∑{r46∈nodesOfCell46(j46)}(dot(C_ic46{j46,r46}, coord46{r46}));
IniM46: ∀j46∈cells46(), m46{j46} = ρ_ic46{j46} * V_ic46{j46}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr46: ∀j46∈cells46(), ∀r46∈nodesOfCell46(j46), C46{j46,r46} = 0.5 * perp46(X46{►(r46)} - X46{◄(r46)});
ComputeLjr46: ∀j46∈cells46(), ∀r46∈nodesOfCell46(j46), l46{j46,r46} = norm(C46{j46,r46});
Computeδtj46: ∀j46∈cells46(), δtj46{j46} = 2.0 * V46{j46} / (c46{j46} * ∑{r46∈nodesOfCell46(j46)}(l46{j46,r46}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity46: ∀j46∈cells46(), ρ46{j46} = m46{j46} / V46{j46};
ComputeEOSp46: ∀j46∈cells46(), p46{j46} = (γ46-1.0) * ρ46{j46} * e46{j46};
ComputeInternalEngergy46: ∀j46∈cells46(), e46{j46} = E46{j46} - 0.5 * dot(uj46{j46}, uj46{j46});
ComputeEOSc46: ∀j46∈cells46(), c46{j46} = √(γ46*p46{j46}/ρ46{j46}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr46: ∀j46∈cells46(), ∀r46∈nodesOfCell46(j46), Ajr46{j46,r46} = ((ρ46{j46}*c46{j46})/l46{j46,r46}) * tensProduct46(C46{j46,r46}, C46{j46,r46});
ComputeFjr46: ∀j46∈cells46(), ∀r46∈nodesOfCell46(j46), F46{j46,r46} = p46{j46}*C46{j46,r46} + matVectProduct46(Ajr46{j46,r46}, (uj46{j46}-ur46{r46}));
ComputeAr46: ∀r46∈nodes46(), Ar46{r46} = ∑{j46∈cellsOfNode46(r46)}(Ajr46{j46,r46});
ComputeBr46: ∀r46∈nodes46(), b46{r46} = ∑{j46∈cellsOfNode46(r46)}(p46{j46}*C46{j46,r46} + matVectProduct46(Ajr46{j46,r46}, uj46{j46}));
ComputeMt46: ∀r46∈innerNodes46(), Mt46{r46} = Ar46{r46};
ComputeBt46: ∀r46∈innerNodes46(), bt46{r46} = b46{r46};

OuterFacesComputations46: ∀k46∈outerFaces46(), {
	const ℝ epsilon46 = 1.0e-10;
	ℝ²ˣ² I46 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN46 = 0.0;
	ℝ X_MAX46 = X_EDGE_ELEMS46 * LENGTH46;
	ℝ Y_MIN46 = 0.0; 
	ℝ Y_MAX46 = Y_EDGE_ELEMS46 * LENGTH46;
	ℝ² nY46 = {0.0,1.0};
	
	∀r46∈nodesOfFace46(k46), {
		// Y boundary conditions (must be done before X)
		if ((X46{r46}.y-Y_MIN46 < epsilon46) || (X46{r46}.y-Y_MAX46 < epsilon46)) {
			ℝ sign46 = 0.0;
			if (X46{r46}.y-Y_MIN46 < epsilon46) sign46 = -1.0;
			else sign46 = 1.0;
			ℝ² n46 = sign46 * nY46;
      		ℝ²ˣ² nxn46 = tensProduct46(n46,n46);
      		ℝ²ˣ² IcP46 = I46 - nxn46;
			bt1{r46} = matVectProduct46(IcP46, b46{r46});
			Mt1{r46} = IcP46 * (Ar46{r46} * IcP46) + nxn46*trace46(Ar46{r46});
		}

		// X boundary conditions
		if ((Math.fabs(X46{r46}.x-X_MIN46) < epsilon46) || ( (Math.fabs(X46{r46}.x-X_MAX46) < epsilon46) )) {
			Mt46{r46} = I46;
			bt46{r46} = {0.0, 0.0};
		}
	}
}


ComputeU46: ∀r46∈nodes46(), ur46{r46} = matVectProduct46(inverse46(Mt46{r46}), bt46{r46});
ComputeV46: ∀j46∈cells46(), V46{j46} = 0.5 * ∑{r46∈nodesOfCell46(j46)}(dot(C46{j46,r46},X46{r46}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn46: ∀n46∈ℕ, ∀r046∈nodes46(), X46{r046}^{n46=0}=coord46{r046}; , ∀r46∈nodes46(), X46{r46}^{n46+1}=X46{r46}^{n46}+δt46^{n46}*ur46{r46};
ComputeUn46: ∀n46∈ℕ, ∀j046∈cells46(), uj46{j046}^{n46=0}={0.0,0.0}; , ∀j46∈cells46(), uj46{j46}^{n46+1}=uj46{j46}^{n46}-(δt46^{n46}/m46{j46})*∑{r46∈nodesOfCell46(j46)}(F46{j46,r46});
ComputeEn46: ∀n46∈ℕ, ∀j046∈cells46(), E46{j046}^{n46=0}=p_ic46{j046}/((γ46-1.0)*ρ_ic46{j046}); , ∀j46∈cells46(), E46{j46}^{n46+1}=E46{j46}^{n46} - (δt46^{n46} / m46{j46}) * ∑{r46∈nodesOfCell46(j46)}(dot(F46{j46,r46},ur46{r46}));
ComputeDt46: ∀n46∈ℕ, δt46^{n46=0}=option_δt_ini46;, δt46^{n46+1}=option_δt_cfl46*reduceMin{j46∈cells46()}(δtj46{j46});
ComputeTn46: ∀n46∈ℕ, t46^{n46=0}=0.0; , t46^{n46+1}=t46^{n46}+δt46^{n46+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter47: ∀j47∈cells47(), center47{j47} = (1.0/4.0) * ∑{r47∈nodesOfCell47(j47)}(coord47{r47});
IniIc47: ∀j47∈cells47(), if (center47{j47}.x < option_x_interface47) {
  ρ_ic47{j47}=option_ρ_ini_zg47;
  p_ic47{j47}=option_p_ini_zg47;
} else {
  ρ_ic47{j47}=option_ρ_ini_zd47;
  p_ic47{j47}=option_p_ini_zd47;
}

ComputeCjrIc47: ∀j47∈cells47(), ∀r47∈nodesOfCell47(j47), 
	C_ic47{j47,r47} = 0.5 * perp47(coord47{►(r47)} - coord47{◄(r47)});
IniVIc47: ∀j47∈cells47(), V_ic47{j47} = 0.5 * ∑{r47∈nodesOfCell47(j47)}(dot(C_ic47{j47,r47}, coord47{r47}));
IniM47: ∀j47∈cells47(), m47{j47} = ρ_ic47{j47} * V_ic47{j47}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr47: ∀j47∈cells47(), ∀r47∈nodesOfCell47(j47), C47{j47,r47} = 0.5 * perp47(X47{►(r47)} - X47{◄(r47)});
ComputeLjr47: ∀j47∈cells47(), ∀r47∈nodesOfCell47(j47), l47{j47,r47} = norm(C47{j47,r47});
Computeδtj47: ∀j47∈cells47(), δtj47{j47} = 2.0 * V47{j47} / (c47{j47} * ∑{r47∈nodesOfCell47(j47)}(l47{j47,r47}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity47: ∀j47∈cells47(), ρ47{j47} = m47{j47} / V47{j47};
ComputeEOSp47: ∀j47∈cells47(), p47{j47} = (γ47-1.0) * ρ47{j47} * e47{j47};
ComputeInternalEngergy47: ∀j47∈cells47(), e47{j47} = E47{j47} - 0.5 * dot(uj47{j47}, uj47{j47});
ComputeEOSc47: ∀j47∈cells47(), c47{j47} = √(γ47*p47{j47}/ρ47{j47}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr47: ∀j47∈cells47(), ∀r47∈nodesOfCell47(j47), Ajr47{j47,r47} = ((ρ47{j47}*c47{j47})/l47{j47,r47}) * tensProduct47(C47{j47,r47}, C47{j47,r47});
ComputeFjr47: ∀j47∈cells47(), ∀r47∈nodesOfCell47(j47), F47{j47,r47} = p47{j47}*C47{j47,r47} + matVectProduct47(Ajr47{j47,r47}, (uj47{j47}-ur47{r47}));
ComputeAr47: ∀r47∈nodes47(), Ar47{r47} = ∑{j47∈cellsOfNode47(r47)}(Ajr47{j47,r47});
ComputeBr47: ∀r47∈nodes47(), b47{r47} = ∑{j47∈cellsOfNode47(r47)}(p47{j47}*C47{j47,r47} + matVectProduct47(Ajr47{j47,r47}, uj47{j47}));
ComputeMt47: ∀r47∈innerNodes47(), Mt47{r47} = Ar47{r47};
ComputeBt47: ∀r47∈innerNodes47(), bt47{r47} = b47{r47};

OuterFacesComputations47: ∀k47∈outerFaces47(), {
	const ℝ epsilon47 = 1.0e-10;
	ℝ²ˣ² I47 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN47 = 0.0;
	ℝ X_MAX47 = X_EDGE_ELEMS47 * LENGTH47;
	ℝ Y_MIN47 = 0.0; 
	ℝ Y_MAX47 = Y_EDGE_ELEMS47 * LENGTH47;
	ℝ² nY47 = {0.0,1.0};
	
	∀r47∈nodesOfFace47(k47), {
		// Y boundary conditions (must be done before X)
		if ((X47{r47}.y-Y_MIN47 < epsilon47) || (X47{r47}.y-Y_MAX47 < epsilon47)) {
			ℝ sign47 = 0.0;
			if (X47{r47}.y-Y_MIN47 < epsilon47) sign47 = -1.0;
			else sign47 = 1.0;
			ℝ² n47 = sign47 * nY47;
      		ℝ²ˣ² nxn47 = tensProduct47(n47,n47);
      		ℝ²ˣ² IcP47 = I47 - nxn47;
			bt1{r47} = matVectProduct47(IcP47, b47{r47});
			Mt1{r47} = IcP47 * (Ar47{r47} * IcP47) + nxn47*trace47(Ar47{r47});
		}

		// X boundary conditions
		if ((Math.fabs(X47{r47}.x-X_MIN47) < epsilon47) || ( (Math.fabs(X47{r47}.x-X_MAX47) < epsilon47) )) {
			Mt47{r47} = I47;
			bt47{r47} = {0.0, 0.0};
		}
	}
}


ComputeU47: ∀r47∈nodes47(), ur47{r47} = matVectProduct47(inverse47(Mt47{r47}), bt47{r47});
ComputeV47: ∀j47∈cells47(), V47{j47} = 0.5 * ∑{r47∈nodesOfCell47(j47)}(dot(C47{j47,r47},X47{r47}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn47: ∀n47∈ℕ, ∀r047∈nodes47(), X47{r047}^{n47=0}=coord47{r047}; , ∀r47∈nodes47(), X47{r47}^{n47+1}=X47{r47}^{n47}+δt47^{n47}*ur47{r47};
ComputeUn47: ∀n47∈ℕ, ∀j047∈cells47(), uj47{j047}^{n47=0}={0.0,0.0}; , ∀j47∈cells47(), uj47{j47}^{n47+1}=uj47{j47}^{n47}-(δt47^{n47}/m47{j47})*∑{r47∈nodesOfCell47(j47)}(F47{j47,r47});
ComputeEn47: ∀n47∈ℕ, ∀j047∈cells47(), E47{j047}^{n47=0}=p_ic47{j047}/((γ47-1.0)*ρ_ic47{j047}); , ∀j47∈cells47(), E47{j47}^{n47+1}=E47{j47}^{n47} - (δt47^{n47} / m47{j47}) * ∑{r47∈nodesOfCell47(j47)}(dot(F47{j47,r47},ur47{r47}));
ComputeDt47: ∀n47∈ℕ, δt47^{n47=0}=option_δt_ini47;, δt47^{n47+1}=option_δt_cfl47*reduceMin{j47∈cells47()}(δtj47{j47});
ComputeTn47: ∀n47∈ℕ, t47^{n47=0}=0.0; , t47^{n47+1}=t47^{n47}+δt47^{n47+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter48: ∀j48∈cells48(), center48{j48} = (1.0/4.0) * ∑{r48∈nodesOfCell48(j48)}(coord48{r48});
IniIc48: ∀j48∈cells48(), if (center48{j48}.x < option_x_interface48) {
  ρ_ic48{j48}=option_ρ_ini_zg48;
  p_ic48{j48}=option_p_ini_zg48;
} else {
  ρ_ic48{j48}=option_ρ_ini_zd48;
  p_ic48{j48}=option_p_ini_zd48;
}

ComputeCjrIc48: ∀j48∈cells48(), ∀r48∈nodesOfCell48(j48), 
	C_ic48{j48,r48} = 0.5 * perp48(coord48{►(r48)} - coord48{◄(r48)});
IniVIc48: ∀j48∈cells48(), V_ic48{j48} = 0.5 * ∑{r48∈nodesOfCell48(j48)}(dot(C_ic48{j48,r48}, coord48{r48}));
IniM48: ∀j48∈cells48(), m48{j48} = ρ_ic48{j48} * V_ic48{j48}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr48: ∀j48∈cells48(), ∀r48∈nodesOfCell48(j48), C48{j48,r48} = 0.5 * perp48(X48{►(r48)} - X48{◄(r48)});
ComputeLjr48: ∀j48∈cells48(), ∀r48∈nodesOfCell48(j48), l48{j48,r48} = norm(C48{j48,r48});
Computeδtj48: ∀j48∈cells48(), δtj48{j48} = 2.0 * V48{j48} / (c48{j48} * ∑{r48∈nodesOfCell48(j48)}(l48{j48,r48}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity48: ∀j48∈cells48(), ρ48{j48} = m48{j48} / V48{j48};
ComputeEOSp48: ∀j48∈cells48(), p48{j48} = (γ48-1.0) * ρ48{j48} * e48{j48};
ComputeInternalEngergy48: ∀j48∈cells48(), e48{j48} = E48{j48} - 0.5 * dot(uj48{j48}, uj48{j48});
ComputeEOSc48: ∀j48∈cells48(), c48{j48} = √(γ48*p48{j48}/ρ48{j48}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr48: ∀j48∈cells48(), ∀r48∈nodesOfCell48(j48), Ajr48{j48,r48} = ((ρ48{j48}*c48{j48})/l48{j48,r48}) * tensProduct48(C48{j48,r48}, C48{j48,r48});
ComputeFjr48: ∀j48∈cells48(), ∀r48∈nodesOfCell48(j48), F48{j48,r48} = p48{j48}*C48{j48,r48} + matVectProduct48(Ajr48{j48,r48}, (uj48{j48}-ur48{r48}));
ComputeAr48: ∀r48∈nodes48(), Ar48{r48} = ∑{j48∈cellsOfNode48(r48)}(Ajr48{j48,r48});
ComputeBr48: ∀r48∈nodes48(), b48{r48} = ∑{j48∈cellsOfNode48(r48)}(p48{j48}*C48{j48,r48} + matVectProduct48(Ajr48{j48,r48}, uj48{j48}));
ComputeMt48: ∀r48∈innerNodes48(), Mt48{r48} = Ar48{r48};
ComputeBt48: ∀r48∈innerNodes48(), bt48{r48} = b48{r48};

OuterFacesComputations48: ∀k48∈outerFaces48(), {
	const ℝ epsilon48 = 1.0e-10;
	ℝ²ˣ² I48 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN48 = 0.0;
	ℝ X_MAX48 = X_EDGE_ELEMS48 * LENGTH48;
	ℝ Y_MIN48 = 0.0; 
	ℝ Y_MAX48 = Y_EDGE_ELEMS48 * LENGTH48;
	ℝ² nY48 = {0.0,1.0};
	
	∀r48∈nodesOfFace48(k48), {
		// Y boundary conditions (must be done before X)
		if ((X48{r48}.y-Y_MIN48 < epsilon48) || (X48{r48}.y-Y_MAX48 < epsilon48)) {
			ℝ sign48 = 0.0;
			if (X48{r48}.y-Y_MIN48 < epsilon48) sign48 = -1.0;
			else sign48 = 1.0;
			ℝ² n48 = sign48 * nY48;
      		ℝ²ˣ² nxn48 = tensProduct48(n48,n48);
      		ℝ²ˣ² IcP48 = I48 - nxn48;
			bt1{r48} = matVectProduct48(IcP48, b48{r48});
			Mt1{r48} = IcP48 * (Ar48{r48} * IcP48) + nxn48*trace48(Ar48{r48});
		}

		// X boundary conditions
		if ((Math.fabs(X48{r48}.x-X_MIN48) < epsilon48) || ( (Math.fabs(X48{r48}.x-X_MAX48) < epsilon48) )) {
			Mt48{r48} = I48;
			bt48{r48} = {0.0, 0.0};
		}
	}
}


ComputeU48: ∀r48∈nodes48(), ur48{r48} = matVectProduct48(inverse48(Mt48{r48}), bt48{r48});
ComputeV48: ∀j48∈cells48(), V48{j48} = 0.5 * ∑{r48∈nodesOfCell48(j48)}(dot(C48{j48,r48},X48{r48}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn48: ∀n48∈ℕ, ∀r048∈nodes48(), X48{r048}^{n48=0}=coord48{r048}; , ∀r48∈nodes48(), X48{r48}^{n48+1}=X48{r48}^{n48}+δt48^{n48}*ur48{r48};
ComputeUn48: ∀n48∈ℕ, ∀j048∈cells48(), uj48{j048}^{n48=0}={0.0,0.0}; , ∀j48∈cells48(), uj48{j48}^{n48+1}=uj48{j48}^{n48}-(δt48^{n48}/m48{j48})*∑{r48∈nodesOfCell48(j48)}(F48{j48,r48});
ComputeEn48: ∀n48∈ℕ, ∀j048∈cells48(), E48{j048}^{n48=0}=p_ic48{j048}/((γ48-1.0)*ρ_ic48{j048}); , ∀j48∈cells48(), E48{j48}^{n48+1}=E48{j48}^{n48} - (δt48^{n48} / m48{j48}) * ∑{r48∈nodesOfCell48(j48)}(dot(F48{j48,r48},ur48{r48}));
ComputeDt48: ∀n48∈ℕ, δt48^{n48=0}=option_δt_ini48;, δt48^{n48+1}=option_δt_cfl48*reduceMin{j48∈cells48()}(δtj48{j48});
ComputeTn48: ∀n48∈ℕ, t48^{n48=0}=0.0; , t48^{n48+1}=t48^{n48}+δt48^{n48+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter49: ∀j49∈cells49(), center49{j49} = (1.0/4.0) * ∑{r49∈nodesOfCell49(j49)}(coord49{r49});
IniIc49: ∀j49∈cells49(), if (center49{j49}.x < option_x_interface49) {
  ρ_ic49{j49}=option_ρ_ini_zg49;
  p_ic49{j49}=option_p_ini_zg49;
} else {
  ρ_ic49{j49}=option_ρ_ini_zd49;
  p_ic49{j49}=option_p_ini_zd49;
}

ComputeCjrIc49: ∀j49∈cells49(), ∀r49∈nodesOfCell49(j49), 
	C_ic49{j49,r49} = 0.5 * perp49(coord49{►(r49)} - coord49{◄(r49)});
IniVIc49: ∀j49∈cells49(), V_ic49{j49} = 0.5 * ∑{r49∈nodesOfCell49(j49)}(dot(C_ic49{j49,r49}, coord49{r49}));
IniM49: ∀j49∈cells49(), m49{j49} = ρ_ic49{j49} * V_ic49{j49}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr49: ∀j49∈cells49(), ∀r49∈nodesOfCell49(j49), C49{j49,r49} = 0.5 * perp49(X49{►(r49)} - X49{◄(r49)});
ComputeLjr49: ∀j49∈cells49(), ∀r49∈nodesOfCell49(j49), l49{j49,r49} = norm(C49{j49,r49});
Computeδtj49: ∀j49∈cells49(), δtj49{j49} = 2.0 * V49{j49} / (c49{j49} * ∑{r49∈nodesOfCell49(j49)}(l49{j49,r49}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity49: ∀j49∈cells49(), ρ49{j49} = m49{j49} / V49{j49};
ComputeEOSp49: ∀j49∈cells49(), p49{j49} = (γ49-1.0) * ρ49{j49} * e49{j49};
ComputeInternalEngergy49: ∀j49∈cells49(), e49{j49} = E49{j49} - 0.5 * dot(uj49{j49}, uj49{j49});
ComputeEOSc49: ∀j49∈cells49(), c49{j49} = √(γ49*p49{j49}/ρ49{j49}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr49: ∀j49∈cells49(), ∀r49∈nodesOfCell49(j49), Ajr49{j49,r49} = ((ρ49{j49}*c49{j49})/l49{j49,r49}) * tensProduct49(C49{j49,r49}, C49{j49,r49});
ComputeFjr49: ∀j49∈cells49(), ∀r49∈nodesOfCell49(j49), F49{j49,r49} = p49{j49}*C49{j49,r49} + matVectProduct49(Ajr49{j49,r49}, (uj49{j49}-ur49{r49}));
ComputeAr49: ∀r49∈nodes49(), Ar49{r49} = ∑{j49∈cellsOfNode49(r49)}(Ajr49{j49,r49});
ComputeBr49: ∀r49∈nodes49(), b49{r49} = ∑{j49∈cellsOfNode49(r49)}(p49{j49}*C49{j49,r49} + matVectProduct49(Ajr49{j49,r49}, uj49{j49}));
ComputeMt49: ∀r49∈innerNodes49(), Mt49{r49} = Ar49{r49};
ComputeBt49: ∀r49∈innerNodes49(), bt49{r49} = b49{r49};

OuterFacesComputations49: ∀k49∈outerFaces49(), {
	const ℝ epsilon49 = 1.0e-10;
	ℝ²ˣ² I49 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN49 = 0.0;
	ℝ X_MAX49 = X_EDGE_ELEMS49 * LENGTH49;
	ℝ Y_MIN49 = 0.0; 
	ℝ Y_MAX49 = Y_EDGE_ELEMS49 * LENGTH49;
	ℝ² nY49 = {0.0,1.0};
	
	∀r49∈nodesOfFace49(k49), {
		// Y boundary conditions (must be done before X)
		if ((X49{r49}.y-Y_MIN49 < epsilon49) || (X49{r49}.y-Y_MAX49 < epsilon49)) {
			ℝ sign49 = 0.0;
			if (X49{r49}.y-Y_MIN49 < epsilon49) sign49 = -1.0;
			else sign49 = 1.0;
			ℝ² n49 = sign49 * nY49;
      		ℝ²ˣ² nxn49 = tensProduct49(n49,n49);
      		ℝ²ˣ² IcP49 = I49 - nxn49;
			bt1{r49} = matVectProduct49(IcP49, b49{r49});
			Mt1{r49} = IcP49 * (Ar49{r49} * IcP49) + nxn49*trace49(Ar49{r49});
		}

		// X boundary conditions
		if ((Math.fabs(X49{r49}.x-X_MIN49) < epsilon49) || ( (Math.fabs(X49{r49}.x-X_MAX49) < epsilon49) )) {
			Mt49{r49} = I49;
			bt49{r49} = {0.0, 0.0};
		}
	}
}


ComputeU49: ∀r49∈nodes49(), ur49{r49} = matVectProduct49(inverse49(Mt49{r49}), bt49{r49});
ComputeV49: ∀j49∈cells49(), V49{j49} = 0.5 * ∑{r49∈nodesOfCell49(j49)}(dot(C49{j49,r49},X49{r49}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn49: ∀n49∈ℕ, ∀r049∈nodes49(), X49{r049}^{n49=0}=coord49{r049}; , ∀r49∈nodes49(), X49{r49}^{n49+1}=X49{r49}^{n49}+δt49^{n49}*ur49{r49};
ComputeUn49: ∀n49∈ℕ, ∀j049∈cells49(), uj49{j049}^{n49=0}={0.0,0.0}; , ∀j49∈cells49(), uj49{j49}^{n49+1}=uj49{j49}^{n49}-(δt49^{n49}/m49{j49})*∑{r49∈nodesOfCell49(j49)}(F49{j49,r49});
ComputeEn49: ∀n49∈ℕ, ∀j049∈cells49(), E49{j049}^{n49=0}=p_ic49{j049}/((γ49-1.0)*ρ_ic49{j049}); , ∀j49∈cells49(), E49{j49}^{n49+1}=E49{j49}^{n49} - (δt49^{n49} / m49{j49}) * ∑{r49∈nodesOfCell49(j49)}(dot(F49{j49,r49},ur49{r49}));
ComputeDt49: ∀n49∈ℕ, δt49^{n49=0}=option_δt_ini49;, δt49^{n49+1}=option_δt_cfl49*reduceMin{j49∈cells49()}(δtj49{j49});
ComputeTn49: ∀n49∈ℕ, t49^{n49=0}=0.0; , t49^{n49+1}=t49^{n49}+δt49^{n49+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter50: ∀j50∈cells50(), center50{j50} = (1.0/4.0) * ∑{r50∈nodesOfCell50(j50)}(coord50{r50});
IniIc50: ∀j50∈cells50(), if (center50{j50}.x < option_x_interface50) {
  ρ_ic50{j50}=option_ρ_ini_zg50;
  p_ic50{j50}=option_p_ini_zg50;
} else {
  ρ_ic50{j50}=option_ρ_ini_zd50;
  p_ic50{j50}=option_p_ini_zd50;
}

ComputeCjrIc50: ∀j50∈cells50(), ∀r50∈nodesOfCell50(j50), 
	C_ic50{j50,r50} = 0.5 * perp50(coord50{►(r50)} - coord50{◄(r50)});
IniVIc50: ∀j50∈cells50(), V_ic50{j50} = 0.5 * ∑{r50∈nodesOfCell50(j50)}(dot(C_ic50{j50,r50}, coord50{r50}));
IniM50: ∀j50∈cells50(), m50{j50} = ρ_ic50{j50} * V_ic50{j50}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr50: ∀j50∈cells50(), ∀r50∈nodesOfCell50(j50), C50{j50,r50} = 0.5 * perp50(X50{►(r50)} - X50{◄(r50)});
ComputeLjr50: ∀j50∈cells50(), ∀r50∈nodesOfCell50(j50), l50{j50,r50} = norm(C50{j50,r50});
Computeδtj50: ∀j50∈cells50(), δtj50{j50} = 2.0 * V50{j50} / (c50{j50} * ∑{r50∈nodesOfCell50(j50)}(l50{j50,r50}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity50: ∀j50∈cells50(), ρ50{j50} = m50{j50} / V50{j50};
ComputeEOSp50: ∀j50∈cells50(), p50{j50} = (γ50-1.0) * ρ50{j50} * e50{j50};
ComputeInternalEngergy50: ∀j50∈cells50(), e50{j50} = E50{j50} - 0.5 * dot(uj50{j50}, uj50{j50});
ComputeEOSc50: ∀j50∈cells50(), c50{j50} = √(γ50*p50{j50}/ρ50{j50}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr50: ∀j50∈cells50(), ∀r50∈nodesOfCell50(j50), Ajr50{j50,r50} = ((ρ50{j50}*c50{j50})/l50{j50,r50}) * tensProduct50(C50{j50,r50}, C50{j50,r50});
ComputeFjr50: ∀j50∈cells50(), ∀r50∈nodesOfCell50(j50), F50{j50,r50} = p50{j50}*C50{j50,r50} + matVectProduct50(Ajr50{j50,r50}, (uj50{j50}-ur50{r50}));
ComputeAr50: ∀r50∈nodes50(), Ar50{r50} = ∑{j50∈cellsOfNode50(r50)}(Ajr50{j50,r50});
ComputeBr50: ∀r50∈nodes50(), b50{r50} = ∑{j50∈cellsOfNode50(r50)}(p50{j50}*C50{j50,r50} + matVectProduct50(Ajr50{j50,r50}, uj50{j50}));
ComputeMt50: ∀r50∈innerNodes50(), Mt50{r50} = Ar50{r50};
ComputeBt50: ∀r50∈innerNodes50(), bt50{r50} = b50{r50};

OuterFacesComputations50: ∀k50∈outerFaces50(), {
	const ℝ epsilon50 = 1.0e-10;
	ℝ²ˣ² I50 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN50 = 0.0;
	ℝ X_MAX50 = X_EDGE_ELEMS50 * LENGTH50;
	ℝ Y_MIN50 = 0.0; 
	ℝ Y_MAX50 = Y_EDGE_ELEMS50 * LENGTH50;
	ℝ² nY50 = {0.0,1.0};
	
	∀r50∈nodesOfFace50(k50), {
		// Y boundary conditions (must be done before X)
		if ((X50{r50}.y-Y_MIN50 < epsilon50) || (X50{r50}.y-Y_MAX50 < epsilon50)) {
			ℝ sign50 = 0.0;
			if (X50{r50}.y-Y_MIN50 < epsilon50) sign50 = -1.0;
			else sign50 = 1.0;
			ℝ² n50 = sign50 * nY50;
      		ℝ²ˣ² nxn50 = tensProduct50(n50,n50);
      		ℝ²ˣ² IcP50 = I50 - nxn50;
			bt1{r50} = matVectProduct50(IcP50, b50{r50});
			Mt1{r50} = IcP50 * (Ar50{r50} * IcP50) + nxn50*trace50(Ar50{r50});
		}

		// X boundary conditions
		if ((Math.fabs(X50{r50}.x-X_MIN50) < epsilon50) || ( (Math.fabs(X50{r50}.x-X_MAX50) < epsilon50) )) {
			Mt50{r50} = I50;
			bt50{r50} = {0.0, 0.0};
		}
	}
}


ComputeU50: ∀r50∈nodes50(), ur50{r50} = matVectProduct50(inverse50(Mt50{r50}), bt50{r50});
ComputeV50: ∀j50∈cells50(), V50{j50} = 0.5 * ∑{r50∈nodesOfCell50(j50)}(dot(C50{j50,r50},X50{r50}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn50: ∀n50∈ℕ, ∀r050∈nodes50(), X50{r050}^{n50=0}=coord50{r050}; , ∀r50∈nodes50(), X50{r50}^{n50+1}=X50{r50}^{n50}+δt50^{n50}*ur50{r50};
ComputeUn50: ∀n50∈ℕ, ∀j050∈cells50(), uj50{j050}^{n50=0}={0.0,0.0}; , ∀j50∈cells50(), uj50{j50}^{n50+1}=uj50{j50}^{n50}-(δt50^{n50}/m50{j50})*∑{r50∈nodesOfCell50(j50)}(F50{j50,r50});
ComputeEn50: ∀n50∈ℕ, ∀j050∈cells50(), E50{j050}^{n50=0}=p_ic50{j050}/((γ50-1.0)*ρ_ic50{j050}); , ∀j50∈cells50(), E50{j50}^{n50+1}=E50{j50}^{n50} - (δt50^{n50} / m50{j50}) * ∑{r50∈nodesOfCell50(j50)}(dot(F50{j50,r50},ur50{r50}));
ComputeDt50: ∀n50∈ℕ, δt50^{n50=0}=option_δt_ini50;, δt50^{n50+1}=option_δt_cfl50*reduceMin{j50∈cells50()}(δtj50{j50});
ComputeTn50: ∀n50∈ℕ, t50^{n50=0}=0.0; , t50^{n50+1}=t50^{n50}+δt50^{n50+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter51: ∀j51∈cells51(), center51{j51} = (1.0/4.0) * ∑{r51∈nodesOfCell51(j51)}(coord51{r51});
IniIc51: ∀j51∈cells51(), if (center51{j51}.x < option_x_interface51) {
  ρ_ic51{j51}=option_ρ_ini_zg51;
  p_ic51{j51}=option_p_ini_zg51;
} else {
  ρ_ic51{j51}=option_ρ_ini_zd51;
  p_ic51{j51}=option_p_ini_zd51;
}

ComputeCjrIc51: ∀j51∈cells51(), ∀r51∈nodesOfCell51(j51), 
	C_ic51{j51,r51} = 0.5 * perp51(coord51{►(r51)} - coord51{◄(r51)});
IniVIc51: ∀j51∈cells51(), V_ic51{j51} = 0.5 * ∑{r51∈nodesOfCell51(j51)}(dot(C_ic51{j51,r51}, coord51{r51}));
IniM51: ∀j51∈cells51(), m51{j51} = ρ_ic51{j51} * V_ic51{j51}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr51: ∀j51∈cells51(), ∀r51∈nodesOfCell51(j51), C51{j51,r51} = 0.5 * perp51(X51{►(r51)} - X51{◄(r51)});
ComputeLjr51: ∀j51∈cells51(), ∀r51∈nodesOfCell51(j51), l51{j51,r51} = norm(C51{j51,r51});
Computeδtj51: ∀j51∈cells51(), δtj51{j51} = 2.0 * V51{j51} / (c51{j51} * ∑{r51∈nodesOfCell51(j51)}(l51{j51,r51}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity51: ∀j51∈cells51(), ρ51{j51} = m51{j51} / V51{j51};
ComputeEOSp51: ∀j51∈cells51(), p51{j51} = (γ51-1.0) * ρ51{j51} * e51{j51};
ComputeInternalEngergy51: ∀j51∈cells51(), e51{j51} = E51{j51} - 0.5 * dot(uj51{j51}, uj51{j51});
ComputeEOSc51: ∀j51∈cells51(), c51{j51} = √(γ51*p51{j51}/ρ51{j51}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr51: ∀j51∈cells51(), ∀r51∈nodesOfCell51(j51), Ajr51{j51,r51} = ((ρ51{j51}*c51{j51})/l51{j51,r51}) * tensProduct51(C51{j51,r51}, C51{j51,r51});
ComputeFjr51: ∀j51∈cells51(), ∀r51∈nodesOfCell51(j51), F51{j51,r51} = p51{j51}*C51{j51,r51} + matVectProduct51(Ajr51{j51,r51}, (uj51{j51}-ur51{r51}));
ComputeAr51: ∀r51∈nodes51(), Ar51{r51} = ∑{j51∈cellsOfNode51(r51)}(Ajr51{j51,r51});
ComputeBr51: ∀r51∈nodes51(), b51{r51} = ∑{j51∈cellsOfNode51(r51)}(p51{j51}*C51{j51,r51} + matVectProduct51(Ajr51{j51,r51}, uj51{j51}));
ComputeMt51: ∀r51∈innerNodes51(), Mt51{r51} = Ar51{r51};
ComputeBt51: ∀r51∈innerNodes51(), bt51{r51} = b51{r51};

OuterFacesComputations51: ∀k51∈outerFaces51(), {
	const ℝ epsilon51 = 1.0e-10;
	ℝ²ˣ² I51 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN51 = 0.0;
	ℝ X_MAX51 = X_EDGE_ELEMS51 * LENGTH51;
	ℝ Y_MIN51 = 0.0; 
	ℝ Y_MAX51 = Y_EDGE_ELEMS51 * LENGTH51;
	ℝ² nY51 = {0.0,1.0};
	
	∀r51∈nodesOfFace51(k51), {
		// Y boundary conditions (must be done before X)
		if ((X51{r51}.y-Y_MIN51 < epsilon51) || (X51{r51}.y-Y_MAX51 < epsilon51)) {
			ℝ sign51 = 0.0;
			if (X51{r51}.y-Y_MIN51 < epsilon51) sign51 = -1.0;
			else sign51 = 1.0;
			ℝ² n51 = sign51 * nY51;
      		ℝ²ˣ² nxn51 = tensProduct51(n51,n51);
      		ℝ²ˣ² IcP51 = I51 - nxn51;
			bt1{r51} = matVectProduct51(IcP51, b51{r51});
			Mt1{r51} = IcP51 * (Ar51{r51} * IcP51) + nxn51*trace51(Ar51{r51});
		}

		// X boundary conditions
		if ((Math.fabs(X51{r51}.x-X_MIN51) < epsilon51) || ( (Math.fabs(X51{r51}.x-X_MAX51) < epsilon51) )) {
			Mt51{r51} = I51;
			bt51{r51} = {0.0, 0.0};
		}
	}
}


ComputeU51: ∀r51∈nodes51(), ur51{r51} = matVectProduct51(inverse51(Mt51{r51}), bt51{r51});
ComputeV51: ∀j51∈cells51(), V51{j51} = 0.5 * ∑{r51∈nodesOfCell51(j51)}(dot(C51{j51,r51},X51{r51}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn51: ∀n51∈ℕ, ∀r051∈nodes51(), X51{r051}^{n51=0}=coord51{r051}; , ∀r51∈nodes51(), X51{r51}^{n51+1}=X51{r51}^{n51}+δt51^{n51}*ur51{r51};
ComputeUn51: ∀n51∈ℕ, ∀j051∈cells51(), uj51{j051}^{n51=0}={0.0,0.0}; , ∀j51∈cells51(), uj51{j51}^{n51+1}=uj51{j51}^{n51}-(δt51^{n51}/m51{j51})*∑{r51∈nodesOfCell51(j51)}(F51{j51,r51});
ComputeEn51: ∀n51∈ℕ, ∀j051∈cells51(), E51{j051}^{n51=0}=p_ic51{j051}/((γ51-1.0)*ρ_ic51{j051}); , ∀j51∈cells51(), E51{j51}^{n51+1}=E51{j51}^{n51} - (δt51^{n51} / m51{j51}) * ∑{r51∈nodesOfCell51(j51)}(dot(F51{j51,r51},ur51{r51}));
ComputeDt51: ∀n51∈ℕ, δt51^{n51=0}=option_δt_ini51;, δt51^{n51+1}=option_δt_cfl51*reduceMin{j51∈cells51()}(δtj51{j51});
ComputeTn51: ∀n51∈ℕ, t51^{n51=0}=0.0; , t51^{n51+1}=t51^{n51}+δt51^{n51+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter52: ∀j52∈cells52(), center52{j52} = (1.0/4.0) * ∑{r52∈nodesOfCell52(j52)}(coord52{r52});
IniIc52: ∀j52∈cells52(), if (center52{j52}.x < option_x_interface52) {
  ρ_ic52{j52}=option_ρ_ini_zg52;
  p_ic52{j52}=option_p_ini_zg52;
} else {
  ρ_ic52{j52}=option_ρ_ini_zd52;
  p_ic52{j52}=option_p_ini_zd52;
}

ComputeCjrIc52: ∀j52∈cells52(), ∀r52∈nodesOfCell52(j52), 
	C_ic52{j52,r52} = 0.5 * perp52(coord52{►(r52)} - coord52{◄(r52)});
IniVIc52: ∀j52∈cells52(), V_ic52{j52} = 0.5 * ∑{r52∈nodesOfCell52(j52)}(dot(C_ic52{j52,r52}, coord52{r52}));
IniM52: ∀j52∈cells52(), m52{j52} = ρ_ic52{j52} * V_ic52{j52}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr52: ∀j52∈cells52(), ∀r52∈nodesOfCell52(j52), C52{j52,r52} = 0.5 * perp52(X52{►(r52)} - X52{◄(r52)});
ComputeLjr52: ∀j52∈cells52(), ∀r52∈nodesOfCell52(j52), l52{j52,r52} = norm(C52{j52,r52});
Computeδtj52: ∀j52∈cells52(), δtj52{j52} = 2.0 * V52{j52} / (c52{j52} * ∑{r52∈nodesOfCell52(j52)}(l52{j52,r52}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity52: ∀j52∈cells52(), ρ52{j52} = m52{j52} / V52{j52};
ComputeEOSp52: ∀j52∈cells52(), p52{j52} = (γ52-1.0) * ρ52{j52} * e52{j52};
ComputeInternalEngergy52: ∀j52∈cells52(), e52{j52} = E52{j52} - 0.5 * dot(uj52{j52}, uj52{j52});
ComputeEOSc52: ∀j52∈cells52(), c52{j52} = √(γ52*p52{j52}/ρ52{j52}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr52: ∀j52∈cells52(), ∀r52∈nodesOfCell52(j52), Ajr52{j52,r52} = ((ρ52{j52}*c52{j52})/l52{j52,r52}) * tensProduct52(C52{j52,r52}, C52{j52,r52});
ComputeFjr52: ∀j52∈cells52(), ∀r52∈nodesOfCell52(j52), F52{j52,r52} = p52{j52}*C52{j52,r52} + matVectProduct52(Ajr52{j52,r52}, (uj52{j52}-ur52{r52}));
ComputeAr52: ∀r52∈nodes52(), Ar52{r52} = ∑{j52∈cellsOfNode52(r52)}(Ajr52{j52,r52});
ComputeBr52: ∀r52∈nodes52(), b52{r52} = ∑{j52∈cellsOfNode52(r52)}(p52{j52}*C52{j52,r52} + matVectProduct52(Ajr52{j52,r52}, uj52{j52}));
ComputeMt52: ∀r52∈innerNodes52(), Mt52{r52} = Ar52{r52};
ComputeBt52: ∀r52∈innerNodes52(), bt52{r52} = b52{r52};

OuterFacesComputations52: ∀k52∈outerFaces52(), {
	const ℝ epsilon52 = 1.0e-10;
	ℝ²ˣ² I52 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN52 = 0.0;
	ℝ X_MAX52 = X_EDGE_ELEMS52 * LENGTH52;
	ℝ Y_MIN52 = 0.0; 
	ℝ Y_MAX52 = Y_EDGE_ELEMS52 * LENGTH52;
	ℝ² nY52 = {0.0,1.0};
	
	∀r52∈nodesOfFace52(k52), {
		// Y boundary conditions (must be done before X)
		if ((X52{r52}.y-Y_MIN52 < epsilon52) || (X52{r52}.y-Y_MAX52 < epsilon52)) {
			ℝ sign52 = 0.0;
			if (X52{r52}.y-Y_MIN52 < epsilon52) sign52 = -1.0;
			else sign52 = 1.0;
			ℝ² n52 = sign52 * nY52;
      		ℝ²ˣ² nxn52 = tensProduct52(n52,n52);
      		ℝ²ˣ² IcP52 = I52 - nxn52;
			bt1{r52} = matVectProduct52(IcP52, b52{r52});
			Mt1{r52} = IcP52 * (Ar52{r52} * IcP52) + nxn52*trace52(Ar52{r52});
		}

		// X boundary conditions
		if ((Math.fabs(X52{r52}.x-X_MIN52) < epsilon52) || ( (Math.fabs(X52{r52}.x-X_MAX52) < epsilon52) )) {
			Mt52{r52} = I52;
			bt52{r52} = {0.0, 0.0};
		}
	}
}


ComputeU52: ∀r52∈nodes52(), ur52{r52} = matVectProduct52(inverse52(Mt52{r52}), bt52{r52});
ComputeV52: ∀j52∈cells52(), V52{j52} = 0.5 * ∑{r52∈nodesOfCell52(j52)}(dot(C52{j52,r52},X52{r52}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn52: ∀n52∈ℕ, ∀r052∈nodes52(), X52{r052}^{n52=0}=coord52{r052}; , ∀r52∈nodes52(), X52{r52}^{n52+1}=X52{r52}^{n52}+δt52^{n52}*ur52{r52};
ComputeUn52: ∀n52∈ℕ, ∀j052∈cells52(), uj52{j052}^{n52=0}={0.0,0.0}; , ∀j52∈cells52(), uj52{j52}^{n52+1}=uj52{j52}^{n52}-(δt52^{n52}/m52{j52})*∑{r52∈nodesOfCell52(j52)}(F52{j52,r52});
ComputeEn52: ∀n52∈ℕ, ∀j052∈cells52(), E52{j052}^{n52=0}=p_ic52{j052}/((γ52-1.0)*ρ_ic52{j052}); , ∀j52∈cells52(), E52{j52}^{n52+1}=E52{j52}^{n52} - (δt52^{n52} / m52{j52}) * ∑{r52∈nodesOfCell52(j52)}(dot(F52{j52,r52},ur52{r52}));
ComputeDt52: ∀n52∈ℕ, δt52^{n52=0}=option_δt_ini52;, δt52^{n52+1}=option_δt_cfl52*reduceMin{j52∈cells52()}(δtj52{j52});
ComputeTn52: ∀n52∈ℕ, t52^{n52=0}=0.0; , t52^{n52+1}=t52^{n52}+δt52^{n52+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter53: ∀j53∈cells53(), center53{j53} = (1.0/4.0) * ∑{r53∈nodesOfCell53(j53)}(coord53{r53});
IniIc53: ∀j53∈cells53(), if (center53{j53}.x < option_x_interface53) {
  ρ_ic53{j53}=option_ρ_ini_zg53;
  p_ic53{j53}=option_p_ini_zg53;
} else {
  ρ_ic53{j53}=option_ρ_ini_zd53;
  p_ic53{j53}=option_p_ini_zd53;
}

ComputeCjrIc53: ∀j53∈cells53(), ∀r53∈nodesOfCell53(j53), 
	C_ic53{j53,r53} = 0.5 * perp53(coord53{►(r53)} - coord53{◄(r53)});
IniVIc53: ∀j53∈cells53(), V_ic53{j53} = 0.5 * ∑{r53∈nodesOfCell53(j53)}(dot(C_ic53{j53,r53}, coord53{r53}));
IniM53: ∀j53∈cells53(), m53{j53} = ρ_ic53{j53} * V_ic53{j53}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr53: ∀j53∈cells53(), ∀r53∈nodesOfCell53(j53), C53{j53,r53} = 0.5 * perp53(X53{►(r53)} - X53{◄(r53)});
ComputeLjr53: ∀j53∈cells53(), ∀r53∈nodesOfCell53(j53), l53{j53,r53} = norm(C53{j53,r53});
Computeδtj53: ∀j53∈cells53(), δtj53{j53} = 2.0 * V53{j53} / (c53{j53} * ∑{r53∈nodesOfCell53(j53)}(l53{j53,r53}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity53: ∀j53∈cells53(), ρ53{j53} = m53{j53} / V53{j53};
ComputeEOSp53: ∀j53∈cells53(), p53{j53} = (γ53-1.0) * ρ53{j53} * e53{j53};
ComputeInternalEngergy53: ∀j53∈cells53(), e53{j53} = E53{j53} - 0.5 * dot(uj53{j53}, uj53{j53});
ComputeEOSc53: ∀j53∈cells53(), c53{j53} = √(γ53*p53{j53}/ρ53{j53}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr53: ∀j53∈cells53(), ∀r53∈nodesOfCell53(j53), Ajr53{j53,r53} = ((ρ53{j53}*c53{j53})/l53{j53,r53}) * tensProduct53(C53{j53,r53}, C53{j53,r53});
ComputeFjr53: ∀j53∈cells53(), ∀r53∈nodesOfCell53(j53), F53{j53,r53} = p53{j53}*C53{j53,r53} + matVectProduct53(Ajr53{j53,r53}, (uj53{j53}-ur53{r53}));
ComputeAr53: ∀r53∈nodes53(), Ar53{r53} = ∑{j53∈cellsOfNode53(r53)}(Ajr53{j53,r53});
ComputeBr53: ∀r53∈nodes53(), b53{r53} = ∑{j53∈cellsOfNode53(r53)}(p53{j53}*C53{j53,r53} + matVectProduct53(Ajr53{j53,r53}, uj53{j53}));
ComputeMt53: ∀r53∈innerNodes53(), Mt53{r53} = Ar53{r53};
ComputeBt53: ∀r53∈innerNodes53(), bt53{r53} = b53{r53};

OuterFacesComputations53: ∀k53∈outerFaces53(), {
	const ℝ epsilon53 = 1.0e-10;
	ℝ²ˣ² I53 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN53 = 0.0;
	ℝ X_MAX53 = X_EDGE_ELEMS53 * LENGTH53;
	ℝ Y_MIN53 = 0.0; 
	ℝ Y_MAX53 = Y_EDGE_ELEMS53 * LENGTH53;
	ℝ² nY53 = {0.0,1.0};
	
	∀r53∈nodesOfFace53(k53), {
		// Y boundary conditions (must be done before X)
		if ((X53{r53}.y-Y_MIN53 < epsilon53) || (X53{r53}.y-Y_MAX53 < epsilon53)) {
			ℝ sign53 = 0.0;
			if (X53{r53}.y-Y_MIN53 < epsilon53) sign53 = -1.0;
			else sign53 = 1.0;
			ℝ² n53 = sign53 * nY53;
      		ℝ²ˣ² nxn53 = tensProduct53(n53,n53);
      		ℝ²ˣ² IcP53 = I53 - nxn53;
			bt1{r53} = matVectProduct53(IcP53, b53{r53});
			Mt1{r53} = IcP53 * (Ar53{r53} * IcP53) + nxn53*trace53(Ar53{r53});
		}

		// X boundary conditions
		if ((Math.fabs(X53{r53}.x-X_MIN53) < epsilon53) || ( (Math.fabs(X53{r53}.x-X_MAX53) < epsilon53) )) {
			Mt53{r53} = I53;
			bt53{r53} = {0.0, 0.0};
		}
	}
}


ComputeU53: ∀r53∈nodes53(), ur53{r53} = matVectProduct53(inverse53(Mt53{r53}), bt53{r53});
ComputeV53: ∀j53∈cells53(), V53{j53} = 0.5 * ∑{r53∈nodesOfCell53(j53)}(dot(C53{j53,r53},X53{r53}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn53: ∀n53∈ℕ, ∀r053∈nodes53(), X53{r053}^{n53=0}=coord53{r053}; , ∀r53∈nodes53(), X53{r53}^{n53+1}=X53{r53}^{n53}+δt53^{n53}*ur53{r53};
ComputeUn53: ∀n53∈ℕ, ∀j053∈cells53(), uj53{j053}^{n53=0}={0.0,0.0}; , ∀j53∈cells53(), uj53{j53}^{n53+1}=uj53{j53}^{n53}-(δt53^{n53}/m53{j53})*∑{r53∈nodesOfCell53(j53)}(F53{j53,r53});
ComputeEn53: ∀n53∈ℕ, ∀j053∈cells53(), E53{j053}^{n53=0}=p_ic53{j053}/((γ53-1.0)*ρ_ic53{j053}); , ∀j53∈cells53(), E53{j53}^{n53+1}=E53{j53}^{n53} - (δt53^{n53} / m53{j53}) * ∑{r53∈nodesOfCell53(j53)}(dot(F53{j53,r53},ur53{r53}));
ComputeDt53: ∀n53∈ℕ, δt53^{n53=0}=option_δt_ini53;, δt53^{n53+1}=option_δt_cfl53*reduceMin{j53∈cells53()}(δtj53{j53});
ComputeTn53: ∀n53∈ℕ, t53^{n53=0}=0.0; , t53^{n53+1}=t53^{n53}+δt53^{n53+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter54: ∀j54∈cells54(), center54{j54} = (1.0/4.0) * ∑{r54∈nodesOfCell54(j54)}(coord54{r54});
IniIc54: ∀j54∈cells54(), if (center54{j54}.x < option_x_interface54) {
  ρ_ic54{j54}=option_ρ_ini_zg54;
  p_ic54{j54}=option_p_ini_zg54;
} else {
  ρ_ic54{j54}=option_ρ_ini_zd54;
  p_ic54{j54}=option_p_ini_zd54;
}

ComputeCjrIc54: ∀j54∈cells54(), ∀r54∈nodesOfCell54(j54), 
	C_ic54{j54,r54} = 0.5 * perp54(coord54{►(r54)} - coord54{◄(r54)});
IniVIc54: ∀j54∈cells54(), V_ic54{j54} = 0.5 * ∑{r54∈nodesOfCell54(j54)}(dot(C_ic54{j54,r54}, coord54{r54}));
IniM54: ∀j54∈cells54(), m54{j54} = ρ_ic54{j54} * V_ic54{j54}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr54: ∀j54∈cells54(), ∀r54∈nodesOfCell54(j54), C54{j54,r54} = 0.5 * perp54(X54{►(r54)} - X54{◄(r54)});
ComputeLjr54: ∀j54∈cells54(), ∀r54∈nodesOfCell54(j54), l54{j54,r54} = norm(C54{j54,r54});
Computeδtj54: ∀j54∈cells54(), δtj54{j54} = 2.0 * V54{j54} / (c54{j54} * ∑{r54∈nodesOfCell54(j54)}(l54{j54,r54}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity54: ∀j54∈cells54(), ρ54{j54} = m54{j54} / V54{j54};
ComputeEOSp54: ∀j54∈cells54(), p54{j54} = (γ54-1.0) * ρ54{j54} * e54{j54};
ComputeInternalEngergy54: ∀j54∈cells54(), e54{j54} = E54{j54} - 0.5 * dot(uj54{j54}, uj54{j54});
ComputeEOSc54: ∀j54∈cells54(), c54{j54} = √(γ54*p54{j54}/ρ54{j54}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr54: ∀j54∈cells54(), ∀r54∈nodesOfCell54(j54), Ajr54{j54,r54} = ((ρ54{j54}*c54{j54})/l54{j54,r54}) * tensProduct54(C54{j54,r54}, C54{j54,r54});
ComputeFjr54: ∀j54∈cells54(), ∀r54∈nodesOfCell54(j54), F54{j54,r54} = p54{j54}*C54{j54,r54} + matVectProduct54(Ajr54{j54,r54}, (uj54{j54}-ur54{r54}));
ComputeAr54: ∀r54∈nodes54(), Ar54{r54} = ∑{j54∈cellsOfNode54(r54)}(Ajr54{j54,r54});
ComputeBr54: ∀r54∈nodes54(), b54{r54} = ∑{j54∈cellsOfNode54(r54)}(p54{j54}*C54{j54,r54} + matVectProduct54(Ajr54{j54,r54}, uj54{j54}));
ComputeMt54: ∀r54∈innerNodes54(), Mt54{r54} = Ar54{r54};
ComputeBt54: ∀r54∈innerNodes54(), bt54{r54} = b54{r54};

OuterFacesComputations54: ∀k54∈outerFaces54(), {
	const ℝ epsilon54 = 1.0e-10;
	ℝ²ˣ² I54 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN54 = 0.0;
	ℝ X_MAX54 = X_EDGE_ELEMS54 * LENGTH54;
	ℝ Y_MIN54 = 0.0; 
	ℝ Y_MAX54 = Y_EDGE_ELEMS54 * LENGTH54;
	ℝ² nY54 = {0.0,1.0};
	
	∀r54∈nodesOfFace54(k54), {
		// Y boundary conditions (must be done before X)
		if ((X54{r54}.y-Y_MIN54 < epsilon54) || (X54{r54}.y-Y_MAX54 < epsilon54)) {
			ℝ sign54 = 0.0;
			if (X54{r54}.y-Y_MIN54 < epsilon54) sign54 = -1.0;
			else sign54 = 1.0;
			ℝ² n54 = sign54 * nY54;
      		ℝ²ˣ² nxn54 = tensProduct54(n54,n54);
      		ℝ²ˣ² IcP54 = I54 - nxn54;
			bt1{r54} = matVectProduct54(IcP54, b54{r54});
			Mt1{r54} = IcP54 * (Ar54{r54} * IcP54) + nxn54*trace54(Ar54{r54});
		}

		// X boundary conditions
		if ((Math.fabs(X54{r54}.x-X_MIN54) < epsilon54) || ( (Math.fabs(X54{r54}.x-X_MAX54) < epsilon54) )) {
			Mt54{r54} = I54;
			bt54{r54} = {0.0, 0.0};
		}
	}
}


ComputeU54: ∀r54∈nodes54(), ur54{r54} = matVectProduct54(inverse54(Mt54{r54}), bt54{r54});
ComputeV54: ∀j54∈cells54(), V54{j54} = 0.5 * ∑{r54∈nodesOfCell54(j54)}(dot(C54{j54,r54},X54{r54}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn54: ∀n54∈ℕ, ∀r054∈nodes54(), X54{r054}^{n54=0}=coord54{r054}; , ∀r54∈nodes54(), X54{r54}^{n54+1}=X54{r54}^{n54}+δt54^{n54}*ur54{r54};
ComputeUn54: ∀n54∈ℕ, ∀j054∈cells54(), uj54{j054}^{n54=0}={0.0,0.0}; , ∀j54∈cells54(), uj54{j54}^{n54+1}=uj54{j54}^{n54}-(δt54^{n54}/m54{j54})*∑{r54∈nodesOfCell54(j54)}(F54{j54,r54});
ComputeEn54: ∀n54∈ℕ, ∀j054∈cells54(), E54{j054}^{n54=0}=p_ic54{j054}/((γ54-1.0)*ρ_ic54{j054}); , ∀j54∈cells54(), E54{j54}^{n54+1}=E54{j54}^{n54} - (δt54^{n54} / m54{j54}) * ∑{r54∈nodesOfCell54(j54)}(dot(F54{j54,r54},ur54{r54}));
ComputeDt54: ∀n54∈ℕ, δt54^{n54=0}=option_δt_ini54;, δt54^{n54+1}=option_δt_cfl54*reduceMin{j54∈cells54()}(δtj54{j54});
ComputeTn54: ∀n54∈ℕ, t54^{n54=0}=0.0; , t54^{n54+1}=t54^{n54}+δt54^{n54+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter55: ∀j55∈cells55(), center55{j55} = (1.0/4.0) * ∑{r55∈nodesOfCell55(j55)}(coord55{r55});
IniIc55: ∀j55∈cells55(), if (center55{j55}.x < option_x_interface55) {
  ρ_ic55{j55}=option_ρ_ini_zg55;
  p_ic55{j55}=option_p_ini_zg55;
} else {
  ρ_ic55{j55}=option_ρ_ini_zd55;
  p_ic55{j55}=option_p_ini_zd55;
}

ComputeCjrIc55: ∀j55∈cells55(), ∀r55∈nodesOfCell55(j55), 
	C_ic55{j55,r55} = 0.5 * perp55(coord55{►(r55)} - coord55{◄(r55)});
IniVIc55: ∀j55∈cells55(), V_ic55{j55} = 0.5 * ∑{r55∈nodesOfCell55(j55)}(dot(C_ic55{j55,r55}, coord55{r55}));
IniM55: ∀j55∈cells55(), m55{j55} = ρ_ic55{j55} * V_ic55{j55}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr55: ∀j55∈cells55(), ∀r55∈nodesOfCell55(j55), C55{j55,r55} = 0.5 * perp55(X55{►(r55)} - X55{◄(r55)});
ComputeLjr55: ∀j55∈cells55(), ∀r55∈nodesOfCell55(j55), l55{j55,r55} = norm(C55{j55,r55});
Computeδtj55: ∀j55∈cells55(), δtj55{j55} = 2.0 * V55{j55} / (c55{j55} * ∑{r55∈nodesOfCell55(j55)}(l55{j55,r55}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity55: ∀j55∈cells55(), ρ55{j55} = m55{j55} / V55{j55};
ComputeEOSp55: ∀j55∈cells55(), p55{j55} = (γ55-1.0) * ρ55{j55} * e55{j55};
ComputeInternalEngergy55: ∀j55∈cells55(), e55{j55} = E55{j55} - 0.5 * dot(uj55{j55}, uj55{j55});
ComputeEOSc55: ∀j55∈cells55(), c55{j55} = √(γ55*p55{j55}/ρ55{j55}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr55: ∀j55∈cells55(), ∀r55∈nodesOfCell55(j55), Ajr55{j55,r55} = ((ρ55{j55}*c55{j55})/l55{j55,r55}) * tensProduct55(C55{j55,r55}, C55{j55,r55});
ComputeFjr55: ∀j55∈cells55(), ∀r55∈nodesOfCell55(j55), F55{j55,r55} = p55{j55}*C55{j55,r55} + matVectProduct55(Ajr55{j55,r55}, (uj55{j55}-ur55{r55}));
ComputeAr55: ∀r55∈nodes55(), Ar55{r55} = ∑{j55∈cellsOfNode55(r55)}(Ajr55{j55,r55});
ComputeBr55: ∀r55∈nodes55(), b55{r55} = ∑{j55∈cellsOfNode55(r55)}(p55{j55}*C55{j55,r55} + matVectProduct55(Ajr55{j55,r55}, uj55{j55}));
ComputeMt55: ∀r55∈innerNodes55(), Mt55{r55} = Ar55{r55};
ComputeBt55: ∀r55∈innerNodes55(), bt55{r55} = b55{r55};

OuterFacesComputations55: ∀k55∈outerFaces55(), {
	const ℝ epsilon55 = 1.0e-10;
	ℝ²ˣ² I55 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN55 = 0.0;
	ℝ X_MAX55 = X_EDGE_ELEMS55 * LENGTH55;
	ℝ Y_MIN55 = 0.0; 
	ℝ Y_MAX55 = Y_EDGE_ELEMS55 * LENGTH55;
	ℝ² nY55 = {0.0,1.0};
	
	∀r55∈nodesOfFace55(k55), {
		// Y boundary conditions (must be done before X)
		if ((X55{r55}.y-Y_MIN55 < epsilon55) || (X55{r55}.y-Y_MAX55 < epsilon55)) {
			ℝ sign55 = 0.0;
			if (X55{r55}.y-Y_MIN55 < epsilon55) sign55 = -1.0;
			else sign55 = 1.0;
			ℝ² n55 = sign55 * nY55;
      		ℝ²ˣ² nxn55 = tensProduct55(n55,n55);
      		ℝ²ˣ² IcP55 = I55 - nxn55;
			bt1{r55} = matVectProduct55(IcP55, b55{r55});
			Mt1{r55} = IcP55 * (Ar55{r55} * IcP55) + nxn55*trace55(Ar55{r55});
		}

		// X boundary conditions
		if ((Math.fabs(X55{r55}.x-X_MIN55) < epsilon55) || ( (Math.fabs(X55{r55}.x-X_MAX55) < epsilon55) )) {
			Mt55{r55} = I55;
			bt55{r55} = {0.0, 0.0};
		}
	}
}


ComputeU55: ∀r55∈nodes55(), ur55{r55} = matVectProduct55(inverse55(Mt55{r55}), bt55{r55});
ComputeV55: ∀j55∈cells55(), V55{j55} = 0.5 * ∑{r55∈nodesOfCell55(j55)}(dot(C55{j55,r55},X55{r55}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn55: ∀n55∈ℕ, ∀r055∈nodes55(), X55{r055}^{n55=0}=coord55{r055}; , ∀r55∈nodes55(), X55{r55}^{n55+1}=X55{r55}^{n55}+δt55^{n55}*ur55{r55};
ComputeUn55: ∀n55∈ℕ, ∀j055∈cells55(), uj55{j055}^{n55=0}={0.0,0.0}; , ∀j55∈cells55(), uj55{j55}^{n55+1}=uj55{j55}^{n55}-(δt55^{n55}/m55{j55})*∑{r55∈nodesOfCell55(j55)}(F55{j55,r55});
ComputeEn55: ∀n55∈ℕ, ∀j055∈cells55(), E55{j055}^{n55=0}=p_ic55{j055}/((γ55-1.0)*ρ_ic55{j055}); , ∀j55∈cells55(), E55{j55}^{n55+1}=E55{j55}^{n55} - (δt55^{n55} / m55{j55}) * ∑{r55∈nodesOfCell55(j55)}(dot(F55{j55,r55},ur55{r55}));
ComputeDt55: ∀n55∈ℕ, δt55^{n55=0}=option_δt_ini55;, δt55^{n55+1}=option_δt_cfl55*reduceMin{j55∈cells55()}(δtj55{j55});
ComputeTn55: ∀n55∈ℕ, t55^{n55=0}=0.0; , t55^{n55+1}=t55^{n55}+δt55^{n55+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter56: ∀j56∈cells56(), center56{j56} = (1.0/4.0) * ∑{r56∈nodesOfCell56(j56)}(coord56{r56});
IniIc56: ∀j56∈cells56(), if (center56{j56}.x < option_x_interface56) {
  ρ_ic56{j56}=option_ρ_ini_zg56;
  p_ic56{j56}=option_p_ini_zg56;
} else {
  ρ_ic56{j56}=option_ρ_ini_zd56;
  p_ic56{j56}=option_p_ini_zd56;
}

ComputeCjrIc56: ∀j56∈cells56(), ∀r56∈nodesOfCell56(j56), 
	C_ic56{j56,r56} = 0.5 * perp56(coord56{►(r56)} - coord56{◄(r56)});
IniVIc56: ∀j56∈cells56(), V_ic56{j56} = 0.5 * ∑{r56∈nodesOfCell56(j56)}(dot(C_ic56{j56,r56}, coord56{r56}));
IniM56: ∀j56∈cells56(), m56{j56} = ρ_ic56{j56} * V_ic56{j56}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr56: ∀j56∈cells56(), ∀r56∈nodesOfCell56(j56), C56{j56,r56} = 0.5 * perp56(X56{►(r56)} - X56{◄(r56)});
ComputeLjr56: ∀j56∈cells56(), ∀r56∈nodesOfCell56(j56), l56{j56,r56} = norm(C56{j56,r56});
Computeδtj56: ∀j56∈cells56(), δtj56{j56} = 2.0 * V56{j56} / (c56{j56} * ∑{r56∈nodesOfCell56(j56)}(l56{j56,r56}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity56: ∀j56∈cells56(), ρ56{j56} = m56{j56} / V56{j56};
ComputeEOSp56: ∀j56∈cells56(), p56{j56} = (γ56-1.0) * ρ56{j56} * e56{j56};
ComputeInternalEngergy56: ∀j56∈cells56(), e56{j56} = E56{j56} - 0.5 * dot(uj56{j56}, uj56{j56});
ComputeEOSc56: ∀j56∈cells56(), c56{j56} = √(γ56*p56{j56}/ρ56{j56}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr56: ∀j56∈cells56(), ∀r56∈nodesOfCell56(j56), Ajr56{j56,r56} = ((ρ56{j56}*c56{j56})/l56{j56,r56}) * tensProduct56(C56{j56,r56}, C56{j56,r56});
ComputeFjr56: ∀j56∈cells56(), ∀r56∈nodesOfCell56(j56), F56{j56,r56} = p56{j56}*C56{j56,r56} + matVectProduct56(Ajr56{j56,r56}, (uj56{j56}-ur56{r56}));
ComputeAr56: ∀r56∈nodes56(), Ar56{r56} = ∑{j56∈cellsOfNode56(r56)}(Ajr56{j56,r56});
ComputeBr56: ∀r56∈nodes56(), b56{r56} = ∑{j56∈cellsOfNode56(r56)}(p56{j56}*C56{j56,r56} + matVectProduct56(Ajr56{j56,r56}, uj56{j56}));
ComputeMt56: ∀r56∈innerNodes56(), Mt56{r56} = Ar56{r56};
ComputeBt56: ∀r56∈innerNodes56(), bt56{r56} = b56{r56};

OuterFacesComputations56: ∀k56∈outerFaces56(), {
	const ℝ epsilon56 = 1.0e-10;
	ℝ²ˣ² I56 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN56 = 0.0;
	ℝ X_MAX56 = X_EDGE_ELEMS56 * LENGTH56;
	ℝ Y_MIN56 = 0.0; 
	ℝ Y_MAX56 = Y_EDGE_ELEMS56 * LENGTH56;
	ℝ² nY56 = {0.0,1.0};
	
	∀r56∈nodesOfFace56(k56), {
		// Y boundary conditions (must be done before X)
		if ((X56{r56}.y-Y_MIN56 < epsilon56) || (X56{r56}.y-Y_MAX56 < epsilon56)) {
			ℝ sign56 = 0.0;
			if (X56{r56}.y-Y_MIN56 < epsilon56) sign56 = -1.0;
			else sign56 = 1.0;
			ℝ² n56 = sign56 * nY56;
      		ℝ²ˣ² nxn56 = tensProduct56(n56,n56);
      		ℝ²ˣ² IcP56 = I56 - nxn56;
			bt1{r56} = matVectProduct56(IcP56, b56{r56});
			Mt1{r56} = IcP56 * (Ar56{r56} * IcP56) + nxn56*trace56(Ar56{r56});
		}

		// X boundary conditions
		if ((Math.fabs(X56{r56}.x-X_MIN56) < epsilon56) || ( (Math.fabs(X56{r56}.x-X_MAX56) < epsilon56) )) {
			Mt56{r56} = I56;
			bt56{r56} = {0.0, 0.0};
		}
	}
}


ComputeU56: ∀r56∈nodes56(), ur56{r56} = matVectProduct56(inverse56(Mt56{r56}), bt56{r56});
ComputeV56: ∀j56∈cells56(), V56{j56} = 0.5 * ∑{r56∈nodesOfCell56(j56)}(dot(C56{j56,r56},X56{r56}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn56: ∀n56∈ℕ, ∀r056∈nodes56(), X56{r056}^{n56=0}=coord56{r056}; , ∀r56∈nodes56(), X56{r56}^{n56+1}=X56{r56}^{n56}+δt56^{n56}*ur56{r56};
ComputeUn56: ∀n56∈ℕ, ∀j056∈cells56(), uj56{j056}^{n56=0}={0.0,0.0}; , ∀j56∈cells56(), uj56{j56}^{n56+1}=uj56{j56}^{n56}-(δt56^{n56}/m56{j56})*∑{r56∈nodesOfCell56(j56)}(F56{j56,r56});
ComputeEn56: ∀n56∈ℕ, ∀j056∈cells56(), E56{j056}^{n56=0}=p_ic56{j056}/((γ56-1.0)*ρ_ic56{j056}); , ∀j56∈cells56(), E56{j56}^{n56+1}=E56{j56}^{n56} - (δt56^{n56} / m56{j56}) * ∑{r56∈nodesOfCell56(j56)}(dot(F56{j56,r56},ur56{r56}));
ComputeDt56: ∀n56∈ℕ, δt56^{n56=0}=option_δt_ini56;, δt56^{n56+1}=option_δt_cfl56*reduceMin{j56∈cells56()}(δtj56{j56});
ComputeTn56: ∀n56∈ℕ, t56^{n56=0}=0.0; , t56^{n56+1}=t56^{n56}+δt56^{n56+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter57: ∀j57∈cells57(), center57{j57} = (1.0/4.0) * ∑{r57∈nodesOfCell57(j57)}(coord57{r57});
IniIc57: ∀j57∈cells57(), if (center57{j57}.x < option_x_interface57) {
  ρ_ic57{j57}=option_ρ_ini_zg57;
  p_ic57{j57}=option_p_ini_zg57;
} else {
  ρ_ic57{j57}=option_ρ_ini_zd57;
  p_ic57{j57}=option_p_ini_zd57;
}

ComputeCjrIc57: ∀j57∈cells57(), ∀r57∈nodesOfCell57(j57), 
	C_ic57{j57,r57} = 0.5 * perp57(coord57{►(r57)} - coord57{◄(r57)});
IniVIc57: ∀j57∈cells57(), V_ic57{j57} = 0.5 * ∑{r57∈nodesOfCell57(j57)}(dot(C_ic57{j57,r57}, coord57{r57}));
IniM57: ∀j57∈cells57(), m57{j57} = ρ_ic57{j57} * V_ic57{j57}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr57: ∀j57∈cells57(), ∀r57∈nodesOfCell57(j57), C57{j57,r57} = 0.5 * perp57(X57{►(r57)} - X57{◄(r57)});
ComputeLjr57: ∀j57∈cells57(), ∀r57∈nodesOfCell57(j57), l57{j57,r57} = norm(C57{j57,r57});
Computeδtj57: ∀j57∈cells57(), δtj57{j57} = 2.0 * V57{j57} / (c57{j57} * ∑{r57∈nodesOfCell57(j57)}(l57{j57,r57}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity57: ∀j57∈cells57(), ρ57{j57} = m57{j57} / V57{j57};
ComputeEOSp57: ∀j57∈cells57(), p57{j57} = (γ57-1.0) * ρ57{j57} * e57{j57};
ComputeInternalEngergy57: ∀j57∈cells57(), e57{j57} = E57{j57} - 0.5 * dot(uj57{j57}, uj57{j57});
ComputeEOSc57: ∀j57∈cells57(), c57{j57} = √(γ57*p57{j57}/ρ57{j57}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr57: ∀j57∈cells57(), ∀r57∈nodesOfCell57(j57), Ajr57{j57,r57} = ((ρ57{j57}*c57{j57})/l57{j57,r57}) * tensProduct57(C57{j57,r57}, C57{j57,r57});
ComputeFjr57: ∀j57∈cells57(), ∀r57∈nodesOfCell57(j57), F57{j57,r57} = p57{j57}*C57{j57,r57} + matVectProduct57(Ajr57{j57,r57}, (uj57{j57}-ur57{r57}));
ComputeAr57: ∀r57∈nodes57(), Ar57{r57} = ∑{j57∈cellsOfNode57(r57)}(Ajr57{j57,r57});
ComputeBr57: ∀r57∈nodes57(), b57{r57} = ∑{j57∈cellsOfNode57(r57)}(p57{j57}*C57{j57,r57} + matVectProduct57(Ajr57{j57,r57}, uj57{j57}));
ComputeMt57: ∀r57∈innerNodes57(), Mt57{r57} = Ar57{r57};
ComputeBt57: ∀r57∈innerNodes57(), bt57{r57} = b57{r57};

OuterFacesComputations57: ∀k57∈outerFaces57(), {
	const ℝ epsilon57 = 1.0e-10;
	ℝ²ˣ² I57 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN57 = 0.0;
	ℝ X_MAX57 = X_EDGE_ELEMS57 * LENGTH57;
	ℝ Y_MIN57 = 0.0; 
	ℝ Y_MAX57 = Y_EDGE_ELEMS57 * LENGTH57;
	ℝ² nY57 = {0.0,1.0};
	
	∀r57∈nodesOfFace57(k57), {
		// Y boundary conditions (must be done before X)
		if ((X57{r57}.y-Y_MIN57 < epsilon57) || (X57{r57}.y-Y_MAX57 < epsilon57)) {
			ℝ sign57 = 0.0;
			if (X57{r57}.y-Y_MIN57 < epsilon57) sign57 = -1.0;
			else sign57 = 1.0;
			ℝ² n57 = sign57 * nY57;
      		ℝ²ˣ² nxn57 = tensProduct57(n57,n57);
      		ℝ²ˣ² IcP57 = I57 - nxn57;
			bt1{r57} = matVectProduct57(IcP57, b57{r57});
			Mt1{r57} = IcP57 * (Ar57{r57} * IcP57) + nxn57*trace57(Ar57{r57});
		}

		// X boundary conditions
		if ((Math.fabs(X57{r57}.x-X_MIN57) < epsilon57) || ( (Math.fabs(X57{r57}.x-X_MAX57) < epsilon57) )) {
			Mt57{r57} = I57;
			bt57{r57} = {0.0, 0.0};
		}
	}
}


ComputeU57: ∀r57∈nodes57(), ur57{r57} = matVectProduct57(inverse57(Mt57{r57}), bt57{r57});
ComputeV57: ∀j57∈cells57(), V57{j57} = 0.5 * ∑{r57∈nodesOfCell57(j57)}(dot(C57{j57,r57},X57{r57}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn57: ∀n57∈ℕ, ∀r057∈nodes57(), X57{r057}^{n57=0}=coord57{r057}; , ∀r57∈nodes57(), X57{r57}^{n57+1}=X57{r57}^{n57}+δt57^{n57}*ur57{r57};
ComputeUn57: ∀n57∈ℕ, ∀j057∈cells57(), uj57{j057}^{n57=0}={0.0,0.0}; , ∀j57∈cells57(), uj57{j57}^{n57+1}=uj57{j57}^{n57}-(δt57^{n57}/m57{j57})*∑{r57∈nodesOfCell57(j57)}(F57{j57,r57});
ComputeEn57: ∀n57∈ℕ, ∀j057∈cells57(), E57{j057}^{n57=0}=p_ic57{j057}/((γ57-1.0)*ρ_ic57{j057}); , ∀j57∈cells57(), E57{j57}^{n57+1}=E57{j57}^{n57} - (δt57^{n57} / m57{j57}) * ∑{r57∈nodesOfCell57(j57)}(dot(F57{j57,r57},ur57{r57}));
ComputeDt57: ∀n57∈ℕ, δt57^{n57=0}=option_δt_ini57;, δt57^{n57+1}=option_δt_cfl57*reduceMin{j57∈cells57()}(δtj57{j57});
ComputeTn57: ∀n57∈ℕ, t57^{n57=0}=0.0; , t57^{n57+1}=t57^{n57}+δt57^{n57+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter58: ∀j58∈cells58(), center58{j58} = (1.0/4.0) * ∑{r58∈nodesOfCell58(j58)}(coord58{r58});
IniIc58: ∀j58∈cells58(), if (center58{j58}.x < option_x_interface58) {
  ρ_ic58{j58}=option_ρ_ini_zg58;
  p_ic58{j58}=option_p_ini_zg58;
} else {
  ρ_ic58{j58}=option_ρ_ini_zd58;
  p_ic58{j58}=option_p_ini_zd58;
}

ComputeCjrIc58: ∀j58∈cells58(), ∀r58∈nodesOfCell58(j58), 
	C_ic58{j58,r58} = 0.5 * perp58(coord58{►(r58)} - coord58{◄(r58)});
IniVIc58: ∀j58∈cells58(), V_ic58{j58} = 0.5 * ∑{r58∈nodesOfCell58(j58)}(dot(C_ic58{j58,r58}, coord58{r58}));
IniM58: ∀j58∈cells58(), m58{j58} = ρ_ic58{j58} * V_ic58{j58}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr58: ∀j58∈cells58(), ∀r58∈nodesOfCell58(j58), C58{j58,r58} = 0.5 * perp58(X58{►(r58)} - X58{◄(r58)});
ComputeLjr58: ∀j58∈cells58(), ∀r58∈nodesOfCell58(j58), l58{j58,r58} = norm(C58{j58,r58});
Computeδtj58: ∀j58∈cells58(), δtj58{j58} = 2.0 * V58{j58} / (c58{j58} * ∑{r58∈nodesOfCell58(j58)}(l58{j58,r58}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity58: ∀j58∈cells58(), ρ58{j58} = m58{j58} / V58{j58};
ComputeEOSp58: ∀j58∈cells58(), p58{j58} = (γ58-1.0) * ρ58{j58} * e58{j58};
ComputeInternalEngergy58: ∀j58∈cells58(), e58{j58} = E58{j58} - 0.5 * dot(uj58{j58}, uj58{j58});
ComputeEOSc58: ∀j58∈cells58(), c58{j58} = √(γ58*p58{j58}/ρ58{j58}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr58: ∀j58∈cells58(), ∀r58∈nodesOfCell58(j58), Ajr58{j58,r58} = ((ρ58{j58}*c58{j58})/l58{j58,r58}) * tensProduct58(C58{j58,r58}, C58{j58,r58});
ComputeFjr58: ∀j58∈cells58(), ∀r58∈nodesOfCell58(j58), F58{j58,r58} = p58{j58}*C58{j58,r58} + matVectProduct58(Ajr58{j58,r58}, (uj58{j58}-ur58{r58}));
ComputeAr58: ∀r58∈nodes58(), Ar58{r58} = ∑{j58∈cellsOfNode58(r58)}(Ajr58{j58,r58});
ComputeBr58: ∀r58∈nodes58(), b58{r58} = ∑{j58∈cellsOfNode58(r58)}(p58{j58}*C58{j58,r58} + matVectProduct58(Ajr58{j58,r58}, uj58{j58}));
ComputeMt58: ∀r58∈innerNodes58(), Mt58{r58} = Ar58{r58};
ComputeBt58: ∀r58∈innerNodes58(), bt58{r58} = b58{r58};

OuterFacesComputations58: ∀k58∈outerFaces58(), {
	const ℝ epsilon58 = 1.0e-10;
	ℝ²ˣ² I58 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN58 = 0.0;
	ℝ X_MAX58 = X_EDGE_ELEMS58 * LENGTH58;
	ℝ Y_MIN58 = 0.0; 
	ℝ Y_MAX58 = Y_EDGE_ELEMS58 * LENGTH58;
	ℝ² nY58 = {0.0,1.0};
	
	∀r58∈nodesOfFace58(k58), {
		// Y boundary conditions (must be done before X)
		if ((X58{r58}.y-Y_MIN58 < epsilon58) || (X58{r58}.y-Y_MAX58 < epsilon58)) {
			ℝ sign58 = 0.0;
			if (X58{r58}.y-Y_MIN58 < epsilon58) sign58 = -1.0;
			else sign58 = 1.0;
			ℝ² n58 = sign58 * nY58;
      		ℝ²ˣ² nxn58 = tensProduct58(n58,n58);
      		ℝ²ˣ² IcP58 = I58 - nxn58;
			bt1{r58} = matVectProduct58(IcP58, b58{r58});
			Mt1{r58} = IcP58 * (Ar58{r58} * IcP58) + nxn58*trace58(Ar58{r58});
		}

		// X boundary conditions
		if ((Math.fabs(X58{r58}.x-X_MIN58) < epsilon58) || ( (Math.fabs(X58{r58}.x-X_MAX58) < epsilon58) )) {
			Mt58{r58} = I58;
			bt58{r58} = {0.0, 0.0};
		}
	}
}


ComputeU58: ∀r58∈nodes58(), ur58{r58} = matVectProduct58(inverse58(Mt58{r58}), bt58{r58});
ComputeV58: ∀j58∈cells58(), V58{j58} = 0.5 * ∑{r58∈nodesOfCell58(j58)}(dot(C58{j58,r58},X58{r58}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn58: ∀n58∈ℕ, ∀r058∈nodes58(), X58{r058}^{n58=0}=coord58{r058}; , ∀r58∈nodes58(), X58{r58}^{n58+1}=X58{r58}^{n58}+δt58^{n58}*ur58{r58};
ComputeUn58: ∀n58∈ℕ, ∀j058∈cells58(), uj58{j058}^{n58=0}={0.0,0.0}; , ∀j58∈cells58(), uj58{j58}^{n58+1}=uj58{j58}^{n58}-(δt58^{n58}/m58{j58})*∑{r58∈nodesOfCell58(j58)}(F58{j58,r58});
ComputeEn58: ∀n58∈ℕ, ∀j058∈cells58(), E58{j058}^{n58=0}=p_ic58{j058}/((γ58-1.0)*ρ_ic58{j058}); , ∀j58∈cells58(), E58{j58}^{n58+1}=E58{j58}^{n58} - (δt58^{n58} / m58{j58}) * ∑{r58∈nodesOfCell58(j58)}(dot(F58{j58,r58},ur58{r58}));
ComputeDt58: ∀n58∈ℕ, δt58^{n58=0}=option_δt_ini58;, δt58^{n58+1}=option_δt_cfl58*reduceMin{j58∈cells58()}(δtj58{j58});
ComputeTn58: ∀n58∈ℕ, t58^{n58=0}=0.0; , t58^{n58+1}=t58^{n58}+δt58^{n58+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter59: ∀j59∈cells59(), center59{j59} = (1.0/4.0) * ∑{r59∈nodesOfCell59(j59)}(coord59{r59});
IniIc59: ∀j59∈cells59(), if (center59{j59}.x < option_x_interface59) {
  ρ_ic59{j59}=option_ρ_ini_zg59;
  p_ic59{j59}=option_p_ini_zg59;
} else {
  ρ_ic59{j59}=option_ρ_ini_zd59;
  p_ic59{j59}=option_p_ini_zd59;
}

ComputeCjrIc59: ∀j59∈cells59(), ∀r59∈nodesOfCell59(j59), 
	C_ic59{j59,r59} = 0.5 * perp59(coord59{►(r59)} - coord59{◄(r59)});
IniVIc59: ∀j59∈cells59(), V_ic59{j59} = 0.5 * ∑{r59∈nodesOfCell59(j59)}(dot(C_ic59{j59,r59}, coord59{r59}));
IniM59: ∀j59∈cells59(), m59{j59} = ρ_ic59{j59} * V_ic59{j59}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr59: ∀j59∈cells59(), ∀r59∈nodesOfCell59(j59), C59{j59,r59} = 0.5 * perp59(X59{►(r59)} - X59{◄(r59)});
ComputeLjr59: ∀j59∈cells59(), ∀r59∈nodesOfCell59(j59), l59{j59,r59} = norm(C59{j59,r59});
Computeδtj59: ∀j59∈cells59(), δtj59{j59} = 2.0 * V59{j59} / (c59{j59} * ∑{r59∈nodesOfCell59(j59)}(l59{j59,r59}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity59: ∀j59∈cells59(), ρ59{j59} = m59{j59} / V59{j59};
ComputeEOSp59: ∀j59∈cells59(), p59{j59} = (γ59-1.0) * ρ59{j59} * e59{j59};
ComputeInternalEngergy59: ∀j59∈cells59(), e59{j59} = E59{j59} - 0.5 * dot(uj59{j59}, uj59{j59});
ComputeEOSc59: ∀j59∈cells59(), c59{j59} = √(γ59*p59{j59}/ρ59{j59}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr59: ∀j59∈cells59(), ∀r59∈nodesOfCell59(j59), Ajr59{j59,r59} = ((ρ59{j59}*c59{j59})/l59{j59,r59}) * tensProduct59(C59{j59,r59}, C59{j59,r59});
ComputeFjr59: ∀j59∈cells59(), ∀r59∈nodesOfCell59(j59), F59{j59,r59} = p59{j59}*C59{j59,r59} + matVectProduct59(Ajr59{j59,r59}, (uj59{j59}-ur59{r59}));
ComputeAr59: ∀r59∈nodes59(), Ar59{r59} = ∑{j59∈cellsOfNode59(r59)}(Ajr59{j59,r59});
ComputeBr59: ∀r59∈nodes59(), b59{r59} = ∑{j59∈cellsOfNode59(r59)}(p59{j59}*C59{j59,r59} + matVectProduct59(Ajr59{j59,r59}, uj59{j59}));
ComputeMt59: ∀r59∈innerNodes59(), Mt59{r59} = Ar59{r59};
ComputeBt59: ∀r59∈innerNodes59(), bt59{r59} = b59{r59};

OuterFacesComputations59: ∀k59∈outerFaces59(), {
	const ℝ epsilon59 = 1.0e-10;
	ℝ²ˣ² I59 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN59 = 0.0;
	ℝ X_MAX59 = X_EDGE_ELEMS59 * LENGTH59;
	ℝ Y_MIN59 = 0.0; 
	ℝ Y_MAX59 = Y_EDGE_ELEMS59 * LENGTH59;
	ℝ² nY59 = {0.0,1.0};
	
	∀r59∈nodesOfFace59(k59), {
		// Y boundary conditions (must be done before X)
		if ((X59{r59}.y-Y_MIN59 < epsilon59) || (X59{r59}.y-Y_MAX59 < epsilon59)) {
			ℝ sign59 = 0.0;
			if (X59{r59}.y-Y_MIN59 < epsilon59) sign59 = -1.0;
			else sign59 = 1.0;
			ℝ² n59 = sign59 * nY59;
      		ℝ²ˣ² nxn59 = tensProduct59(n59,n59);
      		ℝ²ˣ² IcP59 = I59 - nxn59;
			bt1{r59} = matVectProduct59(IcP59, b59{r59});
			Mt1{r59} = IcP59 * (Ar59{r59} * IcP59) + nxn59*trace59(Ar59{r59});
		}

		// X boundary conditions
		if ((Math.fabs(X59{r59}.x-X_MIN59) < epsilon59) || ( (Math.fabs(X59{r59}.x-X_MAX59) < epsilon59) )) {
			Mt59{r59} = I59;
			bt59{r59} = {0.0, 0.0};
		}
	}
}


ComputeU59: ∀r59∈nodes59(), ur59{r59} = matVectProduct59(inverse59(Mt59{r59}), bt59{r59});
ComputeV59: ∀j59∈cells59(), V59{j59} = 0.5 * ∑{r59∈nodesOfCell59(j59)}(dot(C59{j59,r59},X59{r59}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn59: ∀n59∈ℕ, ∀r059∈nodes59(), X59{r059}^{n59=0}=coord59{r059}; , ∀r59∈nodes59(), X59{r59}^{n59+1}=X59{r59}^{n59}+δt59^{n59}*ur59{r59};
ComputeUn59: ∀n59∈ℕ, ∀j059∈cells59(), uj59{j059}^{n59=0}={0.0,0.0}; , ∀j59∈cells59(), uj59{j59}^{n59+1}=uj59{j59}^{n59}-(δt59^{n59}/m59{j59})*∑{r59∈nodesOfCell59(j59)}(F59{j59,r59});
ComputeEn59: ∀n59∈ℕ, ∀j059∈cells59(), E59{j059}^{n59=0}=p_ic59{j059}/((γ59-1.0)*ρ_ic59{j059}); , ∀j59∈cells59(), E59{j59}^{n59+1}=E59{j59}^{n59} - (δt59^{n59} / m59{j59}) * ∑{r59∈nodesOfCell59(j59)}(dot(F59{j59,r59},ur59{r59}));
ComputeDt59: ∀n59∈ℕ, δt59^{n59=0}=option_δt_ini59;, δt59^{n59+1}=option_δt_cfl59*reduceMin{j59∈cells59()}(δtj59{j59});
ComputeTn59: ∀n59∈ℕ, t59^{n59=0}=0.0; , t59^{n59+1}=t59^{n59}+δt59^{n59+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter60: ∀j60∈cells60(), center60{j60} = (1.0/4.0) * ∑{r60∈nodesOfCell60(j60)}(coord60{r60});
IniIc60: ∀j60∈cells60(), if (center60{j60}.x < option_x_interface60) {
  ρ_ic60{j60}=option_ρ_ini_zg60;
  p_ic60{j60}=option_p_ini_zg60;
} else {
  ρ_ic60{j60}=option_ρ_ini_zd60;
  p_ic60{j60}=option_p_ini_zd60;
}

ComputeCjrIc60: ∀j60∈cells60(), ∀r60∈nodesOfCell60(j60), 
	C_ic60{j60,r60} = 0.5 * perp60(coord60{►(r60)} - coord60{◄(r60)});
IniVIc60: ∀j60∈cells60(), V_ic60{j60} = 0.5 * ∑{r60∈nodesOfCell60(j60)}(dot(C_ic60{j60,r60}, coord60{r60}));
IniM60: ∀j60∈cells60(), m60{j60} = ρ_ic60{j60} * V_ic60{j60}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr60: ∀j60∈cells60(), ∀r60∈nodesOfCell60(j60), C60{j60,r60} = 0.5 * perp60(X60{►(r60)} - X60{◄(r60)});
ComputeLjr60: ∀j60∈cells60(), ∀r60∈nodesOfCell60(j60), l60{j60,r60} = norm(C60{j60,r60});
Computeδtj60: ∀j60∈cells60(), δtj60{j60} = 2.0 * V60{j60} / (c60{j60} * ∑{r60∈nodesOfCell60(j60)}(l60{j60,r60}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity60: ∀j60∈cells60(), ρ60{j60} = m60{j60} / V60{j60};
ComputeEOSp60: ∀j60∈cells60(), p60{j60} = (γ60-1.0) * ρ60{j60} * e60{j60};
ComputeInternalEngergy60: ∀j60∈cells60(), e60{j60} = E60{j60} - 0.5 * dot(uj60{j60}, uj60{j60});
ComputeEOSc60: ∀j60∈cells60(), c60{j60} = √(γ60*p60{j60}/ρ60{j60}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr60: ∀j60∈cells60(), ∀r60∈nodesOfCell60(j60), Ajr60{j60,r60} = ((ρ60{j60}*c60{j60})/l60{j60,r60}) * tensProduct60(C60{j60,r60}, C60{j60,r60});
ComputeFjr60: ∀j60∈cells60(), ∀r60∈nodesOfCell60(j60), F60{j60,r60} = p60{j60}*C60{j60,r60} + matVectProduct60(Ajr60{j60,r60}, (uj60{j60}-ur60{r60}));
ComputeAr60: ∀r60∈nodes60(), Ar60{r60} = ∑{j60∈cellsOfNode60(r60)}(Ajr60{j60,r60});
ComputeBr60: ∀r60∈nodes60(), b60{r60} = ∑{j60∈cellsOfNode60(r60)}(p60{j60}*C60{j60,r60} + matVectProduct60(Ajr60{j60,r60}, uj60{j60}));
ComputeMt60: ∀r60∈innerNodes60(), Mt60{r60} = Ar60{r60};
ComputeBt60: ∀r60∈innerNodes60(), bt60{r60} = b60{r60};

OuterFacesComputations60: ∀k60∈outerFaces60(), {
	const ℝ epsilon60 = 1.0e-10;
	ℝ²ˣ² I60 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN60 = 0.0;
	ℝ X_MAX60 = X_EDGE_ELEMS60 * LENGTH60;
	ℝ Y_MIN60 = 0.0; 
	ℝ Y_MAX60 = Y_EDGE_ELEMS60 * LENGTH60;
	ℝ² nY60 = {0.0,1.0};
	
	∀r60∈nodesOfFace60(k60), {
		// Y boundary conditions (must be done before X)
		if ((X60{r60}.y-Y_MIN60 < epsilon60) || (X60{r60}.y-Y_MAX60 < epsilon60)) {
			ℝ sign60 = 0.0;
			if (X60{r60}.y-Y_MIN60 < epsilon60) sign60 = -1.0;
			else sign60 = 1.0;
			ℝ² n60 = sign60 * nY60;
      		ℝ²ˣ² nxn60 = tensProduct60(n60,n60);
      		ℝ²ˣ² IcP60 = I60 - nxn60;
			bt1{r60} = matVectProduct60(IcP60, b60{r60});
			Mt1{r60} = IcP60 * (Ar60{r60} * IcP60) + nxn60*trace60(Ar60{r60});
		}

		// X boundary conditions
		if ((Math.fabs(X60{r60}.x-X_MIN60) < epsilon60) || ( (Math.fabs(X60{r60}.x-X_MAX60) < epsilon60) )) {
			Mt60{r60} = I60;
			bt60{r60} = {0.0, 0.0};
		}
	}
}


ComputeU60: ∀r60∈nodes60(), ur60{r60} = matVectProduct60(inverse60(Mt60{r60}), bt60{r60});
ComputeV60: ∀j60∈cells60(), V60{j60} = 0.5 * ∑{r60∈nodesOfCell60(j60)}(dot(C60{j60,r60},X60{r60}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn60: ∀n60∈ℕ, ∀r060∈nodes60(), X60{r060}^{n60=0}=coord60{r060}; , ∀r60∈nodes60(), X60{r60}^{n60+1}=X60{r60}^{n60}+δt60^{n60}*ur60{r60};
ComputeUn60: ∀n60∈ℕ, ∀j060∈cells60(), uj60{j060}^{n60=0}={0.0,0.0}; , ∀j60∈cells60(), uj60{j60}^{n60+1}=uj60{j60}^{n60}-(δt60^{n60}/m60{j60})*∑{r60∈nodesOfCell60(j60)}(F60{j60,r60});
ComputeEn60: ∀n60∈ℕ, ∀j060∈cells60(), E60{j060}^{n60=0}=p_ic60{j060}/((γ60-1.0)*ρ_ic60{j060}); , ∀j60∈cells60(), E60{j60}^{n60+1}=E60{j60}^{n60} - (δt60^{n60} / m60{j60}) * ∑{r60∈nodesOfCell60(j60)}(dot(F60{j60,r60},ur60{r60}));
ComputeDt60: ∀n60∈ℕ, δt60^{n60=0}=option_δt_ini60;, δt60^{n60+1}=option_δt_cfl60*reduceMin{j60∈cells60()}(δtj60{j60});
ComputeTn60: ∀n60∈ℕ, t60^{n60=0}=0.0; , t60^{n60+1}=t60^{n60}+δt60^{n60+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter61: ∀j61∈cells61(), center61{j61} = (1.0/4.0) * ∑{r61∈nodesOfCell61(j61)}(coord61{r61});
IniIc61: ∀j61∈cells61(), if (center61{j61}.x < option_x_interface61) {
  ρ_ic61{j61}=option_ρ_ini_zg61;
  p_ic61{j61}=option_p_ini_zg61;
} else {
  ρ_ic61{j61}=option_ρ_ini_zd61;
  p_ic61{j61}=option_p_ini_zd61;
}

ComputeCjrIc61: ∀j61∈cells61(), ∀r61∈nodesOfCell61(j61), 
	C_ic61{j61,r61} = 0.5 * perp61(coord61{►(r61)} - coord61{◄(r61)});
IniVIc61: ∀j61∈cells61(), V_ic61{j61} = 0.5 * ∑{r61∈nodesOfCell61(j61)}(dot(C_ic61{j61,r61}, coord61{r61}));
IniM61: ∀j61∈cells61(), m61{j61} = ρ_ic61{j61} * V_ic61{j61}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr61: ∀j61∈cells61(), ∀r61∈nodesOfCell61(j61), C61{j61,r61} = 0.5 * perp61(X61{►(r61)} - X61{◄(r61)});
ComputeLjr61: ∀j61∈cells61(), ∀r61∈nodesOfCell61(j61), l61{j61,r61} = norm(C61{j61,r61});
Computeδtj61: ∀j61∈cells61(), δtj61{j61} = 2.0 * V61{j61} / (c61{j61} * ∑{r61∈nodesOfCell61(j61)}(l61{j61,r61}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity61: ∀j61∈cells61(), ρ61{j61} = m61{j61} / V61{j61};
ComputeEOSp61: ∀j61∈cells61(), p61{j61} = (γ61-1.0) * ρ61{j61} * e61{j61};
ComputeInternalEngergy61: ∀j61∈cells61(), e61{j61} = E61{j61} - 0.5 * dot(uj61{j61}, uj61{j61});
ComputeEOSc61: ∀j61∈cells61(), c61{j61} = √(γ61*p61{j61}/ρ61{j61}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr61: ∀j61∈cells61(), ∀r61∈nodesOfCell61(j61), Ajr61{j61,r61} = ((ρ61{j61}*c61{j61})/l61{j61,r61}) * tensProduct61(C61{j61,r61}, C61{j61,r61});
ComputeFjr61: ∀j61∈cells61(), ∀r61∈nodesOfCell61(j61), F61{j61,r61} = p61{j61}*C61{j61,r61} + matVectProduct61(Ajr61{j61,r61}, (uj61{j61}-ur61{r61}));
ComputeAr61: ∀r61∈nodes61(), Ar61{r61} = ∑{j61∈cellsOfNode61(r61)}(Ajr61{j61,r61});
ComputeBr61: ∀r61∈nodes61(), b61{r61} = ∑{j61∈cellsOfNode61(r61)}(p61{j61}*C61{j61,r61} + matVectProduct61(Ajr61{j61,r61}, uj61{j61}));
ComputeMt61: ∀r61∈innerNodes61(), Mt61{r61} = Ar61{r61};
ComputeBt61: ∀r61∈innerNodes61(), bt61{r61} = b61{r61};

OuterFacesComputations61: ∀k61∈outerFaces61(), {
	const ℝ epsilon61 = 1.0e-10;
	ℝ²ˣ² I61 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN61 = 0.0;
	ℝ X_MAX61 = X_EDGE_ELEMS61 * LENGTH61;
	ℝ Y_MIN61 = 0.0; 
	ℝ Y_MAX61 = Y_EDGE_ELEMS61 * LENGTH61;
	ℝ² nY61 = {0.0,1.0};
	
	∀r61∈nodesOfFace61(k61), {
		// Y boundary conditions (must be done before X)
		if ((X61{r61}.y-Y_MIN61 < epsilon61) || (X61{r61}.y-Y_MAX61 < epsilon61)) {
			ℝ sign61 = 0.0;
			if (X61{r61}.y-Y_MIN61 < epsilon61) sign61 = -1.0;
			else sign61 = 1.0;
			ℝ² n61 = sign61 * nY61;
      		ℝ²ˣ² nxn61 = tensProduct61(n61,n61);
      		ℝ²ˣ² IcP61 = I61 - nxn61;
			bt1{r61} = matVectProduct61(IcP61, b61{r61});
			Mt1{r61} = IcP61 * (Ar61{r61} * IcP61) + nxn61*trace61(Ar61{r61});
		}

		// X boundary conditions
		if ((Math.fabs(X61{r61}.x-X_MIN61) < epsilon61) || ( (Math.fabs(X61{r61}.x-X_MAX61) < epsilon61) )) {
			Mt61{r61} = I61;
			bt61{r61} = {0.0, 0.0};
		}
	}
}


ComputeU61: ∀r61∈nodes61(), ur61{r61} = matVectProduct61(inverse61(Mt61{r61}), bt61{r61});
ComputeV61: ∀j61∈cells61(), V61{j61} = 0.5 * ∑{r61∈nodesOfCell61(j61)}(dot(C61{j61,r61},X61{r61}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn61: ∀n61∈ℕ, ∀r061∈nodes61(), X61{r061}^{n61=0}=coord61{r061}; , ∀r61∈nodes61(), X61{r61}^{n61+1}=X61{r61}^{n61}+δt61^{n61}*ur61{r61};
ComputeUn61: ∀n61∈ℕ, ∀j061∈cells61(), uj61{j061}^{n61=0}={0.0,0.0}; , ∀j61∈cells61(), uj61{j61}^{n61+1}=uj61{j61}^{n61}-(δt61^{n61}/m61{j61})*∑{r61∈nodesOfCell61(j61)}(F61{j61,r61});
ComputeEn61: ∀n61∈ℕ, ∀j061∈cells61(), E61{j061}^{n61=0}=p_ic61{j061}/((γ61-1.0)*ρ_ic61{j061}); , ∀j61∈cells61(), E61{j61}^{n61+1}=E61{j61}^{n61} - (δt61^{n61} / m61{j61}) * ∑{r61∈nodesOfCell61(j61)}(dot(F61{j61,r61},ur61{r61}));
ComputeDt61: ∀n61∈ℕ, δt61^{n61=0}=option_δt_ini61;, δt61^{n61+1}=option_δt_cfl61*reduceMin{j61∈cells61()}(δtj61{j61});
ComputeTn61: ∀n61∈ℕ, t61^{n61=0}=0.0; , t61^{n61+1}=t61^{n61}+δt61^{n61+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter62: ∀j62∈cells62(), center62{j62} = (1.0/4.0) * ∑{r62∈nodesOfCell62(j62)}(coord62{r62});
IniIc62: ∀j62∈cells62(), if (center62{j62}.x < option_x_interface62) {
  ρ_ic62{j62}=option_ρ_ini_zg62;
  p_ic62{j62}=option_p_ini_zg62;
} else {
  ρ_ic62{j62}=option_ρ_ini_zd62;
  p_ic62{j62}=option_p_ini_zd62;
}

ComputeCjrIc62: ∀j62∈cells62(), ∀r62∈nodesOfCell62(j62), 
	C_ic62{j62,r62} = 0.5 * perp62(coord62{►(r62)} - coord62{◄(r62)});
IniVIc62: ∀j62∈cells62(), V_ic62{j62} = 0.5 * ∑{r62∈nodesOfCell62(j62)}(dot(C_ic62{j62,r62}, coord62{r62}));
IniM62: ∀j62∈cells62(), m62{j62} = ρ_ic62{j62} * V_ic62{j62}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr62: ∀j62∈cells62(), ∀r62∈nodesOfCell62(j62), C62{j62,r62} = 0.5 * perp62(X62{►(r62)} - X62{◄(r62)});
ComputeLjr62: ∀j62∈cells62(), ∀r62∈nodesOfCell62(j62), l62{j62,r62} = norm(C62{j62,r62});
Computeδtj62: ∀j62∈cells62(), δtj62{j62} = 2.0 * V62{j62} / (c62{j62} * ∑{r62∈nodesOfCell62(j62)}(l62{j62,r62}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity62: ∀j62∈cells62(), ρ62{j62} = m62{j62} / V62{j62};
ComputeEOSp62: ∀j62∈cells62(), p62{j62} = (γ62-1.0) * ρ62{j62} * e62{j62};
ComputeInternalEngergy62: ∀j62∈cells62(), e62{j62} = E62{j62} - 0.5 * dot(uj62{j62}, uj62{j62});
ComputeEOSc62: ∀j62∈cells62(), c62{j62} = √(γ62*p62{j62}/ρ62{j62}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr62: ∀j62∈cells62(), ∀r62∈nodesOfCell62(j62), Ajr62{j62,r62} = ((ρ62{j62}*c62{j62})/l62{j62,r62}) * tensProduct62(C62{j62,r62}, C62{j62,r62});
ComputeFjr62: ∀j62∈cells62(), ∀r62∈nodesOfCell62(j62), F62{j62,r62} = p62{j62}*C62{j62,r62} + matVectProduct62(Ajr62{j62,r62}, (uj62{j62}-ur62{r62}));
ComputeAr62: ∀r62∈nodes62(), Ar62{r62} = ∑{j62∈cellsOfNode62(r62)}(Ajr62{j62,r62});
ComputeBr62: ∀r62∈nodes62(), b62{r62} = ∑{j62∈cellsOfNode62(r62)}(p62{j62}*C62{j62,r62} + matVectProduct62(Ajr62{j62,r62}, uj62{j62}));
ComputeMt62: ∀r62∈innerNodes62(), Mt62{r62} = Ar62{r62};
ComputeBt62: ∀r62∈innerNodes62(), bt62{r62} = b62{r62};

OuterFacesComputations62: ∀k62∈outerFaces62(), {
	const ℝ epsilon62 = 1.0e-10;
	ℝ²ˣ² I62 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN62 = 0.0;
	ℝ X_MAX62 = X_EDGE_ELEMS62 * LENGTH62;
	ℝ Y_MIN62 = 0.0; 
	ℝ Y_MAX62 = Y_EDGE_ELEMS62 * LENGTH62;
	ℝ² nY62 = {0.0,1.0};
	
	∀r62∈nodesOfFace62(k62), {
		// Y boundary conditions (must be done before X)
		if ((X62{r62}.y-Y_MIN62 < epsilon62) || (X62{r62}.y-Y_MAX62 < epsilon62)) {
			ℝ sign62 = 0.0;
			if (X62{r62}.y-Y_MIN62 < epsilon62) sign62 = -1.0;
			else sign62 = 1.0;
			ℝ² n62 = sign62 * nY62;
      		ℝ²ˣ² nxn62 = tensProduct62(n62,n62);
      		ℝ²ˣ² IcP62 = I62 - nxn62;
			bt1{r62} = matVectProduct62(IcP62, b62{r62});
			Mt1{r62} = IcP62 * (Ar62{r62} * IcP62) + nxn62*trace62(Ar62{r62});
		}

		// X boundary conditions
		if ((Math.fabs(X62{r62}.x-X_MIN62) < epsilon62) || ( (Math.fabs(X62{r62}.x-X_MAX62) < epsilon62) )) {
			Mt62{r62} = I62;
			bt62{r62} = {0.0, 0.0};
		}
	}
}


ComputeU62: ∀r62∈nodes62(), ur62{r62} = matVectProduct62(inverse62(Mt62{r62}), bt62{r62});
ComputeV62: ∀j62∈cells62(), V62{j62} = 0.5 * ∑{r62∈nodesOfCell62(j62)}(dot(C62{j62,r62},X62{r62}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn62: ∀n62∈ℕ, ∀r062∈nodes62(), X62{r062}^{n62=0}=coord62{r062}; , ∀r62∈nodes62(), X62{r62}^{n62+1}=X62{r62}^{n62}+δt62^{n62}*ur62{r62};
ComputeUn62: ∀n62∈ℕ, ∀j062∈cells62(), uj62{j062}^{n62=0}={0.0,0.0}; , ∀j62∈cells62(), uj62{j62}^{n62+1}=uj62{j62}^{n62}-(δt62^{n62}/m62{j62})*∑{r62∈nodesOfCell62(j62)}(F62{j62,r62});
ComputeEn62: ∀n62∈ℕ, ∀j062∈cells62(), E62{j062}^{n62=0}=p_ic62{j062}/((γ62-1.0)*ρ_ic62{j062}); , ∀j62∈cells62(), E62{j62}^{n62+1}=E62{j62}^{n62} - (δt62^{n62} / m62{j62}) * ∑{r62∈nodesOfCell62(j62)}(dot(F62{j62,r62},ur62{r62}));
ComputeDt62: ∀n62∈ℕ, δt62^{n62=0}=option_δt_ini62;, δt62^{n62+1}=option_δt_cfl62*reduceMin{j62∈cells62()}(δtj62{j62});
ComputeTn62: ∀n62∈ℕ, t62^{n62=0}=0.0; , t62^{n62+1}=t62^{n62}+δt62^{n62+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter63: ∀j63∈cells63(), center63{j63} = (1.0/4.0) * ∑{r63∈nodesOfCell63(j63)}(coord63{r63});
IniIc63: ∀j63∈cells63(), if (center63{j63}.x < option_x_interface63) {
  ρ_ic63{j63}=option_ρ_ini_zg63;
  p_ic63{j63}=option_p_ini_zg63;
} else {
  ρ_ic63{j63}=option_ρ_ini_zd63;
  p_ic63{j63}=option_p_ini_zd63;
}

ComputeCjrIc63: ∀j63∈cells63(), ∀r63∈nodesOfCell63(j63), 
	C_ic63{j63,r63} = 0.5 * perp63(coord63{►(r63)} - coord63{◄(r63)});
IniVIc63: ∀j63∈cells63(), V_ic63{j63} = 0.5 * ∑{r63∈nodesOfCell63(j63)}(dot(C_ic63{j63,r63}, coord63{r63}));
IniM63: ∀j63∈cells63(), m63{j63} = ρ_ic63{j63} * V_ic63{j63}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr63: ∀j63∈cells63(), ∀r63∈nodesOfCell63(j63), C63{j63,r63} = 0.5 * perp63(X63{►(r63)} - X63{◄(r63)});
ComputeLjr63: ∀j63∈cells63(), ∀r63∈nodesOfCell63(j63), l63{j63,r63} = norm(C63{j63,r63});
Computeδtj63: ∀j63∈cells63(), δtj63{j63} = 2.0 * V63{j63} / (c63{j63} * ∑{r63∈nodesOfCell63(j63)}(l63{j63,r63}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity63: ∀j63∈cells63(), ρ63{j63} = m63{j63} / V63{j63};
ComputeEOSp63: ∀j63∈cells63(), p63{j63} = (γ63-1.0) * ρ63{j63} * e63{j63};
ComputeInternalEngergy63: ∀j63∈cells63(), e63{j63} = E63{j63} - 0.5 * dot(uj63{j63}, uj63{j63});
ComputeEOSc63: ∀j63∈cells63(), c63{j63} = √(γ63*p63{j63}/ρ63{j63}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr63: ∀j63∈cells63(), ∀r63∈nodesOfCell63(j63), Ajr63{j63,r63} = ((ρ63{j63}*c63{j63})/l63{j63,r63}) * tensProduct63(C63{j63,r63}, C63{j63,r63});
ComputeFjr63: ∀j63∈cells63(), ∀r63∈nodesOfCell63(j63), F63{j63,r63} = p63{j63}*C63{j63,r63} + matVectProduct63(Ajr63{j63,r63}, (uj63{j63}-ur63{r63}));
ComputeAr63: ∀r63∈nodes63(), Ar63{r63} = ∑{j63∈cellsOfNode63(r63)}(Ajr63{j63,r63});
ComputeBr63: ∀r63∈nodes63(), b63{r63} = ∑{j63∈cellsOfNode63(r63)}(p63{j63}*C63{j63,r63} + matVectProduct63(Ajr63{j63,r63}, uj63{j63}));
ComputeMt63: ∀r63∈innerNodes63(), Mt63{r63} = Ar63{r63};
ComputeBt63: ∀r63∈innerNodes63(), bt63{r63} = b63{r63};

OuterFacesComputations63: ∀k63∈outerFaces63(), {
	const ℝ epsilon63 = 1.0e-10;
	ℝ²ˣ² I63 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN63 = 0.0;
	ℝ X_MAX63 = X_EDGE_ELEMS63 * LENGTH63;
	ℝ Y_MIN63 = 0.0; 
	ℝ Y_MAX63 = Y_EDGE_ELEMS63 * LENGTH63;
	ℝ² nY63 = {0.0,1.0};
	
	∀r63∈nodesOfFace63(k63), {
		// Y boundary conditions (must be done before X)
		if ((X63{r63}.y-Y_MIN63 < epsilon63) || (X63{r63}.y-Y_MAX63 < epsilon63)) {
			ℝ sign63 = 0.0;
			if (X63{r63}.y-Y_MIN63 < epsilon63) sign63 = -1.0;
			else sign63 = 1.0;
			ℝ² n63 = sign63 * nY63;
      		ℝ²ˣ² nxn63 = tensProduct63(n63,n63);
      		ℝ²ˣ² IcP63 = I63 - nxn63;
			bt1{r63} = matVectProduct63(IcP63, b63{r63});
			Mt1{r63} = IcP63 * (Ar63{r63} * IcP63) + nxn63*trace63(Ar63{r63});
		}

		// X boundary conditions
		if ((Math.fabs(X63{r63}.x-X_MIN63) < epsilon63) || ( (Math.fabs(X63{r63}.x-X_MAX63) < epsilon63) )) {
			Mt63{r63} = I63;
			bt63{r63} = {0.0, 0.0};
		}
	}
}


ComputeU63: ∀r63∈nodes63(), ur63{r63} = matVectProduct63(inverse63(Mt63{r63}), bt63{r63});
ComputeV63: ∀j63∈cells63(), V63{j63} = 0.5 * ∑{r63∈nodesOfCell63(j63)}(dot(C63{j63,r63},X63{r63}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn63: ∀n63∈ℕ, ∀r063∈nodes63(), X63{r063}^{n63=0}=coord63{r063}; , ∀r63∈nodes63(), X63{r63}^{n63+1}=X63{r63}^{n63}+δt63^{n63}*ur63{r63};
ComputeUn63: ∀n63∈ℕ, ∀j063∈cells63(), uj63{j063}^{n63=0}={0.0,0.0}; , ∀j63∈cells63(), uj63{j63}^{n63+1}=uj63{j63}^{n63}-(δt63^{n63}/m63{j63})*∑{r63∈nodesOfCell63(j63)}(F63{j63,r63});
ComputeEn63: ∀n63∈ℕ, ∀j063∈cells63(), E63{j063}^{n63=0}=p_ic63{j063}/((γ63-1.0)*ρ_ic63{j063}); , ∀j63∈cells63(), E63{j63}^{n63+1}=E63{j63}^{n63} - (δt63^{n63} / m63{j63}) * ∑{r63∈nodesOfCell63(j63)}(dot(F63{j63,r63},ur63{r63}));
ComputeDt63: ∀n63∈ℕ, δt63^{n63=0}=option_δt_ini63;, δt63^{n63+1}=option_δt_cfl63*reduceMin{j63∈cells63()}(δtj63{j63});
ComputeTn63: ∀n63∈ℕ, t63^{n63=0}=0.0; , t63^{n63+1}=t63^{n63}+δt63^{n63+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter64: ∀j64∈cells64(), center64{j64} = (1.0/4.0) * ∑{r64∈nodesOfCell64(j64)}(coord64{r64});
IniIc64: ∀j64∈cells64(), if (center64{j64}.x < option_x_interface64) {
  ρ_ic64{j64}=option_ρ_ini_zg64;
  p_ic64{j64}=option_p_ini_zg64;
} else {
  ρ_ic64{j64}=option_ρ_ini_zd64;
  p_ic64{j64}=option_p_ini_zd64;
}

ComputeCjrIc64: ∀j64∈cells64(), ∀r64∈nodesOfCell64(j64), 
	C_ic64{j64,r64} = 0.5 * perp64(coord64{►(r64)} - coord64{◄(r64)});
IniVIc64: ∀j64∈cells64(), V_ic64{j64} = 0.5 * ∑{r64∈nodesOfCell64(j64)}(dot(C_ic64{j64,r64}, coord64{r64}));
IniM64: ∀j64∈cells64(), m64{j64} = ρ_ic64{j64} * V_ic64{j64}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr64: ∀j64∈cells64(), ∀r64∈nodesOfCell64(j64), C64{j64,r64} = 0.5 * perp64(X64{►(r64)} - X64{◄(r64)});
ComputeLjr64: ∀j64∈cells64(), ∀r64∈nodesOfCell64(j64), l64{j64,r64} = norm(C64{j64,r64});
Computeδtj64: ∀j64∈cells64(), δtj64{j64} = 2.0 * V64{j64} / (c64{j64} * ∑{r64∈nodesOfCell64(j64)}(l64{j64,r64}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity64: ∀j64∈cells64(), ρ64{j64} = m64{j64} / V64{j64};
ComputeEOSp64: ∀j64∈cells64(), p64{j64} = (γ64-1.0) * ρ64{j64} * e64{j64};
ComputeInternalEngergy64: ∀j64∈cells64(), e64{j64} = E64{j64} - 0.5 * dot(uj64{j64}, uj64{j64});
ComputeEOSc64: ∀j64∈cells64(), c64{j64} = √(γ64*p64{j64}/ρ64{j64}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr64: ∀j64∈cells64(), ∀r64∈nodesOfCell64(j64), Ajr64{j64,r64} = ((ρ64{j64}*c64{j64})/l64{j64,r64}) * tensProduct64(C64{j64,r64}, C64{j64,r64});
ComputeFjr64: ∀j64∈cells64(), ∀r64∈nodesOfCell64(j64), F64{j64,r64} = p64{j64}*C64{j64,r64} + matVectProduct64(Ajr64{j64,r64}, (uj64{j64}-ur64{r64}));
ComputeAr64: ∀r64∈nodes64(), Ar64{r64} = ∑{j64∈cellsOfNode64(r64)}(Ajr64{j64,r64});
ComputeBr64: ∀r64∈nodes64(), b64{r64} = ∑{j64∈cellsOfNode64(r64)}(p64{j64}*C64{j64,r64} + matVectProduct64(Ajr64{j64,r64}, uj64{j64}));
ComputeMt64: ∀r64∈innerNodes64(), Mt64{r64} = Ar64{r64};
ComputeBt64: ∀r64∈innerNodes64(), bt64{r64} = b64{r64};

OuterFacesComputations64: ∀k64∈outerFaces64(), {
	const ℝ epsilon64 = 1.0e-10;
	ℝ²ˣ² I64 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN64 = 0.0;
	ℝ X_MAX64 = X_EDGE_ELEMS64 * LENGTH64;
	ℝ Y_MIN64 = 0.0; 
	ℝ Y_MAX64 = Y_EDGE_ELEMS64 * LENGTH64;
	ℝ² nY64 = {0.0,1.0};
	
	∀r64∈nodesOfFace64(k64), {
		// Y boundary conditions (must be done before X)
		if ((X64{r64}.y-Y_MIN64 < epsilon64) || (X64{r64}.y-Y_MAX64 < epsilon64)) {
			ℝ sign64 = 0.0;
			if (X64{r64}.y-Y_MIN64 < epsilon64) sign64 = -1.0;
			else sign64 = 1.0;
			ℝ² n64 = sign64 * nY64;
      		ℝ²ˣ² nxn64 = tensProduct64(n64,n64);
      		ℝ²ˣ² IcP64 = I64 - nxn64;
			bt1{r64} = matVectProduct64(IcP64, b64{r64});
			Mt1{r64} = IcP64 * (Ar64{r64} * IcP64) + nxn64*trace64(Ar64{r64});
		}

		// X boundary conditions
		if ((Math.fabs(X64{r64}.x-X_MIN64) < epsilon64) || ( (Math.fabs(X64{r64}.x-X_MAX64) < epsilon64) )) {
			Mt64{r64} = I64;
			bt64{r64} = {0.0, 0.0};
		}
	}
}


ComputeU64: ∀r64∈nodes64(), ur64{r64} = matVectProduct64(inverse64(Mt64{r64}), bt64{r64});
ComputeV64: ∀j64∈cells64(), V64{j64} = 0.5 * ∑{r64∈nodesOfCell64(j64)}(dot(C64{j64,r64},X64{r64}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn64: ∀n64∈ℕ, ∀r064∈nodes64(), X64{r064}^{n64=0}=coord64{r064}; , ∀r64∈nodes64(), X64{r64}^{n64+1}=X64{r64}^{n64}+δt64^{n64}*ur64{r64};
ComputeUn64: ∀n64∈ℕ, ∀j064∈cells64(), uj64{j064}^{n64=0}={0.0,0.0}; , ∀j64∈cells64(), uj64{j64}^{n64+1}=uj64{j64}^{n64}-(δt64^{n64}/m64{j64})*∑{r64∈nodesOfCell64(j64)}(F64{j64,r64});
ComputeEn64: ∀n64∈ℕ, ∀j064∈cells64(), E64{j064}^{n64=0}=p_ic64{j064}/((γ64-1.0)*ρ_ic64{j064}); , ∀j64∈cells64(), E64{j64}^{n64+1}=E64{j64}^{n64} - (δt64^{n64} / m64{j64}) * ∑{r64∈nodesOfCell64(j64)}(dot(F64{j64,r64},ur64{r64}));
ComputeDt64: ∀n64∈ℕ, δt64^{n64=0}=option_δt_ini64;, δt64^{n64+1}=option_δt_cfl64*reduceMin{j64∈cells64()}(δtj64{j64});
ComputeTn64: ∀n64∈ℕ, t64^{n64=0}=0.0; , t64^{n64+1}=t64^{n64}+δt64^{n64+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter65: ∀j65∈cells65(), center65{j65} = (1.0/4.0) * ∑{r65∈nodesOfCell65(j65)}(coord65{r65});
IniIc65: ∀j65∈cells65(), if (center65{j65}.x < option_x_interface65) {
  ρ_ic65{j65}=option_ρ_ini_zg65;
  p_ic65{j65}=option_p_ini_zg65;
} else {
  ρ_ic65{j65}=option_ρ_ini_zd65;
  p_ic65{j65}=option_p_ini_zd65;
}

ComputeCjrIc65: ∀j65∈cells65(), ∀r65∈nodesOfCell65(j65), 
	C_ic65{j65,r65} = 0.5 * perp65(coord65{►(r65)} - coord65{◄(r65)});
IniVIc65: ∀j65∈cells65(), V_ic65{j65} = 0.5 * ∑{r65∈nodesOfCell65(j65)}(dot(C_ic65{j65,r65}, coord65{r65}));
IniM65: ∀j65∈cells65(), m65{j65} = ρ_ic65{j65} * V_ic65{j65}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr65: ∀j65∈cells65(), ∀r65∈nodesOfCell65(j65), C65{j65,r65} = 0.5 * perp65(X65{►(r65)} - X65{◄(r65)});
ComputeLjr65: ∀j65∈cells65(), ∀r65∈nodesOfCell65(j65), l65{j65,r65} = norm(C65{j65,r65});
Computeδtj65: ∀j65∈cells65(), δtj65{j65} = 2.0 * V65{j65} / (c65{j65} * ∑{r65∈nodesOfCell65(j65)}(l65{j65,r65}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity65: ∀j65∈cells65(), ρ65{j65} = m65{j65} / V65{j65};
ComputeEOSp65: ∀j65∈cells65(), p65{j65} = (γ65-1.0) * ρ65{j65} * e65{j65};
ComputeInternalEngergy65: ∀j65∈cells65(), e65{j65} = E65{j65} - 0.5 * dot(uj65{j65}, uj65{j65});
ComputeEOSc65: ∀j65∈cells65(), c65{j65} = √(γ65*p65{j65}/ρ65{j65}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr65: ∀j65∈cells65(), ∀r65∈nodesOfCell65(j65), Ajr65{j65,r65} = ((ρ65{j65}*c65{j65})/l65{j65,r65}) * tensProduct65(C65{j65,r65}, C65{j65,r65});
ComputeFjr65: ∀j65∈cells65(), ∀r65∈nodesOfCell65(j65), F65{j65,r65} = p65{j65}*C65{j65,r65} + matVectProduct65(Ajr65{j65,r65}, (uj65{j65}-ur65{r65}));
ComputeAr65: ∀r65∈nodes65(), Ar65{r65} = ∑{j65∈cellsOfNode65(r65)}(Ajr65{j65,r65});
ComputeBr65: ∀r65∈nodes65(), b65{r65} = ∑{j65∈cellsOfNode65(r65)}(p65{j65}*C65{j65,r65} + matVectProduct65(Ajr65{j65,r65}, uj65{j65}));
ComputeMt65: ∀r65∈innerNodes65(), Mt65{r65} = Ar65{r65};
ComputeBt65: ∀r65∈innerNodes65(), bt65{r65} = b65{r65};

OuterFacesComputations65: ∀k65∈outerFaces65(), {
	const ℝ epsilon65 = 1.0e-10;
	ℝ²ˣ² I65 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN65 = 0.0;
	ℝ X_MAX65 = X_EDGE_ELEMS65 * LENGTH65;
	ℝ Y_MIN65 = 0.0; 
	ℝ Y_MAX65 = Y_EDGE_ELEMS65 * LENGTH65;
	ℝ² nY65 = {0.0,1.0};
	
	∀r65∈nodesOfFace65(k65), {
		// Y boundary conditions (must be done before X)
		if ((X65{r65}.y-Y_MIN65 < epsilon65) || (X65{r65}.y-Y_MAX65 < epsilon65)) {
			ℝ sign65 = 0.0;
			if (X65{r65}.y-Y_MIN65 < epsilon65) sign65 = -1.0;
			else sign65 = 1.0;
			ℝ² n65 = sign65 * nY65;
      		ℝ²ˣ² nxn65 = tensProduct65(n65,n65);
      		ℝ²ˣ² IcP65 = I65 - nxn65;
			bt1{r65} = matVectProduct65(IcP65, b65{r65});
			Mt1{r65} = IcP65 * (Ar65{r65} * IcP65) + nxn65*trace65(Ar65{r65});
		}

		// X boundary conditions
		if ((Math.fabs(X65{r65}.x-X_MIN65) < epsilon65) || ( (Math.fabs(X65{r65}.x-X_MAX65) < epsilon65) )) {
			Mt65{r65} = I65;
			bt65{r65} = {0.0, 0.0};
		}
	}
}


ComputeU65: ∀r65∈nodes65(), ur65{r65} = matVectProduct65(inverse65(Mt65{r65}), bt65{r65});
ComputeV65: ∀j65∈cells65(), V65{j65} = 0.5 * ∑{r65∈nodesOfCell65(j65)}(dot(C65{j65,r65},X65{r65}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn65: ∀n65∈ℕ, ∀r065∈nodes65(), X65{r065}^{n65=0}=coord65{r065}; , ∀r65∈nodes65(), X65{r65}^{n65+1}=X65{r65}^{n65}+δt65^{n65}*ur65{r65};
ComputeUn65: ∀n65∈ℕ, ∀j065∈cells65(), uj65{j065}^{n65=0}={0.0,0.0}; , ∀j65∈cells65(), uj65{j65}^{n65+1}=uj65{j65}^{n65}-(δt65^{n65}/m65{j65})*∑{r65∈nodesOfCell65(j65)}(F65{j65,r65});
ComputeEn65: ∀n65∈ℕ, ∀j065∈cells65(), E65{j065}^{n65=0}=p_ic65{j065}/((γ65-1.0)*ρ_ic65{j065}); , ∀j65∈cells65(), E65{j65}^{n65+1}=E65{j65}^{n65} - (δt65^{n65} / m65{j65}) * ∑{r65∈nodesOfCell65(j65)}(dot(F65{j65,r65},ur65{r65}));
ComputeDt65: ∀n65∈ℕ, δt65^{n65=0}=option_δt_ini65;, δt65^{n65+1}=option_δt_cfl65*reduceMin{j65∈cells65()}(δtj65{j65});
ComputeTn65: ∀n65∈ℕ, t65^{n65=0}=0.0; , t65^{n65+1}=t65^{n65}+δt65^{n65+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter66: ∀j66∈cells66(), center66{j66} = (1.0/4.0) * ∑{r66∈nodesOfCell66(j66)}(coord66{r66});
IniIc66: ∀j66∈cells66(), if (center66{j66}.x < option_x_interface66) {
  ρ_ic66{j66}=option_ρ_ini_zg66;
  p_ic66{j66}=option_p_ini_zg66;
} else {
  ρ_ic66{j66}=option_ρ_ini_zd66;
  p_ic66{j66}=option_p_ini_zd66;
}

ComputeCjrIc66: ∀j66∈cells66(), ∀r66∈nodesOfCell66(j66), 
	C_ic66{j66,r66} = 0.5 * perp66(coord66{►(r66)} - coord66{◄(r66)});
IniVIc66: ∀j66∈cells66(), V_ic66{j66} = 0.5 * ∑{r66∈nodesOfCell66(j66)}(dot(C_ic66{j66,r66}, coord66{r66}));
IniM66: ∀j66∈cells66(), m66{j66} = ρ_ic66{j66} * V_ic66{j66}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr66: ∀j66∈cells66(), ∀r66∈nodesOfCell66(j66), C66{j66,r66} = 0.5 * perp66(X66{►(r66)} - X66{◄(r66)});
ComputeLjr66: ∀j66∈cells66(), ∀r66∈nodesOfCell66(j66), l66{j66,r66} = norm(C66{j66,r66});
Computeδtj66: ∀j66∈cells66(), δtj66{j66} = 2.0 * V66{j66} / (c66{j66} * ∑{r66∈nodesOfCell66(j66)}(l66{j66,r66}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity66: ∀j66∈cells66(), ρ66{j66} = m66{j66} / V66{j66};
ComputeEOSp66: ∀j66∈cells66(), p66{j66} = (γ66-1.0) * ρ66{j66} * e66{j66};
ComputeInternalEngergy66: ∀j66∈cells66(), e66{j66} = E66{j66} - 0.5 * dot(uj66{j66}, uj66{j66});
ComputeEOSc66: ∀j66∈cells66(), c66{j66} = √(γ66*p66{j66}/ρ66{j66}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr66: ∀j66∈cells66(), ∀r66∈nodesOfCell66(j66), Ajr66{j66,r66} = ((ρ66{j66}*c66{j66})/l66{j66,r66}) * tensProduct66(C66{j66,r66}, C66{j66,r66});
ComputeFjr66: ∀j66∈cells66(), ∀r66∈nodesOfCell66(j66), F66{j66,r66} = p66{j66}*C66{j66,r66} + matVectProduct66(Ajr66{j66,r66}, (uj66{j66}-ur66{r66}));
ComputeAr66: ∀r66∈nodes66(), Ar66{r66} = ∑{j66∈cellsOfNode66(r66)}(Ajr66{j66,r66});
ComputeBr66: ∀r66∈nodes66(), b66{r66} = ∑{j66∈cellsOfNode66(r66)}(p66{j66}*C66{j66,r66} + matVectProduct66(Ajr66{j66,r66}, uj66{j66}));
ComputeMt66: ∀r66∈innerNodes66(), Mt66{r66} = Ar66{r66};
ComputeBt66: ∀r66∈innerNodes66(), bt66{r66} = b66{r66};

OuterFacesComputations66: ∀k66∈outerFaces66(), {
	const ℝ epsilon66 = 1.0e-10;
	ℝ²ˣ² I66 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN66 = 0.0;
	ℝ X_MAX66 = X_EDGE_ELEMS66 * LENGTH66;
	ℝ Y_MIN66 = 0.0; 
	ℝ Y_MAX66 = Y_EDGE_ELEMS66 * LENGTH66;
	ℝ² nY66 = {0.0,1.0};
	
	∀r66∈nodesOfFace66(k66), {
		// Y boundary conditions (must be done before X)
		if ((X66{r66}.y-Y_MIN66 < epsilon66) || (X66{r66}.y-Y_MAX66 < epsilon66)) {
			ℝ sign66 = 0.0;
			if (X66{r66}.y-Y_MIN66 < epsilon66) sign66 = -1.0;
			else sign66 = 1.0;
			ℝ² n66 = sign66 * nY66;
      		ℝ²ˣ² nxn66 = tensProduct66(n66,n66);
      		ℝ²ˣ² IcP66 = I66 - nxn66;
			bt1{r66} = matVectProduct66(IcP66, b66{r66});
			Mt1{r66} = IcP66 * (Ar66{r66} * IcP66) + nxn66*trace66(Ar66{r66});
		}

		// X boundary conditions
		if ((Math.fabs(X66{r66}.x-X_MIN66) < epsilon66) || ( (Math.fabs(X66{r66}.x-X_MAX66) < epsilon66) )) {
			Mt66{r66} = I66;
			bt66{r66} = {0.0, 0.0};
		}
	}
}


ComputeU66: ∀r66∈nodes66(), ur66{r66} = matVectProduct66(inverse66(Mt66{r66}), bt66{r66});
ComputeV66: ∀j66∈cells66(), V66{j66} = 0.5 * ∑{r66∈nodesOfCell66(j66)}(dot(C66{j66,r66},X66{r66}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn66: ∀n66∈ℕ, ∀r066∈nodes66(), X66{r066}^{n66=0}=coord66{r066}; , ∀r66∈nodes66(), X66{r66}^{n66+1}=X66{r66}^{n66}+δt66^{n66}*ur66{r66};
ComputeUn66: ∀n66∈ℕ, ∀j066∈cells66(), uj66{j066}^{n66=0}={0.0,0.0}; , ∀j66∈cells66(), uj66{j66}^{n66+1}=uj66{j66}^{n66}-(δt66^{n66}/m66{j66})*∑{r66∈nodesOfCell66(j66)}(F66{j66,r66});
ComputeEn66: ∀n66∈ℕ, ∀j066∈cells66(), E66{j066}^{n66=0}=p_ic66{j066}/((γ66-1.0)*ρ_ic66{j066}); , ∀j66∈cells66(), E66{j66}^{n66+1}=E66{j66}^{n66} - (δt66^{n66} / m66{j66}) * ∑{r66∈nodesOfCell66(j66)}(dot(F66{j66,r66},ur66{r66}));
ComputeDt66: ∀n66∈ℕ, δt66^{n66=0}=option_δt_ini66;, δt66^{n66+1}=option_δt_cfl66*reduceMin{j66∈cells66()}(δtj66{j66});
ComputeTn66: ∀n66∈ℕ, t66^{n66=0}=0.0; , t66^{n66+1}=t66^{n66}+δt66^{n66+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter67: ∀j67∈cells67(), center67{j67} = (1.0/4.0) * ∑{r67∈nodesOfCell67(j67)}(coord67{r67});
IniIc67: ∀j67∈cells67(), if (center67{j67}.x < option_x_interface67) {
  ρ_ic67{j67}=option_ρ_ini_zg67;
  p_ic67{j67}=option_p_ini_zg67;
} else {
  ρ_ic67{j67}=option_ρ_ini_zd67;
  p_ic67{j67}=option_p_ini_zd67;
}

ComputeCjrIc67: ∀j67∈cells67(), ∀r67∈nodesOfCell67(j67), 
	C_ic67{j67,r67} = 0.5 * perp67(coord67{►(r67)} - coord67{◄(r67)});
IniVIc67: ∀j67∈cells67(), V_ic67{j67} = 0.5 * ∑{r67∈nodesOfCell67(j67)}(dot(C_ic67{j67,r67}, coord67{r67}));
IniM67: ∀j67∈cells67(), m67{j67} = ρ_ic67{j67} * V_ic67{j67}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr67: ∀j67∈cells67(), ∀r67∈nodesOfCell67(j67), C67{j67,r67} = 0.5 * perp67(X67{►(r67)} - X67{◄(r67)});
ComputeLjr67: ∀j67∈cells67(), ∀r67∈nodesOfCell67(j67), l67{j67,r67} = norm(C67{j67,r67});
Computeδtj67: ∀j67∈cells67(), δtj67{j67} = 2.0 * V67{j67} / (c67{j67} * ∑{r67∈nodesOfCell67(j67)}(l67{j67,r67}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity67: ∀j67∈cells67(), ρ67{j67} = m67{j67} / V67{j67};
ComputeEOSp67: ∀j67∈cells67(), p67{j67} = (γ67-1.0) * ρ67{j67} * e67{j67};
ComputeInternalEngergy67: ∀j67∈cells67(), e67{j67} = E67{j67} - 0.5 * dot(uj67{j67}, uj67{j67});
ComputeEOSc67: ∀j67∈cells67(), c67{j67} = √(γ67*p67{j67}/ρ67{j67}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr67: ∀j67∈cells67(), ∀r67∈nodesOfCell67(j67), Ajr67{j67,r67} = ((ρ67{j67}*c67{j67})/l67{j67,r67}) * tensProduct67(C67{j67,r67}, C67{j67,r67});
ComputeFjr67: ∀j67∈cells67(), ∀r67∈nodesOfCell67(j67), F67{j67,r67} = p67{j67}*C67{j67,r67} + matVectProduct67(Ajr67{j67,r67}, (uj67{j67}-ur67{r67}));
ComputeAr67: ∀r67∈nodes67(), Ar67{r67} = ∑{j67∈cellsOfNode67(r67)}(Ajr67{j67,r67});
ComputeBr67: ∀r67∈nodes67(), b67{r67} = ∑{j67∈cellsOfNode67(r67)}(p67{j67}*C67{j67,r67} + matVectProduct67(Ajr67{j67,r67}, uj67{j67}));
ComputeMt67: ∀r67∈innerNodes67(), Mt67{r67} = Ar67{r67};
ComputeBt67: ∀r67∈innerNodes67(), bt67{r67} = b67{r67};

OuterFacesComputations67: ∀k67∈outerFaces67(), {
	const ℝ epsilon67 = 1.0e-10;
	ℝ²ˣ² I67 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN67 = 0.0;
	ℝ X_MAX67 = X_EDGE_ELEMS67 * LENGTH67;
	ℝ Y_MIN67 = 0.0; 
	ℝ Y_MAX67 = Y_EDGE_ELEMS67 * LENGTH67;
	ℝ² nY67 = {0.0,1.0};
	
	∀r67∈nodesOfFace67(k67), {
		// Y boundary conditions (must be done before X)
		if ((X67{r67}.y-Y_MIN67 < epsilon67) || (X67{r67}.y-Y_MAX67 < epsilon67)) {
			ℝ sign67 = 0.0;
			if (X67{r67}.y-Y_MIN67 < epsilon67) sign67 = -1.0;
			else sign67 = 1.0;
			ℝ² n67 = sign67 * nY67;
      		ℝ²ˣ² nxn67 = tensProduct67(n67,n67);
      		ℝ²ˣ² IcP67 = I67 - nxn67;
			bt1{r67} = matVectProduct67(IcP67, b67{r67});
			Mt1{r67} = IcP67 * (Ar67{r67} * IcP67) + nxn67*trace67(Ar67{r67});
		}

		// X boundary conditions
		if ((Math.fabs(X67{r67}.x-X_MIN67) < epsilon67) || ( (Math.fabs(X67{r67}.x-X_MAX67) < epsilon67) )) {
			Mt67{r67} = I67;
			bt67{r67} = {0.0, 0.0};
		}
	}
}


ComputeU67: ∀r67∈nodes67(), ur67{r67} = matVectProduct67(inverse67(Mt67{r67}), bt67{r67});
ComputeV67: ∀j67∈cells67(), V67{j67} = 0.5 * ∑{r67∈nodesOfCell67(j67)}(dot(C67{j67,r67},X67{r67}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn67: ∀n67∈ℕ, ∀r067∈nodes67(), X67{r067}^{n67=0}=coord67{r067}; , ∀r67∈nodes67(), X67{r67}^{n67+1}=X67{r67}^{n67}+δt67^{n67}*ur67{r67};
ComputeUn67: ∀n67∈ℕ, ∀j067∈cells67(), uj67{j067}^{n67=0}={0.0,0.0}; , ∀j67∈cells67(), uj67{j67}^{n67+1}=uj67{j67}^{n67}-(δt67^{n67}/m67{j67})*∑{r67∈nodesOfCell67(j67)}(F67{j67,r67});
ComputeEn67: ∀n67∈ℕ, ∀j067∈cells67(), E67{j067}^{n67=0}=p_ic67{j067}/((γ67-1.0)*ρ_ic67{j067}); , ∀j67∈cells67(), E67{j67}^{n67+1}=E67{j67}^{n67} - (δt67^{n67} / m67{j67}) * ∑{r67∈nodesOfCell67(j67)}(dot(F67{j67,r67},ur67{r67}));
ComputeDt67: ∀n67∈ℕ, δt67^{n67=0}=option_δt_ini67;, δt67^{n67+1}=option_δt_cfl67*reduceMin{j67∈cells67()}(δtj67{j67});
ComputeTn67: ∀n67∈ℕ, t67^{n67=0}=0.0; , t67^{n67+1}=t67^{n67}+δt67^{n67+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter68: ∀j68∈cells68(), center68{j68} = (1.0/4.0) * ∑{r68∈nodesOfCell68(j68)}(coord68{r68});
IniIc68: ∀j68∈cells68(), if (center68{j68}.x < option_x_interface68) {
  ρ_ic68{j68}=option_ρ_ini_zg68;
  p_ic68{j68}=option_p_ini_zg68;
} else {
  ρ_ic68{j68}=option_ρ_ini_zd68;
  p_ic68{j68}=option_p_ini_zd68;
}

ComputeCjrIc68: ∀j68∈cells68(), ∀r68∈nodesOfCell68(j68), 
	C_ic68{j68,r68} = 0.5 * perp68(coord68{►(r68)} - coord68{◄(r68)});
IniVIc68: ∀j68∈cells68(), V_ic68{j68} = 0.5 * ∑{r68∈nodesOfCell68(j68)}(dot(C_ic68{j68,r68}, coord68{r68}));
IniM68: ∀j68∈cells68(), m68{j68} = ρ_ic68{j68} * V_ic68{j68}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr68: ∀j68∈cells68(), ∀r68∈nodesOfCell68(j68), C68{j68,r68} = 0.5 * perp68(X68{►(r68)} - X68{◄(r68)});
ComputeLjr68: ∀j68∈cells68(), ∀r68∈nodesOfCell68(j68), l68{j68,r68} = norm(C68{j68,r68});
Computeδtj68: ∀j68∈cells68(), δtj68{j68} = 2.0 * V68{j68} / (c68{j68} * ∑{r68∈nodesOfCell68(j68)}(l68{j68,r68}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity68: ∀j68∈cells68(), ρ68{j68} = m68{j68} / V68{j68};
ComputeEOSp68: ∀j68∈cells68(), p68{j68} = (γ68-1.0) * ρ68{j68} * e68{j68};
ComputeInternalEngergy68: ∀j68∈cells68(), e68{j68} = E68{j68} - 0.5 * dot(uj68{j68}, uj68{j68});
ComputeEOSc68: ∀j68∈cells68(), c68{j68} = √(γ68*p68{j68}/ρ68{j68}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr68: ∀j68∈cells68(), ∀r68∈nodesOfCell68(j68), Ajr68{j68,r68} = ((ρ68{j68}*c68{j68})/l68{j68,r68}) * tensProduct68(C68{j68,r68}, C68{j68,r68});
ComputeFjr68: ∀j68∈cells68(), ∀r68∈nodesOfCell68(j68), F68{j68,r68} = p68{j68}*C68{j68,r68} + matVectProduct68(Ajr68{j68,r68}, (uj68{j68}-ur68{r68}));
ComputeAr68: ∀r68∈nodes68(), Ar68{r68} = ∑{j68∈cellsOfNode68(r68)}(Ajr68{j68,r68});
ComputeBr68: ∀r68∈nodes68(), b68{r68} = ∑{j68∈cellsOfNode68(r68)}(p68{j68}*C68{j68,r68} + matVectProduct68(Ajr68{j68,r68}, uj68{j68}));
ComputeMt68: ∀r68∈innerNodes68(), Mt68{r68} = Ar68{r68};
ComputeBt68: ∀r68∈innerNodes68(), bt68{r68} = b68{r68};

OuterFacesComputations68: ∀k68∈outerFaces68(), {
	const ℝ epsilon68 = 1.0e-10;
	ℝ²ˣ² I68 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN68 = 0.0;
	ℝ X_MAX68 = X_EDGE_ELEMS68 * LENGTH68;
	ℝ Y_MIN68 = 0.0; 
	ℝ Y_MAX68 = Y_EDGE_ELEMS68 * LENGTH68;
	ℝ² nY68 = {0.0,1.0};
	
	∀r68∈nodesOfFace68(k68), {
		// Y boundary conditions (must be done before X)
		if ((X68{r68}.y-Y_MIN68 < epsilon68) || (X68{r68}.y-Y_MAX68 < epsilon68)) {
			ℝ sign68 = 0.0;
			if (X68{r68}.y-Y_MIN68 < epsilon68) sign68 = -1.0;
			else sign68 = 1.0;
			ℝ² n68 = sign68 * nY68;
      		ℝ²ˣ² nxn68 = tensProduct68(n68,n68);
      		ℝ²ˣ² IcP68 = I68 - nxn68;
			bt1{r68} = matVectProduct68(IcP68, b68{r68});
			Mt1{r68} = IcP68 * (Ar68{r68} * IcP68) + nxn68*trace68(Ar68{r68});
		}

		// X boundary conditions
		if ((Math.fabs(X68{r68}.x-X_MIN68) < epsilon68) || ( (Math.fabs(X68{r68}.x-X_MAX68) < epsilon68) )) {
			Mt68{r68} = I68;
			bt68{r68} = {0.0, 0.0};
		}
	}
}


ComputeU68: ∀r68∈nodes68(), ur68{r68} = matVectProduct68(inverse68(Mt68{r68}), bt68{r68});
ComputeV68: ∀j68∈cells68(), V68{j68} = 0.5 * ∑{r68∈nodesOfCell68(j68)}(dot(C68{j68,r68},X68{r68}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn68: ∀n68∈ℕ, ∀r068∈nodes68(), X68{r068}^{n68=0}=coord68{r068}; , ∀r68∈nodes68(), X68{r68}^{n68+1}=X68{r68}^{n68}+δt68^{n68}*ur68{r68};
ComputeUn68: ∀n68∈ℕ, ∀j068∈cells68(), uj68{j068}^{n68=0}={0.0,0.0}; , ∀j68∈cells68(), uj68{j68}^{n68+1}=uj68{j68}^{n68}-(δt68^{n68}/m68{j68})*∑{r68∈nodesOfCell68(j68)}(F68{j68,r68});
ComputeEn68: ∀n68∈ℕ, ∀j068∈cells68(), E68{j068}^{n68=0}=p_ic68{j068}/((γ68-1.0)*ρ_ic68{j068}); , ∀j68∈cells68(), E68{j68}^{n68+1}=E68{j68}^{n68} - (δt68^{n68} / m68{j68}) * ∑{r68∈nodesOfCell68(j68)}(dot(F68{j68,r68},ur68{r68}));
ComputeDt68: ∀n68∈ℕ, δt68^{n68=0}=option_δt_ini68;, δt68^{n68+1}=option_δt_cfl68*reduceMin{j68∈cells68()}(δtj68{j68});
ComputeTn68: ∀n68∈ℕ, t68^{n68=0}=0.0; , t68^{n68+1}=t68^{n68}+δt68^{n68+1};

// *************************************************************
// * Init: X_ic(par le mailleur), ρ_ic, p_ic, V_ic & m
// *************************************************************
IniCenter69: ∀j69∈cells69(), center69{j69} = (1.0/4.0) * ∑{r69∈nodesOfCell69(j69)}(coord69{r69});
IniIc69: ∀j69∈cells69(), if (center69{j69}.x < option_x_interface69) {
  ρ_ic69{j69}=option_ρ_ini_zg69;
  p_ic69{j69}=option_p_ini_zg69;
} else {
  ρ_ic69{j69}=option_ρ_ini_zd69;
  p_ic69{j69}=option_p_ini_zd69;
}

ComputeCjrIc69: ∀j69∈cells69(), ∀r69∈nodesOfCell69(j69), 
	C_ic69{j69,r69} = 0.5 * perp69(coord69{►(r69)} - coord69{◄(r69)});
IniVIc69: ∀j69∈cells69(), V_ic69{j69} = 0.5 * ∑{r69∈nodesOfCell69(j69)}(dot(C_ic69{j69,r69}, coord69{r69}));
IniM69: ∀j69∈cells69(), m69{j69} = ρ_ic69{j69} * V_ic69{j69}; // m est constant


// *************************************************************
// * Calcul des C{j,r} et des variables qui en découlent
// *************************************************************
ComputeCjr69: ∀j69∈cells69(), ∀r69∈nodesOfCell69(j69), C69{j69,r69} = 0.5 * perp69(X69{►(r69)} - X69{◄(r69)});
ComputeLjr69: ∀j69∈cells69(), ∀r69∈nodesOfCell69(j69), l69{j69,r69} = norm(C69{j69,r69});
Computeδtj69: ∀j69∈cells69(), δtj69{j69} = 2.0 * V69{j69} / (c69{j69} * ∑{r69∈nodesOfCell69(j69)}(l69{j69,r69}));

// *************************************************************
// * Règles EOS standards: m, ρ, c, p, e
// *************************************************************
ComputeDensity69: ∀j69∈cells69(), ρ69{j69} = m69{j69} / V69{j69};
ComputeEOSp69: ∀j69∈cells69(), p69{j69} = (γ69-1.0) * ρ69{j69} * e69{j69};
ComputeInternalEngergy69: ∀j69∈cells69(), e69{j69} = E69{j69} - 0.5 * dot(uj69{j69}, uj69{j69});
ComputeEOSc69: ∀j69∈cells69(), c69{j69} = √(γ69*p69{j69}/ρ69{j69}); 

// *************************************************************
// * Cell-centered Godunov Scheme for Lagragian gas dynamics
// *************************************************************
ComputeAjr69: ∀j69∈cells69(), ∀r69∈nodesOfCell69(j69), Ajr69{j69,r69} = ((ρ69{j69}*c69{j69})/l69{j69,r69}) * tensProduct69(C69{j69,r69}, C69{j69,r69});
ComputeFjr69: ∀j69∈cells69(), ∀r69∈nodesOfCell69(j69), F69{j69,r69} = p69{j69}*C69{j69,r69} + matVectProduct69(Ajr69{j69,r69}, (uj69{j69}-ur69{r69}));
ComputeAr69: ∀r69∈nodes69(), Ar69{r69} = ∑{j69∈cellsOfNode69(r69)}(Ajr69{j69,r69});
ComputeBr69: ∀r69∈nodes69(), b69{r69} = ∑{j69∈cellsOfNode69(r69)}(p69{j69}*C69{j69,r69} + matVectProduct69(Ajr69{j69,r69}, uj69{j69}));
ComputeMt69: ∀r69∈innerNodes69(), Mt69{r69} = Ar69{r69};
ComputeBt69: ∀r69∈innerNodes69(), bt69{r69} = b69{r69};

OuterFacesComputations69: ∀k69∈outerFaces69(), {
	const ℝ epsilon69 = 1.0e-10;
	ℝ²ˣ² I69 = {{1.0,0.0},{0.0,1.0}};

	ℝ X_MIN69 = 0.0;
	ℝ X_MAX69 = X_EDGE_ELEMS69 * LENGTH69;
	ℝ Y_MIN69 = 0.0; 
	ℝ Y_MAX69 = Y_EDGE_ELEMS69 * LENGTH69;
	ℝ² nY69 = {0.0,1.0};
	
	∀r69∈nodesOfFace69(k69), {
		// Y boundary conditions (must be done before X)
		if ((X69{r69}.y-Y_MIN69 < epsilon69) || (X69{r69}.y-Y_MAX69 < epsilon69)) {
			ℝ sign69 = 0.0;
			if (X69{r69}.y-Y_MIN69 < epsilon69) sign69 = -1.0;
			else sign69 = 1.0;
			ℝ² n69 = sign69 * nY69;
      		ℝ²ˣ² nxn69 = tensProduct69(n69,n69);
      		ℝ²ˣ² IcP69 = I69 - nxn69;
			bt1{r69} = matVectProduct69(IcP69, b69{r69});
			Mt1{r69} = IcP69 * (Ar69{r69} * IcP69) + nxn69*trace69(Ar69{r69});
		}

		// X boundary conditions
		if ((Math.fabs(X69{r69}.x-X_MIN69) < epsilon69) || ( (Math.fabs(X69{r69}.x-X_MAX69) < epsilon69) )) {
			Mt69{r69} = I69;
			bt69{r69} = {0.0, 0.0};
		}
	}
}


ComputeU69: ∀r69∈nodes69(), ur69{r69} = matVectProduct69(inverse69(Mt69{r69}), bt69{r69});
ComputeV69: ∀j69∈cells69(), V69{j69} = 0.5 * ∑{r69∈nodesOfCell69(j69)}(dot(C69{j69,r69},X69{r69}));

// *************************************************************
// * Itérations de la boucle en 'n'
// * Et calcule du δt pour mise-à-jour du temps de la simulation
// *************************************************************
ComputeXn69: ∀n69∈ℕ, ∀r069∈nodes69(), X69{r069}^{n69=0}=coord69{r069}; , ∀r69∈nodes69(), X69{r69}^{n69+1}=X69{r69}^{n69}+δt69^{n69}*ur69{r69};
ComputeUn69: ∀n69∈ℕ, ∀j069∈cells69(), uj69{j069}^{n69=0}={0.0,0.0}; , ∀j69∈cells69(), uj69{j69}^{n69+1}=uj69{j69}^{n69}-(δt69^{n69}/m69{j69})*∑{r69∈nodesOfCell69(j69)}(F69{j69,r69});
ComputeEn69: ∀n69∈ℕ, ∀j069∈cells69(), E69{j069}^{n69=0}=p_ic69{j069}/((γ69-1.0)*ρ_ic69{j069}); , ∀j69∈cells69(), E69{j69}^{n69+1}=E69{j69}^{n69} - (δt69^{n69} / m69{j69}) * ∑{r69∈nodesOfCell69(j69)}(dot(F69{j69,r69},ur69{r69}));
ComputeDt69: ∀n69∈ℕ, δt69^{n69=0}=option_δt_ini69;, δt69^{n69+1}=option_δt_cfl69*reduceMin{j69∈cells69()}(δtj69{j69});
ComputeTn69: ∀n69∈ℕ, t69^{n69=0}=0.0; , t69^{n69+1}=t69^{n69}+δt69^{n69+1};

